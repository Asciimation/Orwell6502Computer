ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : orwell_bas.s
Current file: orwell_bas.s

000000r 1               ; Microsoft BASIC for 6502 (OSI VERSION) tweaked to run on the Orwell computer.
000000r 1               ; Simon Jansen
000000r 1               ;
000000r 1               ; October 2013
000000r 1               ; VERSION 1.0 REV 0.0
000000r 1               ; Added in my own routines for keyboard scanning and reading as well
000000r 1               ; as video output.
000000r 1               ; ROM start moved to $8000.
000000r 1               ; Space from $0200 - $0310 set aside for ORWELL variables.
000000r 1               ; RAM start set to $030F.
000000r 1               ; Width set to 38.
000000r 1               ; Added CLS BASIC command.
000000r 1               ; Added INKEY$ BASIC command.
000000r 1               ; Changed LOAD to be silent.
000000r 1               ; Added ECHOLOAD command to echo loading to the screen.
000000r 1               ; Added a MOVE (cursor) command. The row and column values are poked into memory
000000r 1               ; at locations; row = 783, column = 784
000000r 1               ;
000000r 1               ; April 2014
000000r 1               ; VERSION 1.0 REV 1.1
000000r 1               ; Updated video hardware to Grant Searles monitor/keyboard.
000000r 1               ; New character outputting routines added.
000000r 1               ; Column width set to 80 by default.
000000r 1               ; Added new variables to support graphics commands.
000000r 1               ; Changed MOVE command to use new variables.
000000r 1               ;
000000r 1               ; VERSION 1.0 REV 1.2
000000r 1               ; Added in PLOT, LINE and RECT commands.
000000r 1               ; Changed token parsing to work across 256 byte boundary.
000000r 1               ; Added SETCUR function.
000000r 1               ; Added in CIRC command.
000000r 1               ; Modified LIST command to handle token name table greater than 256 bytes.
000000r 1               ; Added FONT command.
000000r 1               ;
000000r 1               ; VERSION 1.0 REV 1.3
000000r 1               ; Changed INKEY$ to GET. Will return empty string on no key press.
000000r 1               ; Removed MEMORY and TERMINAL width prompts.
000000r 1               ;
000000r 1               ; VERSION 1.0 REV 1.4
000000r 1               ; Changes to save/load mode.
000000r 1               ;
000000r 1               ; VERSION 1.0 REV 1.5
000000r 1               ; Added in support for IO board.
000000r 1               ;
000000r 1               ; VERSION 1.0 REV 1.6
000000r 1               ; Added in support for binary loading.
000000r 1               ; Added in hooks for interrupt vector.
000000r 1               ;
000000r 1               ; VERSION 1.0 REV 1.7
000000r 1               ; Changes to the serial receive code.
000000r 1               ;
000000r 1               ; VERSION 1.0 REV 1.8
000000r 1               ; Addred flow control around parsing lines.
000000r 1               ; Reverted to 80 column default width.
000000r 1               ;
000000r 1               ; ==================================================================================
000000r 1               ;
000000r 1               ; Microsoft BASIC for 6502 (OSI VERSION)
000000r 1               ;
000000r 1               ; ==================================================================================
000000r 1               ; MODIFIED FROM THE ORIGINAL FILES AT http://www.pagetable.com/?p=46
000000r 1               ; MERGED INTO ONE FILE AND MACROS AND CONDITIONAL STATEMENTS REMOVED
000000r 1               ; BY G. SEARLE 2013
000000r 1               ;
000000r 1               ; I/O and dummy load/saves added to the end of this code
000000r 1               ;
000000r 1               ; This then assembles to the OSI version with the following
000000r 1               ; minor changes to the original BASIC code:
000000r 1               ; 1. Control-C call changed
000000r 1               ; 2. Load/save calls changed
000000r 1               ; 3. RAM start set to $0200 instead of $0300
000000r 1               ; 4. ROM start set to $C000
000000r 1               ; 5. Second letter of error messages back to ASCII value (instead of $80+val)
000000r 1               ; ==================================================================================
000000r 1               ;
000000r 1               ; Extract of original header comments follows:
000000r 1               ;
000000r 1               ; (first revision of this distribution, 20 Oct 2008, Michael Steil www.pagetable.com)
000000r 1               ;
000000r 1               ;
000000r 1               
000000r 1               ; Name                 Release   MS Version    ROM   9digit INPUTBUFFER   extensions
000000r 1               ;---------------------------------------------------------------------------------------------------
000000r 1               ; OSI BASIC             1977     1.0 REV 3.2    Y      N ZP            -
000000r 1               ;
000000r 1               ; Credits:
000000r 1               ; * main work by Michael Steil
000000r 1               ; * function names and all uppercase comments taken from Bob Sander-Cederlof's excellent AppleSoft II disassembly:
000000r 1               ;   http://www.txbobsc.com/scsc/scdocumentor/
000000r 1               ; * Applesoft lite by Tom Greene http://cowgod.org/replica1/applesoft/ helped a lot, too.
000000r 1               ; * Thanks to Joe Zbicak for help with Intellision Keyboard BASIC
000000r 1               ; * This work is dedicated to the memory of my dear hacking pal Michael "acidity" Kollmann.
000000r 1               
000000r 1               .debuginfo +
000000r 1               
000000r 1               .setcpu "6502"
000000r 1               .macpack longbranch
000000r 1               
000000r 1               ; =============================================================================
000000r 1               ; Zero page.
000000r 1               ; =============================================================================
000000r 1               
000000r 1               ZP_START1 = $00
000000r 1               ZP_START2 = $0D
000000r 1               ZP_START3 = $5B
000000r 1               ZP_START4 = $65
000000r 1               
000000r 1               ; =============================================================================
000000r 1               ; Extra ZP variables.
000000r 1               ; =============================================================================
000000r 1               
000000r 1               USR := $000A
000000r 1               
000000r 1               ; =============================================================================
000000r 1               ; Constants.
000000r 1               ; =============================================================================
000000r 1               
000000r 1               STACK_TOP           := $FC
000000r 1               SPACE_FOR_GOSUB     := $33
000000r 1               NULL_MAX            := $0A
000000r 1               WIDTH               := 80 ; SJ. 72 Original default value. 80 for Orwell machine.
000000r 1               WIDTH2              := 56
000000r 1               GRAPHICSXMAX		:= 160 ; SJ added. Maximum graphics X co-ord (160 pixels).
000000r 1               GRAPHICSYMAX		:= 100 ; SJ added. Maximum graphics Y co-ord (100 pixels).
000000r 1               
000000r 1               ; =============================================================================
000000r 1               ; Memory layout.
000000r 1               ; =============================================================================
000000r 1               
000000r 1               ORWELL_VARIABLES    := $0200        ; Added to support Orwell keyboard routines.
000000r 1               RAMSTART2           := $0320        ; Start of program RAM.
000000r 1               BYTES_FP            := 4
000000r 1               BYTES_PER_ELEMENT   := BYTES_FP
000000r 1               BYTES_PER_VARIABLE  := BYTES_FP+2
000000r 1               MANTISSA_BYTES      := BYTES_FP-1
000000r 1               BYTES_PER_FRAME     := 2*BYTES_FP+8
000000r 1               FOR_STACK1          := 2*BYTES_FP+5
000000r 1               FOR_STACK2          := BYTES_FP+4
000000r 1               MAX_EXPON           = 10
000000r 1               STACK               := $0100
000000r 1               
000000r 1               INPUTBUFFERX = INPUTBUFFER & $FF00
000000r 1               
000000r 1               ; =============================================================================
000000r 1               ; Carriage return/line feed.
000000r 1               ; =============================================================================
000000r 1               
000000r 1               CR        = $0D
000000r 1               LF        = $0A
000000r 1               CRLF_1    := CR
000000r 1               CRLF_2    := LF
000000r 1               
000000r 1               ; =============================================================================
000000r 1               ; Zero page variables.
000000r 1               ; =============================================================================
000000r 1               
000000r 1               .feature org_per_seg
000000r 1               .zeropage
000000r 1               .org $0000
000000  1               .org ZP_START1  ; $00
000000  1               
000000  1               GORESTART:
000000  1  xx xx xx         .res 3
000003  1               GOSTROUT:
000003  1  xx xx xx         .res 3
000006  1               GOAYINT:
000006  1  xx xx            .res 2
000008  1               GOGIVEAYF:
000008  1  xx xx            .res 2
00000A  1               
00000A  1               .org ZP_START2  ; $OD
00000D  1               Z15:
00000D  1  xx               .res 1
00000E  1               POSX:           ; Number of characters since last CR.
00000E  1  xx               .res 1
00000F  1               Z17:            ; Screen width for auto CR/LF.
00000F  1  xx               .res 1
000010  1               Z18:
000010  1  xx               .res 1
000011  1               LINNUM:         ; Current line number.
000011  1               TXPSV:
000011  1  xx xx            .res 2
000013  1               INPUTBUFFER:    ; Line input buffer.
000013  1               
000013  1               .org ZP_START3  ; $5B
00005B  1               CHARAC:
00005B  1  xx               .res 1      ; Alternate string terminator.
00005C  1               ENDCHR:
00005C  1  xx               .res 1      ; String terminator.
00005D  1               EOLPNTR:
00005D  1  xx               .res 1      ; String terminator.
00005E  1               DIMFLG:
00005E  1  xx               .res 1
00005F  1               VALTYP:
00005F  1  xx               .res 1
000060  1               DATAFLG:
000060  1  xx               .res 1      ; Used in parse.
000061  1               SUBFLG:
000061  1  xx               .res 1
000062  1               INPUTFLG:
000062  1  xx               .res 1      ; $40 for GET. $98 for READ.
000063  1               CPRMASK:
000063  1  xx               .res 1      ; Receives CPRTYP in FRMEVL.
000064  1               Z14:
000064  1  xx               .res 1      ; Error flag.
000065  1               
000065  1               .org ZP_START4  ; $65
000065  1               load_address:   ; SJ added April 2015.
000065  1  xx xx            .res 2
000067  1               TEMPPT:
000067  1  xx               .res 1
000068  1               LASTPT:
000068  1  xx xx            .res 2
00006A  1               TEMPST:
00006A  1  xx xx xx xx      .res 9
00006E  1  xx xx xx xx  
000072  1  xx           
000073  1               INDEX:
000073  1  xx xx            .res 2
000075  1               DEST:
000075  1  xx xx            .res 2
000077  1               RESULT:
000077  1  xx xx xx xx      .res BYTES_FP
00007B  1               RESULT_LAST = RESULT + BYTES_FP-1
00007B  1               TXTTAB:
00007B  1  xx xx            .res 2    ; Pointer to start of BASIC program space.
00007D  1               VARTAB:
00007D  1  xx xx            .res 2    ; Pointer to start of BASIC variable storage.
00007F  1               ARYTAB:
00007F  1  xx xx            .res 2    ; Pointer to start of BASIC array space.
000081  1               STREND:
000081  1  xx xx            .res 2    ; Pointer to end of array space/start of free memory.
000083  1               FRETOP:
000083  1  xx xx            .res 2    ; Pointer to end of string space/top of free memory.
000085  1               FRESPC:
000085  1  xx xx            .res 2    ; Pointer to top of BASIC memory.
000087  1               MEMSIZ:
000087  1  xx xx            .res 2
000089  1               CURLIN:
000089  1  xx xx            .res 2    ; Current line number.
00008B  1               OLDLIN:
00008B  1  xx xx            .res 2    ; Old line number.
00008D  1               OLDTEXT:
00008D  1  xx xx            .res 2
00008F  1               Z8C:
00008F  1  xx xx            .res 2
000091  1               DATPTR:
000091  1  xx xx            .res 2    ; Data pointer.
000093  1               INPTR:
000093  1  xx xx            .res 2
000095  1               VARNAM:
000095  1  xx xx            .res 2
000097  1               VARPNT:
000097  1  xx xx            .res 2
000099  1               FORPNT:
000099  1  xx xx            .res 2
00009B  1               LASTOP:
00009B  1  xx xx            .res 2
00009D  1               CPRTYP:
00009D  1  xx               .res 1
00009E  1               FNCNAM:
00009E  1               TEMP3:
00009E  1  xx xx            .res 2
0000A0  1               DSCPTR:
0000A0  1  xx xx            .res 2
0000A2  1               DSCLEN:
0000A2  1  xx xx            .res 2
0000A4  1               JMPADRS := DSCLEN + 1
0000A4  1               Z52:
0000A4  1  xx               .res 1
0000A5  1               ARGEXTENSION:
0000A5  1               TEMP1:
0000A5  1  xx               .res 1
0000A6  1               HIGHDS:
0000A6  1  xx xx            .res 2
0000A8  1               HIGHTR:
0000A8  1  xx xx            .res 2
0000AA  1               INDX:
0000AA  1               TMPEXP:
0000AA  1               TEMP2:
0000AA  1  xx               .res 1
0000AB  1               EXPON:
0000AB  1  xx               .res 1
0000AC  1               LOWTR:
0000AC  1               LOWTRX:
0000AC  1  xx               .res 1
0000AD  1               EXPSGN:
0000AD  1  xx               .res 1
0000AE  1               FAC:
0000AE  1  xx xx xx xx      .res BYTES_FP
0000B2  1               FAC_LAST = FAC + BYTES_FP-1
0000B2  1               FACSIGN:
0000B2  1  xx               .res 1
0000B3  1               SERLEN:
0000B3  1  xx               .res 1
0000B4  1               SHIFTSIGNEXT:
0000B4  1  xx               .res 1
0000B5  1               ARG:
0000B5  1  xx xx xx xx      .res BYTES_FP
0000B9  1               ARG_LAST = ARG + BYTES_FP-1
0000B9  1               ARGSIGN:
0000B9  1  xx               .res 1
0000BA  1               STRNG1:
0000BA  1  xx xx            .res 2
0000BC  1               SGNCPR = STRNG1
0000BC  1               FACEXTENSION = STRNG1+1
0000BC  1               STRNG2:
0000BC  1  xx xx            .res 2
0000BE  1               
0000BE  1               ; SJ Added April 2014.
0000BE  1               ; Variables used in graphics routines.
0000BE  1               DX:
0000BE  1  xx            	.res 1
0000BF  1               IX:
0000BF  1  xx            	.res 1
0000C0  1               DY:
0000C0  1  xx            	.res 1
0000C1  1               IY:
0000C1  1  xx            	.res 1
0000C2  1               X1:
0000C2  1  xx               .res 1
0000C3  1               Y1:
0000C3  1  xx               .res 1
0000C4  1               X2:
0000C4  1  xx               .res 1
0000C5  1               Y2:
0000C5  1  xx           	.res 1
0000C6  1               FF:
0000C6  1  xx           	.res 1
0000C7  1               Rad:
0000C7  1  xx           	.res 1
0000C8  1               
0000C8  1               ; =============================================================================
0000C8  1               ; Space allocated for code which gets copied from ROM into RAM here
0000C8  1               ; during startup.
0000C8  1               ; =============================================================================
0000C8  1               
0000C8  1               CHRGET:
0000C8  1               TXTPTR = <(GENERIC_TXTPTR-GENERIC_CHRGET + CHRGET)
0000C8  1               CHRGOT = <(GENERIC_CHRGOT-GENERIC_CHRGET + CHRGET)
0000C8  1               CHRGOT2 = <(GENERIC_CHRGOT2-GENERIC_CHRGET + CHRGET)
0000C8  1               RNDSEED = <(GENERIC_RNDSEED-GENERIC_CHRGET + CHRGET)
0000C8  1               
0000C8  1               ; =============================================================================
0000C8  1               ; Orwell specific constants.
0000C8  1               ; =============================================================================
0000C8  1               
0000C8  1               IO          := $6000        ; Top of I/O space. 8 bit buffer.
0000C8  1               via1        := $5000        ; VIA 1 I/O. Used for keyboard and video.
0000C8  1               via1_b      := via1 + $0    ; VIA port b.
0000C8  1               via1_a      := via1 + $1    ; VIA port a.
0000C8  1               via1_ddrb   := via1 + $2    ; VIA port b direction 1 = output.
0000C8  1               via1_ddra   := via1 + $3    ; VIA port a direction 1 = output.
0000C8  1               via1_t1cl   := via1 + $4    ; VIA timer 1 low latch.
0000C8  1               via1_t1ch   := via1 + $5    ; VIA timer 1 high latch.
0000C8  1               via1_acr    := via1 + $B    ; VIA auxiliary control register.
0000C8  1               via1_pcr    := via1 + $C    ; VIA peripheral control register.
0000C8  1               via1_ifr    := via1 + $D    ; VIA interrupt flag register.
0000C8  1               via1_ier    := via1 + $E    ; VIA interrupt enable register.
0000C8  1               
0000C8  1               acia1       := $4800         ; ACIA 1 I/O.
0000C8  1               acia1_d     := acia1 + $0    ; ACIA data register.
0000C8  1               acia1_s     := acia1 + $1    ; ACIA reset/status register.
0000C8  1               acia1_cm    := acia1 + $2    ; ACIA command register.
0000C8  1               acia1_ct    := acia1 + $3    ; ACIA control register.
0000C8  1               
0000C8  1               via2        := $4400        ; VIA 2 I/O. Used for analog to digital conversion.
0000C8  1               via2_b      := via2 + $0    ; VIA port b.
0000C8  1               via2_a      := via2 + $1    ; VIA port a.
0000C8  1               via2_ddrb   := via2 + $2    ; VIA port b direction 1 = output.
0000C8  1               via2_ddra   := via2 + $3    ; VIA port a direction 1 = output.
0000C8  1               via2_t1cl   := via2 + $4    ; VIA timer 1 low latch.
0000C8  1               via2_t1ch   := via2 + $5    ; VIA timer 1 high latch.
0000C8  1               via2_acr    := via2 + $B    ; VIA auxiliary control register.
0000C8  1               via2_pcr    := via2 + $C    ; VIA peripheral control register.
0000C8  1               via2_ifr    := via2 + $D    ; VIA interrupt flag register.
0000C8  1               via2_ier    := via2 + $E    ; VIA interrupt enable register.
0000C8  1               
0000C8  1               via3        := $4200        ; VIA 1 I/O. Used for general purpose IO.
0000C8  1               via3_b      := via3 + $0    ; VIA port b.
0000C8  1               via3_a      := via3 + $1    ; VIA port a.
0000C8  1               via3_ddrb   := via3 + $2    ; VIA port b direction 1 = output.
0000C8  1               via3_ddra   := via3 + $3    ; VIA port a direction 1 = output.
0000C8  1               via3_t1cl   := via3 + $4    ; VIA timer 1 low latch.
0000C8  1               via3_t1ch   := via3 + $5    ; VIA timer 1 high latch.
0000C8  1               via3_acr    := via3 + $B    ; VIA auxiliary control register.
0000C8  1               via3_pcr    := via3 + $C    ; VIA peripheral control register.
0000C8  1               via3_ifr    := via3 + $D    ; VIA interrupt flag register.
0000C8  1               via3_ier    := via3 + $E    ; VIA interrupt enable register.
0000C8  1               
0000C8  1               ; =============================================================================
0000C8  1               ; Orwell specific variables.
0000C8  1               ; =============================================================================
0000C8  1               
0000C8  1               .segment "ORWELL"
000000r 1               ;.org ORWELL_VARIABLES
000000r 1               
000000r 1               key_counter:    ; $200 Key debounce counter.
000000r 1  xx               .res 1
000001r 1               key_buffer:     ; $201 Keyboard port buffer.
000001r 1  xx               .res 1
000002r 1               key_status:     ; $202 Keyboard status: bit0 = function, bit1 = control, bit2 = shift, bit3 = alphalock,
000002r 1  xx               .res 1      ; bit6 = key pressed, bit7 = new data.
000003r 1               key_row:        ; $203 Keyboard row.
000003r 1  xx               .res 1
000004r 1               key_col:        ; $204 Keyboard column.
000004r 1  xx               .res 1
000005r 1               key_pressed:    ; $205 Key pressed (as found in the lookup table).
000005r 1  xx               .res 1
000006r 1               key_last_key:   ; $206 Last value of key pressed
000006r 1  xx               .res 1
000007r 1               key_data:       ; $207 Debounced key value available for users.
000007r 1  xx               .res 1
000008r 1               dump_number:
000008r 1  xx               .res 1      ; $208 (520) Number of bytes to dump to the screen.
000009r 1               acia1_rx_buffer:
000009r 1  xx xx xx xx      .res 256    ; $209 Reserve 256 bytes of RAM for the buffer ring itself.
00000Dr 1  xx xx xx xx  
000011r 1  xx xx xx xx  
000109r 1               acia1_rd_ptr:
000109r 1  xx               .res 1      ; $309 Buffer read pointer.
00010Ar 1               acia1_wr_ptr:
00010Ar 1  xx               .res 1      ; $30A Buffer write pointer.
00010Br 1               acia1_rx_byte:
00010Br 1  xx               .res 1      ; $30B Single byte receive buffer.
00010Cr 1               acia1_s_copy:
00010Cr 1  xx               .res 1      ; $30C ACIA status register copy.
00010Dr 1               ls_mode:
00010Dr 1  xx               .res 1      ; $30D (781) Load/Save flag. 0 = normal.
00010Er 1                   			; 1 = load. 2 = binary. 4 = save.
00010Er 1               				; Top bit set if in flow control mode.
00010Er 1               beeper:
00010Er 1  xx               .res 1      ; $30E Beeper timer 1 low value.
00010Fr 1               c_val:
00010Fr 1  xx               .res 1      ; $30F (783) C value.
000110r 1               x_val:
000110r 1  xx               .res 1      ; $310 (784) X value.
000111r 1               y_val:
000111r 1  xx               .res 1      ; $311 (785) Y value.
000112r 1               a_val:
000112r 1  xx               .res 1      ; $312 (786) A value.
000113r 1               b_val:
000113r 1  xx               .res 1      ; $313 (787) B value.
000114r 1               char_to_send:
000114r 1  xx               .res 1      ; $314 (788) Character to send.
000115r 1               char_sending:
000115r 1  xx           	.res 1      ; $315 (789) Character being sent flag.
000116r 1               load_count:
000116r 1  xx xx        	.res 2 		; $316 - $317 (790 - 791) Count of loaded bytes for binary load.
000118r 1               int_vector1:
000118r 1  xx xx        	.res 2		; $318 - $319 (792 - 793) Address of first interrupt vector.
00011Ar 1               int_vector2:
00011Ar 1  xx xx        	.res 2		; $31A - $31B (793 - 794) Address of second interrupt vector.
00011Cr 1               int_a:
00011Cr 1  xx           	.res 1		; $31C A register storage.
00011Dr 1               int_x:
00011Dr 1  xx           	.res 1		; $31D X register storage.
00011Er 1               int_y:
00011Er 1  xx           	.res 1		; $31E Y register storage.
00011Fr 1               int_p:
00011Fr 1  xx           	.res 1		; $31F P register storage.
000120r 1               
000120r 1               ; =============================================================================
000120r 1               ; Main code.
000120r 1               ; =============================================================================
000120r 1               
000120r 1               .segment "CODE"
000000r 1               ;.org $8000
000000r 1               
000000r 1               TOKEN_ADDRESS_TABLE:
000000r 1  rr rr                .word END-1
000002r 1  rr rr                .word FOR-1
000004r 1  rr rr                .word NEXT-1
000006r 1  rr rr                .word DATA-1
000008r 1  rr rr                .WORD INPUT-1
00000Ar 1  rr rr                .word DIM-1
00000Cr 1  rr rr                .word READ-1
00000Er 1  rr rr                .word LET-1
000010r 1               TOKEN_GOTO=$80+(*-TOKEN_ADDRESS_TABLE)/2
000010r 1  rr rr                .word GOTO-1
000012r 1  rr rr                .word RUN-1
000014r 1  rr rr                .word IF-1
000016r 1  rr rr                .word RESTORE-1
000018r 1               TOKEN_GOSUB=$80+(*-TOKEN_ADDRESS_TABLE)/2
000018r 1  rr rr                .word GOSUB-1
00001Ar 1  rr rr                .word POP-1
00001Cr 1               TOKEN_REM=$80+(*-TOKEN_ADDRESS_TABLE)/2
00001Cr 1  rr rr                .word REM-1
00001Er 1  rr rr                .word STOP-1
000020r 1  rr rr                .word ON-1
000022r 1  rr rr                .word NULL-1
000024r 1  rr rr                .word WAIT-1
000026r 1  rr rr                .word SAVE-1
000028r 1  rr rr                .WORD LOAD-1
00002Ar 1  rr rr                .word NORMAL-1 ; SJ Added Apr 2014.
00002Cr 1  rr rr                .WORD CLS-1 ; SJ Added Nov 2013.
00002Er 1  rr rr                .word MOVE-1 ; SJ Added Apr 2014.
000030r 1  rr rr                .WORD PLOT-1 ; SJ Added Apr 2014.
000032r 1  rr rr                .WORD LINE-1 ; SJ Added Apr 2014.
000034r 1  rr rr                .WORD RECT-1 ; SJ Added Apr 2014.
000036r 1  rr rr                .WORD CIRC-1 ; SJ Added Apr 2014.
000038r 1  rr rr                .WORD SETCUR-1 ; SJ Added Apr 2014.
00003Ar 1  rr rr                .WORD FONT-1 ; SJ Added Apr 2014.
00003Cr 1  rr rr                .word GET-1 ; SJ Added Apr 2014.
00003Er 1  rr rr                .word BINARY-1 ; SJ Added Apr 2015.
000040r 1  rr rr                .word DEF-1
000042r 1  rr rr                .word POKE-1
000044r 1               TOKEN_PRINT=$80+(*-TOKEN_ADDRESS_TABLE)/2
000044r 1  rr rr                .word PRINT-1
000046r 1  rr rr                .word CONT-1
000048r 1  rr rr                .word LIST-1
00004Ar 1  rr rr                .word CLEAR-1
00004Cr 1  rr rr                .word NEW-1
00004Er 1               TOKEN_TAB=$00+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_TO=$01+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_FN=$02+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_SPC=$03+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_THEN=$04+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_NOT=$05+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_STEP=$06+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_PLUS=$07+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_MINUS=$08+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_GREATER=$0E+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               TOKEN_EQUAL=$0F+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               NUM_TOKENS=(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1               
00004Er 1               UNFNC:
00004Er 1               TOKEN_SGN=$11+$80+(*-TOKEN_ADDRESS_TABLE)/2
00004Er 1  rr rr                .WORD SGN
000050r 1  rr rr                .word INT
000052r 1  rr rr                .word ABS
000054r 1  0A 00                .word USR
000056r 1  rr rr                .word FRE
000058r 1  rr rr                .word POS
00005Ar 1  rr rr                .word SQR
00005Cr 1  rr rr                .word RND
00005Er 1  rr rr                .word LOG
000060r 1  rr rr                .word EXP
000062r 1  rr rr                .word COS
000064r 1  rr rr                .word SIN
000066r 1  rr rr                .word TAN
000068r 1  rr rr                .word ATN
00006Ar 1  rr rr                .word PEEK
00006Cr 1  rr rr                .word LEN
00006Er 1  rr rr                .word STR
000070r 1  rr rr                .word VAL
000072r 1  rr rr                .word ASC
000074r 1  rr rr                .word CHRSTR
000076r 1               
000076r 1               TOKEN_LEFTSTR=$11+$80+(*-TOKEN_ADDRESS_TABLE)/2
000076r 1  rr rr                .word LEFTSTR
000078r 1  rr rr                .word RIGHTSTR
00007Ar 1  rr rr                .word MIDSTR
00007Cr 1               
00007Cr 1               MATHTBL:
00007Cr 1  79                   .byte   $79
00007Dr 1  rr rr                .word   FADDT-1
00007Fr 1  79                   .byte   $79
000080r 1  rr rr                .word   FSUBT-1
000082r 1  7B                   .byte   $7B
000083r 1  rr rr                .word   FMULTT-1
000085r 1  7B                   .byte   $7B
000086r 1  rr rr                .word   FDIVT-1
000088r 1  7F                   .byte   $7F
000089r 1  rr rr                .word   FPWRT-1
00008Br 1  50                   .byte   $50
00008Cr 1  rr rr                .word   TAND-1
00008Er 1  46                   .byte   $46
00008Fr 1  rr rr                .word   OR-1
000091r 1  7D                   .byte   $7D
000092r 1  rr rr                .word   NEGOP-1
000094r 1  5A                   .byte   $5A
000095r 1  rr rr                .word   EQUOP-1
000097r 1  64                   .byte   $64
000098r 1  rr rr                .word   RELOPS-1
00009Ar 1               
00009Ar 1               TOKEN_NAME_TABLE:
00009Ar 1  45 4E C4             .byte "EN", $80+'D'
00009Dr 1  46 4F D2             .byte "FO", $80+'R'
0000A0r 1  4E 45 58 D4          .byte "NEX", $80+'T'
0000A4r 1  44 41 54 C1          .byte "DAT", $80+'A'
0000A8r 1  49 4E 50 55          .byte "INPU", $80+'T'
0000ACr 1  D4           
0000ADr 1  44 49 CD             .byte "DI", $80+'M'
0000B0r 1  52 45 41 C4          .byte "REA", $80+'D'
0000B4r 1  4C 45 D4             .byte "LE", $80+'T'
0000B7r 1  47 4F 54 CF          .byte "GOT", $80+'O'
0000BBr 1  52 55 CE             .byte "RU", $80+'N'
0000BEr 1  49 C6                .byte "I", $80+'F'
0000C0r 1  52 45 53 54          .byte "RESTOR", $80+'E'
0000C4r 1  4F 52 C5     
0000C7r 1  47 4F 53 55          .byte "GOSU", $80+'B'
0000CBr 1  C2           
0000CCr 1  52 45 54 55          .byte "RETUR", $80+'N'
0000D0r 1  52 CE        
0000D2r 1  52 45 CD             .byte "RE", $80+'M'
0000D5r 1  53 54 4F D0          .byte "STO", $80+'P'
0000D9r 1  4F CE                .byte "O", $80+'N'
0000DBr 1  4E 55 4C CC          .byte "NUL", $80+'L'
0000DFr 1  57 41 49 D4          .byte "WAI", $80+'T'
0000E3r 1  53 41 56 C5          .byte "SAV", $80+'E'
0000E7r 1  4C 4F 41 C4          .BYTE "LOA", $80+'D'
0000EBr 1  4E 4F 52 4D          .byte "NORMA", $80+'L' ; SJ Added Apr 2014.
0000EFr 1  41 CC        
0000F1r 1  43 4C D3             .BYTE "CL", $80+'S' ; SJ Added Nov 2013.
0000F4r 1  4D 4F 56 C5          .BYTE "MOV", $80+'E' ; SJ Added Apr 2014.
0000F8r 1  50 4C 4F D4          .BYTE "PLO", $80+'T' ; SJ Added Apr 2014.
0000FCr 1  4C 49 4E C5          .BYTE "LIN", $80+'E' ; SJ Added Apr 2014.
000100r 1  52 45 43 D4          .BYTE "REC", $80+'T' ; SJ Added Apr 2014.
000104r 1  43 49 52 C3          .BYTE "CIR", $80+'C' ; SJ Added Apr 2014.
000108r 1  53 45 54 43          .BYTE "SETCU", $80+'R' ; SJ Added Apr 2014.
00010Cr 1  55 D2        
00010Er 1  46 4F 4E D4          .BYTE "FON", $80+'T' ; SJ Added Apr 2014.
000112r 1  47 45 D4             .BYTE "GE", $80+'T' ; SJ Added Apr 2014.
000115r 1  42 49 4E 41          .BYTE "BINAR", $80+'Y' ; SJ Added Apr 2015.
000119r 1  52 D9        
00011Br 1  44 45 C6             .byte "DE", $80+'F'
00011Er 1  50 4F 4B C5          .byte "POK", $80+'E'
000122r 1  50 52 49 4E          .byte "PRIN", $80+'T'
000126r 1  D4           
000127r 1  43 4F 4E D4          .byte "CON", $80+'T'
00012Br 1  4C 49 53 D4          .byte "LIS", $80+'T'
00012Fr 1  43 4C 45 41          .byte "CLEA", $80+'R'
000133r 1  D2           
000134r 1  4E 45 D7             .byte "NE", $80+'W'
000137r 1  54 41 42 A8          .byte "TAB", $80+'('
00013Br 1  54 CF                .byte "T", $80+'O'
00013Dr 1  46 CE                .byte "F", $80+'N'
00013Fr 1  53 50 43 A8          .byte "SPC", $80+'('
000143r 1  54 48 45 CE          .byte "THE", $80+'N'
000147r 1  4E 4F D4             .byte "NO", $80+'T'
00014Ar 1  53 54 45 D0          .byte "STE", $80+'P'
00014Er 1  AB                   .byte "", $80+'+'
00014Fr 1  AD                   .byte "", $80+'-'
000150r 1  AA                   .byte "", $80+'*'
000151r 1  AF                   .byte "", $80+'/'
000152r 1  DE                   .byte "", $80+'^'
000153r 1  41 4E C4             .byte "AN", $80+'D'
000156r 1  4F D2                .byte "O", $80+'R'
000158r 1  BE                   .byte "", $80+'>'
000159r 1  BD                   .byte "", $80+'='
00015Ar 1  BC                   .byte "", $80+'<'
00015Br 1  53 47 CE             .BYTE "SG", $80+'N'
00015Er 1  49 4E D4             .byte "IN", $80+'T'
000161r 1  41 42 D3             .byte "AB", $80+'S'
000164r 1  55 53 D2             .byte "US", $80+'R'
000167r 1  46 52 C5             .byte "FR", $80+'E'
00016Ar 1  50 4F D3             .byte "PO", $80+'S'
00016Dr 1  53 51 D2             .byte "SQ", $80+'R'
000170r 1  52 4E C4             .byte "RN", $80+'D'
000173r 1  4C 4F C7             .byte "LO", $80+'G'
000176r 1  45 58 D0             .byte "EX", $80+'P'
000179r 1  43 4F D3             .byte "CO", $80+'S'
00017Cr 1  53 49 CE             .byte "SI", $80+'N'
00017Fr 1  54 41 CE             .byte "TA", $80+'N'
000182r 1  41 54 CE             .byte "AT", $80+'N'
000185r 1  50 45 45 CB          .byte "PEE", $80+'K'
000189r 1  4C 45 CE             .byte "LE", $80+'N'
00018Cr 1  53 54 52 A4          .byte "STR", $80+'$'
000190r 1  56 41 CC             .byte "VA", $80+'L'
000193r 1  41 53 C3             .byte "AS", $80+'C'
000196r 1  43 48 52 A4          .byte "CHR", $80+'$'
00019Ar 1  4C 45 46 54          .byte "LEFT", $80+'$'
00019Er 1  A4           
00019Fr 1  52 49 47 48          .byte "RIGHT", $80+'$'
0001A3r 1  54 A4        
0001A5r 1  4D 49 44 A4          .byte "MID", $80+'$'
0001A9r 1  00                   .byte   0
0001AAr 1               
0001AAr 1               ERROR_MESSAGES:
0001AAr 1               ERR_NOFOR := <(*-ERROR_MESSAGES)
0001AAr 1  4E 46                .byte "NF"
0001ACr 1               ERR_SYNTAX := <(*-ERROR_MESSAGES)
0001ACr 1  53 4E                .byte "SN"
0001AEr 1               ERR_NOGOSUB := <(*-ERROR_MESSAGES)
0001AEr 1  52 47                .byte "RG"
0001B0r 1               ERR_NODATA := <(*-ERROR_MESSAGES)
0001B0r 1  4F 44                .byte "OD"
0001B2r 1               ERR_ILLQTY := <(*-ERROR_MESSAGES)
0001B2r 1  46 43                .byte "FC"
0001B4r 1               ERR_OVERFLOW := <(*-ERROR_MESSAGES)
0001B4r 1  4F 56                .byte "OV"
0001B6r 1               ERR_MEMFULL := <(*-ERROR_MESSAGES)
0001B6r 1  4F 4D                .byte "OM"
0001B8r 1               ERR_UNDEFSTAT := <(*-ERROR_MESSAGES)
0001B8r 1  55 53                .byte "US"
0001BAr 1               ERR_BADSUBS := <(*-ERROR_MESSAGES)
0001BAr 1  42 53                .byte "BS"
0001BCr 1               ERR_REDIMD := <(*-ERROR_MESSAGES)
0001BCr 1  44 44                .byte "DD"
0001BEr 1               ERR_ZERODIV := <(*-ERROR_MESSAGES)
0001BEr 1  2F 30                .byte "/0"
0001C0r 1               ERR_ILLDIR := <(*-ERROR_MESSAGES)
0001C0r 1  49 44                .byte "ID"
0001C2r 1               ERR_BADTYPE := <(*-ERROR_MESSAGES)
0001C2r 1  54 4D                .byte "TM"
0001C4r 1               ERR_STRLONG := <(*-ERROR_MESSAGES)
0001C4r 1  4C 53                .byte "LS"
0001C6r 1               ERR_FRMCPX := <(*-ERROR_MESSAGES)
0001C6r 1  53 54                .byte "ST"
0001C8r 1               ERR_CANTCONT := <(*-ERROR_MESSAGES)
0001C8r 1  43 4E                .byte "CN"
0001CAr 1               ERR_UNDEFFN := <(*-ERROR_MESSAGES)
0001CAr 1  55 46                .byte "UF"
0001CCr 1               
0001CCr 1               ; =============================================================================
0001CCr 1               ; Global messages: "ERROR", "IN", "OK", "BREAK".
0001CCr 1               ; =============================================================================
0001CCr 1               
0001CCr 1               QT_ERROR:
0001CCr 1  20 45 52 52          .byte   " ERROR"
0001D0r 1  4F 52        
0001D2r 1  00                   .byte   0
0001D3r 1               QT_IN:
0001D3r 1  20 49 4E 20          .byte   " IN "
0001D7r 1  00                   .byte   $00
0001D8r 1               QT_OK:
0001D8r 1  0D 0A 4F 4B          .byte   CR,LF,"OK",CR,LF
0001DCr 1  0D 0A        
0001DEr 1  00                   .byte    0
0001DFr 1               QT_BREAK:
0001DFr 1  0D 0A 42 52          .byte CR,LF,"BREAK"
0001E3r 1  45 41 4B     
0001E6r 1  00                   .byte   0
0001E7r 1               
0001E7r 1               ; =============================================================================
0001E7r 1               ; Generic stack and memory management code
0001E7r 1               ; this code is identical across all versions of
0001E7r 1               ; BASIC.
0001E7r 1               
0001E7r 1               ; CALLED BY "NEXT" AND "FOR" TO SCAN THROUGH
0001E7r 1               ; THE STACK FOR A FRAME WITH THE SAME VARIABLE.
0001E7r 1               ;
0001E7r 1               ; (FORPNT) = ADDRESS OF VARIABLE IF "FOR" OR "NEXT"
0001E7r 1               ;     = $XXFF IF CALLED FROM "RETURN"
0001E7r 1               ;     <<< BUG: SHOULD BE $FFXX >>>
0001E7r 1               ;
0001E7r 1               ;    RETURNS .NE. IF VARIABLE NOT FOUND,
0001E7r 1               ;    (X) = STACK PNTR AFTER SKIPPING ALL FRAMES
0001E7r 1               ;
0001E7r 1               ;    .EQ. IF FOUND
0001E7r 1               ;    (X) = STACK PNTR OF FRAME FOUND
0001E7r 1               ; =============================================================================
0001E7r 1               
0001E7r 1               GTFORPNT:
0001E7r 1  BA                   tsx
0001E8r 1  E8                   inx
0001E9r 1  E8                   inx
0001EAr 1  E8                   inx
0001EBr 1  E8                   inx
0001ECr 1               L2279:
0001ECr 1  BD 01 01             lda     STACK+1,x
0001EFr 1  C9 81                cmp     #$81
0001F1r 1  D0 21                bne     L22A1
0001F3r 1  A5 9A                lda     FORPNT+1
0001F5r 1  D0 0A                bne     L228E
0001F7r 1  BD 02 01             lda     STACK+2,x
0001FAr 1  85 99                sta     FORPNT
0001FCr 1  BD 03 01             lda     STACK+3,x
0001FFr 1  85 9A                sta     FORPNT+1
000201r 1               L228E:
000201r 1  DD 03 01             cmp     STACK+3,x
000204r 1  D0 07                bne     L229A
000206r 1  A5 99                lda     FORPNT
000208r 1  DD 02 01             cmp     STACK+2,x
00020Br 1  F0 07                beq     L22A1
00020Dr 1               L229A:
00020Dr 1  8A                   txa
00020Er 1  18                   clc
00020Fr 1  69 10                adc     #BYTES_PER_FRAME
000211r 1  AA                   tax
000212r 1  D0 D8                bne     L2279
000214r 1               L22A1:
000214r 1  60                   rts
000215r 1               ; =============================================================================
000215r 1               ; MOVE BLOCK OF MEMORY UP
000215r 1               ;
000215r 1               ; ON ENTRY:
000215r 1               ;    (Y,A) = (HIGHDS) = DESTINATION END+1
000215r 1               ;    (LOWTR) = LOWEST ADDRESS OF SOURCE
000215r 1               ;    (HIGHTR) = HIGHEST SOURCE ADDRESS+1
000215r 1               ; =============================================================================
000215r 1               
000215r 1               BLTU:
000215r 1  20 rr rr             jsr     REASON
000218r 1  85 81                sta     STREND
00021Ar 1  84 82                sty     STREND+1
00021Cr 1               BLTU2:
00021Cr 1  38                   sec
00021Dr 1  A5 A8                lda     HIGHTR
00021Fr 1  E5 AC                sbc     LOWTR
000221r 1  85 73                sta     INDEX
000223r 1  A8                   tay
000224r 1  A5 A9                lda     HIGHTR+1
000226r 1  E5 AD                sbc     LOWTR+1
000228r 1  AA                   tax
000229r 1  E8                   inx
00022Ar 1  98                   tya
00022Br 1  F0 23                beq     L22DD
00022Dr 1  A5 A8                lda     HIGHTR
00022Fr 1  38                   sec
000230r 1  E5 73                sbc     INDEX
000232r 1  85 A8                sta     HIGHTR
000234r 1  B0 03                bcs     L22C6
000236r 1  C6 A9                dec     HIGHTR+1
000238r 1  38                   sec
000239r 1               L22C6:
000239r 1  A5 A6                lda     HIGHDS
00023Br 1  E5 73                sbc     INDEX
00023Dr 1  85 A6                sta     HIGHDS
00023Fr 1  B0 08                bcs     L22D6
000241r 1  C6 A7                dec     HIGHDS+1
000243r 1  90 04                bcc     L22D6
000245r 1               L22D2:
000245r 1  B1 A8                lda     (HIGHTR),y
000247r 1  91 A6                sta     (HIGHDS),y
000249r 1               L22D6:
000249r 1  88                   dey
00024Ar 1  D0 F9                bne     L22D2
00024Cr 1  B1 A8                lda     (HIGHTR),y
00024Er 1  91 A6                sta     (HIGHDS),y
000250r 1               L22DD:
000250r 1  C6 A9                dec     HIGHTR+1
000252r 1  C6 A7                dec     HIGHDS+1
000254r 1  CA                   dex
000255r 1  D0 F2                bne     L22D6
000257r 1  60                   rts
000258r 1               
000258r 1               ; =============================================================================
000258r 1               ; CHECK IF ENOUGH ROOM LEFT ON STACK
000258r 1               ; FOR "FOR", "GOSUB", OR EXPRESSION EVALUATION
000258r 1               ; =============================================================================
000258r 1               
000258r 1               CHKMEM:
000258r 1  0A                   asl     a
000259r 1  69 33                adc     #SPACE_FOR_GOSUB
00025Br 1  B0 35                bcs     MEMERR
00025Dr 1  85 73                sta     INDEX
00025Fr 1  BA                   tsx
000260r 1  E4 73                cpx     INDEX
000262r 1  90 2E                bcc     MEMERR
000264r 1  60                   rts
000265r 1               ; =============================================================================
000265r 1               ; CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
000265r 1               ; (Y,A) = ADDR ARRAYS NEED TO GROW TO
000265r 1               ; =============================================================================
000265r 1               
000265r 1               REASON:
000265r 1  C4 84                cpy     FRETOP+1
000267r 1  90 28                bcc     L231E
000269r 1  D0 04                bne     L22FC
00026Br 1  C5 83                cmp     FRETOP
00026Dr 1  90 22                bcc     L231E
00026Fr 1               L22FC:
00026Fr 1  48                   pha
000270r 1  A2 08                ldx     #FAC-TEMP1-1
000272r 1  98                   tya
000273r 1               L2300:
000273r 1  48                   pha
000274r 1  B5 A5                lda     TEMP1,x
000276r 1  CA                   dex
000277r 1  10 FA                bpl     L2300
000279r 1  20 rr rr             jsr     GARBAG
00027Cr 1  A2 F8                ldx     #TEMP1-FAC+1
00027Er 1               L230B:
00027Er 1  68                   pla
00027Fr 1  95 AE                sta     FAC,x
000281r 1  E8                   inx
000282r 1  30 FA                bmi     L230B
000284r 1  68                   pla
000285r 1  A8                   tay
000286r 1  68                   pla
000287r 1  C4 84                cpy     FRETOP+1
000289r 1  90 06                bcc     L231E
00028Br 1  D0 05                bne     MEMERR
00028Dr 1  C5 83                cmp     FRETOP
00028Fr 1  B0 01                bcs     MEMERR
000291r 1               L231E:
000291r 1  60                   rts
000292r 1               MEMERR:
000292r 1  A2 0C                ldx     #ERR_MEMFULL
000294r 1               
000294r 1               ; =============================================================================
000294r 1               ; HANDLE AN ERROR
000294r 1               ;
000294r 1               ; (X)=OFFSET IN ERROR MESSAGE TABLE
000294r 1               ; (ERRFLG) > 128 IF "ON ERR" TURNED ON
000294r 1               ; (CURLIN+1) = $FF IF IN DIRECT MODE
000294r 1               ; =============================================================================
000294r 1               ERROR:
000294r 1  46 64                lsr     Z14
000296r 1  20 rr rr             jsr     CRDO
000299r 1  20 rr rr             jsr     OUTQUES
00029Cr 1  BD rr rr             lda     ERROR_MESSAGES,x
00029Fr 1  20 rr rr             jsr     OUTDO
0002A2r 1  BD rr rr             lda     ERROR_MESSAGES+1,x
0002A5r 1  20 rr rr             jsr     OUTDO
0002A8r 1  20 rr rr             jsr     STKINI
0002ABr 1  A9 rr                lda     #<QT_ERROR
0002ADr 1  A0 rr                ldy     #>QT_ERROR
0002AFr 1               
0002AFr 1               ; =============================================================================
0002AFr 1               ; PRINT STRING AT (Y,A)
0002AFr 1               ; PRINT CURRENT LINE # UNLESS IN DIRECT MODE
0002AFr 1               ; FALL INTO WARM RESTART
0002AFr 1               ; =============================================================================
0002AFr 1               
0002AFr 1               PRINT_ERROR_LINNUM:
0002AFr 1  20 rr rr             jsr     STROUT
0002B2r 1  A4 8A                ldy     CURLIN+1
0002B4r 1  C8                   iny
0002B5r 1  F0 03                beq     RESTART
0002B7r 1  20 rr rr             jsr     INPRT
0002BAr 1               
0002BAr 1               ; =============================================================================
0002BAr 1               ; WARM RESTART ENTRY
0002BAr 1               ; =============================================================================
0002BAr 1               
0002BAr 1               RESTART:
0002BAr 1               
0002BAr 1  46 64                LSR     Z14
0002BCr 1  A9 rr                LDA     #<QT_OK
0002BEr 1  A0 rr                LDY     #>QT_OK
0002C0r 1  20 03 00             JSR     GOSTROUT
0002C3r 1               
0002C3r 1                                               ; Start the ACDs free running.
0002C3r 1  A9 00                LDA     #$00            ; Set CA2 to input.
0002C5r 1  8D 0C 44             STA     via2_pcr
0002C8r 1               
0002C8r 1               L2351:                  ; The code loops here. Lines are read and acted
0002C8r 1                                       ; on then we end up back here again.
0002C8r 1               
0002C8r 1  A9 02                LDA     #%00000010       ; If we are in binary mode bit 2 is set.
0002CAr 1  2D rr rr             AND     ls_mode
0002CDr 1  F0 2B            	BEQ     RESTART_INLIN    ; Get binary input from the serial port.
0002CFr 1               
0002CFr 1  20 rr rr             JSR     MONISCNTC       ; Check if control C is pressed.
0002D2r 1  B0 20                BCS     RESTART_CTRL_C  ; Yes, so we go out of load mode.
0002D4r 1               
0002D4r 1  20 rr rr     		JSR     ACIA_Buffer_Get ; Else get the next character.
0002D7r 1  90 EF                BCC     L2351           ; If there isn't one just keep looping.
0002D9r 1  AA           		tax						; Store it in X.
0002DAr 1               
0002DAr 1               								; Store the byte in memory.
0002DAr 1  AD rr rr     		lda		load_count		; Get the count.
0002DDr 1  A8           		tay						; Store the count in Y.
0002DEr 1  8A           		txa						; Get back the value.
0002DFr 1  91 65        		sta		(load_address), y
0002E1r 1               
0002E1r 1               								; Increment the counter by one.
0002E1r 1  EE rr rr             inc 	load_count  	; Increment the LSB.
0002E4r 1  AD rr rr             lda     load_count
0002E7r 1  8D 00 60             sta     IO
0002EAr 1  D0 DC                bne     L2351           ; If the result was not zero we're done.
0002ECr 1  EE rr rr             inc 	load_count + 1  ; Increment the MSB if LSB wrapped round.
0002EFr 1  E6 66        		inc		load_address + 1; Increment the high byte of the address we're storing data into.
0002F1r 1  4C rr rr             jmp     L2351
0002F4r 1               
0002F4r 1               RESTART_CTRL_C:
0002F4r 1  20 rr rr             JSR     NORMAL    		; Normal mode.
0002F7r 1  4C rr rr             jmp     L2351
0002FAr 1               RESTART_INLIN:
0002FAr 1  20 rr rr             JSR     INLIN
0002FDr 1  86 CF                STX     TXTPTR
0002FFr 1  84 D0                STY     TXTPTR+1
000301r 1  20 C8 00             JSR     CHRGET
000304r 1               
000304r 1               ; bug in pre-1.1: CHRGET sets Z on '\0'
000304r 1               ; and ':' - a line starting with ':' in
000304r 1               ; direct mode gets ignored
000304r 1               
000304r 1  AA                   TAX
000305r 1  F0 C1                BEQ     L2351
000307r 1  48                   PHA
000308r 1  A9 01                LDA     #%00000001      ; If we are in load mode bit 1 is set.
00030Ar 1  2D rr rr         	AND     ls_mode
00030Dr 1  F0 03            	beq     RESTART_normal  ; Normal mode.
00030Fr 1  20 rr rr             jsr     Flow_Off ; While processing a line stop receiving to avoid
000312r 1                                        ; overflowing the buffer.
000312r 1                RESTART_normal:
000312r 1  68                   PLA
000313r 1  A2 FF                ldx     #$FF
000315r 1  86 8A                STX     CURLIN+1
000317r 1  90 12                bcc     NUMBERED_LINE
000319r 1  20 rr rr             jsr     PARSE_INPUT_LINE
00031Cr 1               
00031Cr 1  48                   PHA
00031Dr 1  A9 01                LDA     #%00000001      ; If we are in load mode bit 1 is set.
00031Fr 1  2D rr rr         	AND     ls_mode
000322r 1  F0 03                beq     RESTART_done  ; Normal mode.
000324r 1  20 rr rr             jsr     Flow_On  ; Start receiving again.
000327r 1               
000327r 1               RESTART_done:
000327r 1  68                   PLA
000328r 1  4C rr rr             jmp     NEWSTT2
00032Br 1               
00032Br 1               ; =============================================================================
00032Br 1               ; HANDLE NUMBERED LINE
00032Br 1               ; =============================================================================
00032Br 1               
00032Br 1               NUMBERED_LINE:
00032Br 1               
00032Br 1  20 rr rr             JSR     LINGET              ; Get the line number.
00032Er 1  20 rr rr             JSR     PARSE_INPUT_LINE    ; Parse the line.
000331r 1  84 5D                STY     EOLPNTR
000333r 1  20 rr rr             JSR     FNDLIN              ; Check if the line exists already?
000336r 1  90 44                BCC     PUT_NEW_LINE        ; It doesn't so branch and add it.
000338r 1               
000338r 1  A0 01                LDY     #$01                ; It exists already so modify it.
00033Ar 1  B1 AC                LDA     (LOWTR),y
00033Cr 1  85 74                STA     INDEX+1
00033Er 1  A5 7D                LDA     VARTAB
000340r 1  85 73                STA     INDEX
000342r 1  A5 AD                LDA     LOWTR+1
000344r 1  85 76                STA     DEST+1
000346r 1  A5 AC                LDA     LOWTR
000348r 1  88                   DEY
000349r 1  F1 AC                SBC     (LOWTR),y
00034Br 1  18                   CLC
00034Cr 1  65 7D                ADC     VARTAB
00034Er 1  85 7D                STA     VARTAB
000350r 1  85 75                STA     DEST
000352r 1  A5 7E                LDA     VARTAB+1
000354r 1  69 FF                ADC     #$FF
000356r 1  85 7E                STA     VARTAB+1
000358r 1  E5 AD                SBC     LOWTR+1
00035Ar 1  AA                   TAX
00035Br 1  38                   SEC
00035Cr 1  A5 AC                LDA     LOWTR
00035Er 1  E5 7D                SBC     VARTAB
000360r 1  A8                   TAY
000361r 1  B0 03                BCS     L23A5
000363r 1  E8                   INX
000364r 1  C6 76                DEC     DEST+1
000366r 1               L23A5:
000366r 1  18                   CLC
000367r 1  65 73                ADC     INDEX
000369r 1  90 03                BCC     L23AD
00036Br 1  C6 74                DEC     INDEX+1
00036Dr 1  18                   CLC
00036Er 1               L23AD:
00036Er 1  B1 73                LDA     (INDEX),y
000370r 1  91 75                STA     (DEST),y
000372r 1  C8                   INY
000373r 1  D0 F9                BNE     L23AD
000375r 1  E6 74                INC     INDEX+1
000377r 1  E6 76                INC     DEST+1
000379r 1  CA                   DEX
00037Ar 1  D0 F2                BNE     L23AD
00037Cr 1               
00037Cr 1               ; =============================================================================
00037Cr 1               
00037Cr 1               PUT_NEW_LINE:
00037Cr 1               
00037Cr 1  A5 13                LDA     INPUTBUFFER
00037Er 1  F0 2F                BEQ     FIX_LINKS
000380r 1  A5 87                LDA     MEMSIZ
000382r 1  A4 88                LDY     MEMSIZ+1
000384r 1  85 83                STA     FRETOP
000386r 1  84 84                STY     FRETOP+1
000388r 1  A5 7D                LDA     VARTAB
00038Ar 1  85 A8                STA     HIGHTR
00038Cr 1  65 5D                ADC     EOLPNTR
00038Er 1  85 A6                STA     HIGHDS
000390r 1  A4 7E                LDY     VARTAB+1
000392r 1  84 A9                STY     HIGHTR+1
000394r 1  90 01                BCC     L23D6
000396r 1  C8                   INY
000397r 1               L23D6:
000397r 1  84 A7                STY     HIGHDS+1
000399r 1  20 rr rr             JSR     BLTU
00039Cr 1               
00039Cr 1  A5 81                LDA     STREND
00039Er 1  A4 82                LDY     STREND+1
0003A0r 1  85 7D                STA     VARTAB
0003A2r 1  84 7E                STY     VARTAB+1
0003A4r 1  A4 5D                LDY     EOLPNTR
0003A6r 1  88                   DEY
0003A7r 1               
0003A7r 1               ; =============================================================================
0003A7r 1               ; COPY LINE INTO PROGRAM
0003A7r 1               ; =============================================================================
0003A7r 1               
0003A7r 1               L23E6:
0003A7r 1  B9 0F 00             LDA     INPUTBUFFER-4,y
0003AAr 1  91 AC                STA     (LOWTR),y
0003ACr 1  88                   DEY
0003ADr 1  10 F8                BPL     L23E6
0003AFr 1               
0003AFr 1               ; =============================================================================
0003AFr 1               ; CLEAR ALL VARIABLES
0003AFr 1               ; RE-ESTABLISH ALL FORWARD LINKS
0003AFr 1               ; =============================================================================
0003AFr 1               
0003AFr 1               FIX_LINKS:
0003AFr 1  20 rr rr             JSR     SETPTRS
0003B2r 1  A5 7B                LDA     TXTTAB
0003B4r 1  A4 7C                LDY     TXTTAB+1
0003B6r 1  85 73                STA     INDEX
0003B8r 1  84 74                STY     INDEX+1
0003BAr 1  18                   CLC
0003BBr 1               L23FA:
0003BBr 1  A0 01                LDY     #$01
0003BDr 1  B1 73                LDA     (INDEX),y
0003BFr 1  D0 03 4C rr          jeq     L2351
0003C3r 1  rr           
0003C4r 1               
0003C4r 1  A0 04                LDY     #$04
0003C6r 1               L2405:
0003C6r 1  C8                   INY
0003C7r 1  B1 73                LDA     (INDEX),y
0003C9r 1  D0 FB                BNE     L2405
0003CBr 1  C8                   INY
0003CCr 1  98                   TYA
0003CDr 1  65 73                ADC     INDEX
0003CFr 1  AA                   TAX
0003D0r 1  A0 00                LDY     #$00
0003D2r 1  91 73                STA     (INDEX),y
0003D4r 1  A5 74                LDA     INDEX+1
0003D6r 1  69 00                ADC     #$00
0003D8r 1  C8                   INY
0003D9r 1  91 73                STA     (INDEX),y
0003DBr 1  86 73                STX     INDEX
0003DDr 1  85 74                STA     INDEX+1
0003DFr 1  90 DA                BCC     L23FA    ; always
0003E1r 1               
0003E1r 1               ; =============================================================================
0003E1r 1               
0003E1r 1               L2420:
0003E1r 1  20 rr rr             JSR     OUTDO
0003E4r 1  CA                   DEX
0003E5r 1  10 08                BPL     INLIN2
0003E7r 1               L2423:
0003E7r 1  20 rr rr             JSR     OUTDO
0003EAr 1  20 rr rr             jsr     CRDO
0003EDr 1               
0003EDr 1               ; =============================================================================
0003EDr 1               ; READ A LINE, AND STRIP OFF SIGN BITS
0003EDr 1               ; =============================================================================
0003EDr 1               
0003EDr 1               INLIN:
0003EDr 1  A2 00                ldx     #$00
0003EFr 1               INLIN2:
0003EFr 1  20 rr rr             JSR     GETLN
0003F2r 1  C9 07                cmp     #$07    ; BEL character.
0003F4r 1  F0 18                beq     L2443
0003F6r 1  C9 08                CMP     #$08    ; Backspace (back arrow) character.
0003F8r 1  F0 E7                BEQ     L2420
0003FAr 1  C9 0D                CMP     #$0D    ; CR character.
0003FCr 1  F0 1F                beq     L2453
0003FEr 1  C9 20                cmp     #$20    ; Space character.
000400r 1  90 ED                bcc     INLIN2
000402r 1  C9 7D                cmp     #$7D    ; } character.
000404r 1  B0 E9                bcs     INLIN2
000406r 1  C9 40                cmp     #$40    ; @ character.
000408r 1  F0 DD                beq     L2423
00040Ar 1  C9 5F                cmp     #$5F    ; _ character.
00040Cr 1  F0 D3                BEQ     L2420
00040Er 1               
00040Er 1               L2443:
00040Er 1  E0 47                CPX     #$47    ; Check the line length.
000410r 1  B0 04                BCS     L244C
000412r 1               
000412r 1  95 13                STA     INPUTBUFFER,x   ; Store in our input buffer.
000414r 1  E8                   INX
000415r 1               cont:
000415r 1  2C                   .BYTE   $2C ; Skip the next instruction.
000416r 1               
000416r 1               L244C:
000416r 1  A9 07                lda     #$07     ; BEL character. We go DING! if the line is full.
000418r 1  20 rr rr             jsr     OUTDO
00041Br 1  D0 D2                bne     INLIN2
00041Dr 1               L2453:
00041Dr 1  4C rr rr             JMP     L29B9
000420r 1               
000420r 1               ; =============================================================================
000420r 1               ; Get a character.
000420r 1               ; =============================================================================
000420r 1               
000420r 1               GETLN:
000420r 1  A9 01                LDA     #%00000001      ; If we are in load mode bit 1 is set.
000422r 1  2D rr rr         	AND     ls_mode
000425r 1  D0 0C            	BNE     GETLN_serial    ; Get input from the serial port.
000427r 1               
000427r 1  20 rr rr             JSR     MONRDKEY        ; Else we get input from the keyboard.
00042Ar 1  4C rr rr             JMP     GETLN_key       ; Then process normally.
00042Dr 1               
00042Dr 1               GETLN_CTRL_C:
00042Dr 1  20 rr rr             JSR     NORMAL    		; Normal mode.
000430r 1  4C rr rr             JMP     GETLN_key       ; Then process normally.
000433r 1               
000433r 1               GETLN_serial:
000433r 1  20 rr rr             JSR     MONISCNTC       ; Check if control C is pressed.
000436r 1  B0 F5                BCS     GETLN_CTRL_C    ; Yes, so we go out of load mode.
000438r 1  20 rr rr             JSR     ACIA_Buffer_Get ; Else get the next character.
00043Br 1  C9 03                CMP     #3              ; Check if control C was sent.
00043Dr 1  F0 EE                BEQ     GETLN_CTRL_C    ; Yes, so we go out of load/save mode.
00043Fr 1               
00043Fr 1               GETLN_key:                      ; We got a character.
00043Fr 1  EA                   nop
000440r 1  EA                   nop
000441r 1  EA                   nop
000442r 1  EA                   nop
000443r 1  EA                   nop
000444r 1  EA                   nop
000445r 1  EA                   nop
000446r 1  EA                   nop
000447r 1  EA                   nop
000448r 1  EA                   nop
000449r 1  EA                   nop
00044Ar 1  EA                   nop
00044Br 1  EA                   nop
00044Cr 1  EA                   nop
00044Dr 1  29 7F                and     #$7F
00044Fr 1               RDKEY:
00044Fr 1  C9 0F                cmp     #$0F
000451r 1  D0 08                bne     L2465
000453r 1  48                   pha
000454r 1  A5 64                lda     Z14
000456r 1  49 FF                eor     #$FF
000458r 1  85 64                sta     Z14
00045Ar 1  68                   PLA
00045Br 1               L2465:
00045Br 1  60                   rts
00045Cr 1               ; =============================================================================
00045Cr 1               ; TOKENIZE THE INPUT LINE
00045Cr 1               ; =============================================================================
00045Cr 1               
00045Cr 1               PARSE_INPUT_LINE:
00045Cr 1               
00045Cr 1  A6 CF                LDX     TXTPTR          ; Index into unparsed line.
00045Er 1  A0 04                ldy     #$04			; Index into output line.
000460r 1  84 60                sty     DATAFLG			; Set up the dataflag.
000462r 1               L246C:
000462r 1               
000462r 1  B5 00                LDA     INPUTBUFFERX,x	; Get next input character.
000464r 1  C9 20                cmp     #$20            ; Ignore spaces.
000466r 1  F0 48                beq     L24AC
000468r 1  85 5C                sta     ENDCHR
00046Ar 1  C9 22                cmp     #$22            ; Start of quote marks.
00046Cr 1  F0 66                beq     L24D0
00046Er 1  24 60                bit     DATAFLG         ; In a DATA statement?
000470r 1  70 3E                bvs     L24AC
000472r 1  C9 3F                cmp     #$3F            ; Print '?' character.
000474r 1  D0 04                bne     L2484
000476r 1  A9 A2                lda     #TOKEN_PRINT
000478r 1  D0 36                bne     L24AC
00047Ar 1               L2484:
00047Ar 1  C9 30                cmp     #$30            ; Is it a digit?
00047Cr 1  90 04                bcc     L248C
00047Er 1  C9 3C                cmp     #$3C            ; Or punctuation?
000480r 1  90 2E                bcc     L24AC
000482r 1               
000482r 1               ; =============================================================================
000482r 1               ; SEARCH TOKEN NAME TABLE FOR MATCH STARTING
000482r 1               ; WITH CURRENT CHAR FROM INPUT LINE
000482r 1               ; SJ April 2014: Tweaked with code from Applesoft to use FAC to index
000482r 1               ; token name table rather to get past 256 byte limit.
000482r 1               ; =============================================================================
000482r 1               
000482r 1               L248C:
000482r 1  84 BC                sty     STRNG2          	; Save index into output line.
000484r 1               
000484r 1  A9 rr                LDA   	#<TOKEN_NAME_TABLE  	; Get ADL of table.
000486r 1  85 AE                STA   	FAC              		; and put it in FAC.
000488r 1  A9 rr                LDA   	#>TOKEN_NAME_TABLE  	; Get ADH of table
00048Ar 1                       			            		; and put it in FAC+1.
00048Ar 1  38                   SEC
00048Br 1  E9 01                SBC		#$01					; But take back one to account for the inc
00048Dr 1  85 AF                STA   	FAC+1					; that happens later.
00048Fr 1               
00048Fr 1  A0 00                ldy     #$00				; Y used to index table.
000491r 1  84 5D                sty     EOLPNTR				; Current token.
000493r 1  88                   dey							; Dec so we start at 0 after INY below.
000494r 1  86 CF                stx     TXTPTR				; Save position in input line.
000496r 1  CA                   DEX
000497r 1               L2496:
000497r 1  C8                   INY                     	; Y is the index into the token table.
000498r 1  D0 02                BNE		L2497
00049Ar 1  E6 AF                inc		FAC+1				; Next page in table.
00049Cr 1               L2497:
00049Cr 1  E8                   inx                     	; X is the index into the line.
00049Dr 1               L2498:
00049Dr 1  B5 00                lda     INPUTBUFFERX,x  	; Get next character.
00049Fr 1  C9 20                cmp     #$20            	; Ignore spaces.
0004A1r 1  F0 F9                beq     L2497
0004A3r 1               
0004A3r 1  38                   SEC							; Compare.
0004A4r 1  F1 AE                sbc     (FAC),y
0004A6r 1  F0 EF                beq     L2496
0004A8r 1  C9 80                cmp     #$80
0004AAr 1  D0 2F                bne     L24D7
0004ACr 1  05 5D                ora     EOLPNTR         	; Token matched.
0004AEr 1               
0004AEr 1               ; =============================================================================
0004AEr 1               ; STORE CHARACTER OR TOKEN IN OUTPUT LINE
0004AEr 1               ; =============================================================================
0004AEr 1               
0004AEr 1               L24AA:
0004AEr 1  A4 BC                ldy     STRNG2          ; Get index to output line.
0004B0r 1               L24AC:
0004B0r 1  E8                   inx
0004B1r 1  C8                   iny
0004B2r 1  99 0E 00             sta     INPUTBUFFER-5,y ; Store character or token.
0004B5r 1  B9 0E 00             lda     INPUTBUFFER-5,y ; Look for end of line or statement.
0004B8r 1  F0 37                beq     L24EA
0004BAr 1  38                   sec
0004BBr 1  E9 3A                sbc     #$3A            ; Look for :
0004BDr 1  F0 04                beq     L24BF
0004BFr 1  C9 49                cmp     #$49
0004C1r 1  D0 02                bne     L24C1
0004C3r 1               L24BF:
0004C3r 1  85 60                sta     DATAFLG
0004C5r 1               L24C1:
0004C5r 1  38                   sec
0004C6r 1  E9 54                sbc     #TOKEN_REM-':'
0004C8r 1  D0 98                bne     L246C
0004CAr 1  85 5C                sta     ENDCHR
0004CCr 1               
0004CCr 1               ; =============================================================================
0004CCr 1               ; HANDLE LITERAL (BETWEEN QUOTES) OR REMARK,
0004CCr 1               ; BY COPYING CHARS UP TO ENDCHR.
0004CCr 1               ; =============================================================================
0004CCr 1               
0004CCr 1               L24C8:
0004CCr 1  B5 00                lda     INPUTBUFFERX,x
0004CEr 1  F0 E0                beq     L24AC
0004D0r 1  C5 5C                cmp     ENDCHR
0004D2r 1  F0 DC                beq     L24AC
0004D4r 1               L24D0:
0004D4r 1  C8                   iny
0004D5r 1  99 0E 00             sta     INPUTBUFFER-5,y
0004D8r 1  E8                   inx
0004D9r 1  D0 F1                bne     L24C8
0004DBr 1               
0004DBr 1               ; =============================================================================
0004DBr 1               ; ADVANCE POINTER TO NEXT TOKEN NAME
0004DBr 1               ; =============================================================================
0004DBr 1               
0004DBr 1               L24D7:
0004DBr 1  A6 CF                ldx     TXTPTR
0004DDr 1  E6 5D                inc     EOLPNTR
0004DFr 1               L24DB:
0004DFr 1  B1 AE                LDA     (FAC),y
0004E1r 1  C8                   INY
0004E2r 1  D0 02                BNE		L24DB_a
0004E4r 1  E6 AF                INC		FAC+1
0004E6r 1                L24DB_a:
0004E6r 1  0A            		ASL
0004E7r 1  90 F6         		BCC		L24DB
0004E9r 1  B1 AE         		LDA     (FAC),y
0004EBr 1  D0 B0                bne     L2498
0004EDr 1  B5 00                lda     INPUTBUFFERX,x
0004EFr 1  10 BD                bpl     L24AA
0004F1r 1               ; ---END OF LINE------------------
0004F1r 1               L24EA:
0004F1r 1  99 10 00             STA     INPUTBUFFER-3,y
0004F4r 1  A9 12                lda     #<INPUTBUFFER-1
0004F6r 1  85 CF                sta     TXTPTR
0004F8r 1  60                   rts
0004F9r 1               
0004F9r 1               ; =============================================================================
0004F9r 1               ; SEARCH FOR LINE
0004F9r 1               ;
0004F9r 1               ; (LINNUM) = LINE # TO FIND
0004F9r 1               ; IF NOT FOUND:  CARRY = 0
0004F9r 1               ;    LOWTR POINTS AT NEXT LINE
0004F9r 1               ; IF FOUND:      CARRY = 1
0004F9r 1               ;    LOWTR POINTS AT LINE
0004F9r 1               ; =============================================================================
0004F9r 1               
0004F9r 1               FNDLIN:
0004F9r 1  A5 7B                lda     TXTTAB
0004FBr 1  A6 7C                LDX     TXTTAB+1
0004FDr 1               
0004FDr 1               FL1:
0004FDr 1  A0 01                ldy     #$01
0004FFr 1  85 AC                sta     LOWTR
000501r 1  86 AD                stx     LOWTR+1
000503r 1  B1 AC                lda     (LOWTR),y   ; End of program. Line not found.
000505r 1  F0 1F                beq     L251F
000507r 1  C8                   iny                 ; Increment.
000508r 1  C8                   iny                 ; Increment.
000509r 1  A5 12                lda     LINNUM+1    ; Compare line number lower byte.
00050Br 1  D1 AC                cmp     (LOWTR),y
00050Dr 1  90 18                bcc     L2520       ; Not found.
00050Fr 1  F0 03                beq     L250D       ; Matches.
000511r 1  88                   dey
000512r 1  D0 09                bne     L2516
000514r 1               L250D:
000514r 1  A5 11                lda     LINNUM      ; Check upper byte.
000516r 1  88                   dey
000517r 1  D1 AC                cmp     (LOWTR),y
000519r 1  90 0C                bcc     L2520       ; Branch is value less than.
00051Br 1  F0 0A                beq     L2520
00051Dr 1               L2516:
00051Dr 1  88                   dey
00051Er 1  B1 AC                lda     (LOWTR),y
000520r 1  AA                   tax
000521r 1  88                   dey
000522r 1  B1 AC                lda     (LOWTR),y
000524r 1  B0 D7                bcs     FL1
000526r 1               L251F:
000526r 1  18                   clc                 ; Line not found.
000527r 1               L2520:
000527r 1  60                   rts
000528r 1               
000528r 1               ; =============================================================================
000528r 1               ; "NEW" STATEMENT
000528r 1               ; =============================================================================
000528r 1               
000528r 1               NEW:
000528r 1  D0 FD                bne     L2520
00052Ar 1               SCRTCH:
00052Ar 1               
00052Ar 1  A9 00                lda     #$00
00052Cr 1  A8                   tay
00052Dr 1               
00052Dr 1  91 7B                STA     (TXTTAB),y
00052Fr 1  C8                   iny
000530r 1  91 7B                sta     (TXTTAB),y
000532r 1  A5 7B                lda     TXTTAB
000534r 1  69 02                adc     #$02
000536r 1  85 7D                sta     VARTAB
000538r 1  A5 7C                lda     TXTTAB+1
00053Ar 1  69 00                adc     #$00
00053Cr 1  85 7E                sta     VARTAB+1
00053Er 1               
00053Er 1               ; =============================================================================
00053Er 1               SETPTRS:
00053Er 1  20 rr rr             jsr     STXTPT
000541r 1               
000541r 1               ; =============================================================================
000541r 1               ; "CLEAR" STATEMENT
000541r 1               ; =============================================================================
000541r 1               
000541r 1               CLEARC:
000541r 1  A5 87                lda     MEMSIZ
000543r 1  A4 88                ldy     MEMSIZ+1
000545r 1  85 83                sta     FRETOP
000547r 1  84 84                sty     FRETOP+1
000549r 1  A5 7D                lda     VARTAB
00054Br 1  A4 7E                ldy     VARTAB+1
00054Dr 1  85 7F                sta     ARYTAB
00054Fr 1  84 80                sty     ARYTAB+1
000551r 1  85 81                sta     STREND
000553r 1  84 82                sty     STREND+1
000555r 1  20 rr rr             jsr     RESTORE
000558r 1               
000558r 1               ; =============================================================================
000558r 1               
000558r 1               STKINI:
000558r 1  A2 6A                ldx     #TEMPST
00055Ar 1  86 67                stx     TEMPPT
00055Cr 1  68                   pla
00055Dr 1  8D FD 01             sta     STACK+STACK_TOP+1
000560r 1  68                   pla
000561r 1  8D FE 01             sta     STACK+STACK_TOP+2
000564r 1  A2 FC                ldx     #STACK_TOP
000566r 1  9A                   txs
000567r 1  A9 00                lda     #$00
000569r 1  85 8E                sta     OLDTEXT+1
00056Br 1  85 61                sta     SUBFLG
00056Dr 1               L256A:
00056Dr 1  60                   rts
00056Er 1               
00056Er 1               ; =============================================================================
00056Er 1               ; SET TXTPTR TO BEGINNING OF PROGRAM
00056Er 1               ; =============================================================================
00056Er 1               
00056Er 1               STXTPT:
00056Er 1  18                   clc
00056Fr 1  A5 7B                lda     TXTTAB
000571r 1  69 FF                adc     #$FF
000573r 1  85 CF                sta     TXTPTR
000575r 1  A5 7C                lda     TXTTAB+1
000577r 1  69 FF                adc     #$FF
000579r 1  85 D0                sta     TXTPTR+1
00057Br 1  60                   rts
00057Cr 1               
00057Cr 1               ; =============================================================================
00057Cr 1               ; "LIST" STATEMENT
00057Cr 1               ; =============================================================================
00057Cr 1               
00057Cr 1               LIST:
00057Cr 1  90 06                BCC     L2581
00057Er 1  F0 04                beq     L2581
000580r 1  C9 AF                cmp     #TOKEN_MINUS
000582r 1  D0 E9                bne     L256A
000584r 1               L2581:
000584r 1  20 rr rr             JSR     LINGET
000587r 1  20 rr rr             jsr     FNDLIN
00058Ar 1  20 CE 00             jsr     CHRGOT
00058Dr 1  F0 0C                beq     L2598
00058Fr 1  C9 AF                cmp     #TOKEN_MINUS
000591r 1  D0 94                bne     L2520
000593r 1  20 C8 00             jsr     CHRGET
000596r 1  20 rr rr             jsr     LINGET
000599r 1  D0 8C                bne     L2520
00059Br 1               L2598:
00059Br 1  68                   pla
00059Cr 1  68                   pla
00059Dr 1  A5 11                lda     LINNUM
00059Fr 1  05 12                ora     LINNUM+1
0005A1r 1  D0 06                bne     L25A6
0005A3r 1  A9 FF                lda     #$FF
0005A5r 1  85 11                sta     LINNUM
0005A7r 1  85 12                sta     LINNUM+1
0005A9r 1               L25A6:
0005A9r 1  A0 01                ldy     #$01
0005ABr 1  84 60                sty     DATAFLG
0005ADr 1  B1 AC                lda     (LOWTRX),y
0005AFr 1  F0 41                beq     L25E5
0005B1r 1  20 rr rr             jsr     ISCNTC
0005B4r 1  20 rr rr             jsr     CRDO
0005B7r 1  C8                   iny
0005B8r 1  B1 AC                lda     (LOWTRX),y
0005BAr 1  AA                   tax
0005BBr 1  C8                   iny
0005BCr 1  B1 AC                lda     (LOWTRX),y
0005BEr 1  C5 12                cmp     LINNUM+1
0005C0r 1  D0 04                bne     L25C1
0005C2r 1  E4 11                cpx     LINNUM
0005C4r 1  F0 02                beq     L25C3
0005C6r 1               L25C1:
0005C6r 1  B0 2A                bcs     L25E5
0005C8r 1               ; ---LIST ONE LINE----------------
0005C8r 1               L25C3:
0005C8r 1  84 99                sty     FORPNT
0005CAr 1  20 rr rr             jsr     LINPRT
0005CDr 1  A9 20                lda     #$20
0005CFr 1               L25CA:
0005CFr 1  A4 99                ldy     FORPNT
0005D1r 1  29 7F                and     #$7F
0005D3r 1               L25CE:
0005D3r 1  20 rr rr             jsr     OUTDO
0005D6r 1  C9 22                cmp     #$22
0005D8r 1  D0 06                bne     LA519
0005DAr 1  A5 60                lda     DATAFLG
0005DCr 1  49 FF                eor     #$FF
0005DEr 1  85 60                sta     DATAFLG
0005E0r 1               LA519:
0005E0r 1  C8                   iny
0005E1r 1  B1 AC                lda     (LOWTRX),y
0005E3r 1  D0 10                bne     L25E8
0005E5r 1  A8                   tay
0005E6r 1  B1 AC                lda     (LOWTRX),y
0005E8r 1  AA                   tax
0005E9r 1  C8                   iny
0005EAr 1  B1 AC                lda     (LOWTRX),y
0005ECr 1  86 AC                stx     LOWTRX
0005EEr 1  85 AD                sta     LOWTRX+1
0005F0r 1  D0 B7                bne     L25A6
0005F2r 1               L25E5:
0005F2r 1  4C rr rr             jmp     RESTART
0005F5r 1               L25E8:
0005F5r 1  10 DC                bpl     L25CE
0005F7r 1  C9 FF                cmp     #$FF
0005F9r 1  F0 D8                beq     L25CE
0005FBr 1  24 60                bit     DATAFLG
0005FDr 1  30 D4                bmi     L25CE
0005FFr 1  38                   sec
000600r 1  E9 7F                sbc     #$7F
000602r 1  AA                   tax
000603r 1  84 99                sty     FORPNT
000605r 1               
000605r 1                       ; SJ April 2014. Modified this to handle
000605r 1                       ; table greater than 256 bytes.
000605r 1               
000605r 1  A9 rr                LDA   	#<TOKEN_NAME_TABLE  	; Get ADL of table.
000607r 1  85 AE                STA   	FAC              		; and put it in FAC.
000609r 1  A9 rr                LDA   	#>TOKEN_NAME_TABLE  	; Get ADH of table
00060Br 1                       			            		; and put it in FAC+1.
00060Br 1  38                   SEC
00060Cr 1  E9 01                SBC		#$01					; But take back one to account for the inc
00060Er 1  85 AF                STA   	FAC+1					; that happens later.
000610r 1  A0 FF                LDY     #$FF					; Y starts 1 less than 0.
000612r 1               
000612r 1               L25F2:
000612r 1  CA                   dex
000613r 1  F0 0B                beq     L25FD
000615r 1               L25F5:
000615r 1  C8                   iny								; Increment Y.
000616r 1                       ;lda     TOKEN_NAME_TABLE,y
000616r 1  D0 02                BNE		L25F5_a					; Check if we rolled over.
000618r 1  E6 AF                INC		FAC+1					; Next page in table.
00061Ar 1               L25F5_a:
00061Ar 1  B1 AE        		LDA 	(FAC), Y        		; Get the value.
00061Cr 1  10 F7                bpl     L25F5
00061Er 1  30 F2                bmi     L25F2
000620r 1               L25FD:
000620r 1  C8                   iny
000621r 1                       ; lda     TOKEN_NAME_TABLE,y
000621r 1  D0 02                BNE		L25FD_a					; Check if we rolled over.
000623r 1  E6 AF                INC		FAC+1					; Next page in table.
000625r 1               L25FD_a:
000625r 1  B1 AE        		LDA 	(FAC), Y        		; Get the value.
000627r 1  30 A6                bmi     L25CA
000629r 1  20 rr rr             jsr     OUTDO
00062Cr 1  D0 F2                bne     L25FD    ; always
00062Er 1               
00062Er 1               ; =============================================================================
00062Er 1               ; "FOR" STATEMENT
00062Er 1               ;
00062Er 1               ; FOR PUSHES 18 BYTES ON THE STACK:
00062Er 1               ; 2 -- TXTPTR
00062Er 1               ; 2 -- LINE NUMBER
00062Er 1               ; 5 -- INITIAL (CURRENT)  FOR VARIABLE VALUE
00062Er 1               ; 1 -- STEP SIGN
00062Er 1               ; 5 -- STEP VALUE
00062Er 1               ; 2 -- ADDRESS OF FOR VARIABLE IN VARTAB
00062Er 1               ; 1 -- FOR TOKEN ($81)
00062Er 1               ; =============================================================================
00062Er 1               
00062Er 1               FOR:
00062Er 1  A9 80                lda     #$80
000630r 1  85 61                sta     SUBFLG
000632r 1  20 rr rr             jsr     LET
000635r 1  20 rr rr             jsr     GTFORPNT
000638r 1  D0 05                bne     L2619
00063Ar 1  8A                   txa
00063Br 1  69 0D                adc     #FOR_STACK1
00063Dr 1  AA                   tax
00063Er 1  9A                   txs
00063Fr 1               L2619:
00063Fr 1  68                   pla
000640r 1  68                   pla
000641r 1  A9 08                lda     #FOR_STACK2
000643r 1  20 rr rr             jsr     CHKMEM
000646r 1  20 rr rr             jsr     DATAN
000649r 1  18                   clc
00064Ar 1  98                   tya
00064Br 1  65 CF                adc     TXTPTR
00064Dr 1  48                   pha
00064Er 1  A5 D0                lda     TXTPTR+1
000650r 1  69 00                adc     #$00
000652r 1  48                   pha
000653r 1  A5 8A                lda     CURLIN+1
000655r 1  48                   pha
000656r 1  A5 89                lda     CURLIN
000658r 1  48                   pha
000659r 1  A9 A8                lda     #TOKEN_TO
00065Br 1  20 rr rr             jsr     SYNCHR
00065Er 1  20 rr rr             jsr     CHKNUM
000661r 1  20 rr rr             jsr     FRMNUM
000664r 1  A5 B2                lda     FACSIGN
000666r 1  09 7F                ora     #$7F
000668r 1  25 AF                and     FAC+1
00066Ar 1  85 AF                sta     FAC+1
00066Cr 1  A9 rr                lda     #<STEP
00066Er 1  A0 rr                ldy     #>STEP
000670r 1  85 73                sta     INDEX
000672r 1  84 74                sty     INDEX+1
000674r 1  4C rr rr             jmp     FRM_STACK3
000677r 1               
000677r 1               ; =============================================================================
000677r 1               ; "STEP" PHRASE OF "FOR" STATEMENT
000677r 1               ; =============================================================================
000677r 1               
000677r 1               STEP:
000677r 1  A9 rr                lda     #<CON_ONE
000679r 1  A0 rr                ldy     #>CON_ONE
00067Br 1  20 rr rr             jsr     LOAD_FAC_FROM_YA
00067Er 1  20 CE 00             jsr     CHRGOT
000681r 1  C9 AD                cmp     #TOKEN_STEP
000683r 1  D0 06                bne     L2665
000685r 1  20 C8 00             jsr     CHRGET
000688r 1  20 rr rr             jsr     FRMNUM
00068Br 1               L2665:
00068Br 1  20 rr rr             jsr     SIGN
00068Er 1  20 rr rr             jsr     FRM_STACK2
000691r 1  A5 9A                lda     FORPNT+1
000693r 1  48                   pha
000694r 1  A5 99                lda     FORPNT
000696r 1  48                   pha
000697r 1  A9 81                lda     #$81
000699r 1  48                   pha
00069Ar 1               
00069Ar 1               ; =============================================================================
00069Ar 1               ; PERFORM NEXT STATEMENT
00069Ar 1               ; =============================================================================
00069Ar 1               
00069Ar 1               NEWSTT:
00069Ar 1  20 rr rr             jsr     ISCNTC
00069Dr 1  A5 CF                lda     TXTPTR
00069Fr 1  A4 D0                ldy     TXTPTR+1
0006A1r 1  F0 06                beq     L2683
0006A3r 1  85 8D                sta     OLDTEXT
0006A5r 1  84 8E                sty     OLDTEXT+1
0006A7r 1  A0 00                ldy     #$00
0006A9r 1               L2683:
0006A9r 1  B1 CF                lda     (TXTPTR),y
0006ABr 1  F0 07                beq     LA5DC           ; old: 1 cycle more on generic case
0006ADr 1  C9 3A                cmp     #$3A
0006AFr 1  F0 1D                beq     NEWSTT2
0006B1r 1               SYNERR1:
0006B1r 1  4C rr rr             jmp     SYNERR
0006B4r 1               LA5DC:
0006B4r 1  A0 02                ldy     #$02
0006B6r 1  B1 CF                lda     (TXTPTR),y
0006B8r 1  18                   clc
0006B9r 1  F0 65                beq     L2701
0006BBr 1  C8                   iny
0006BCr 1  B1 CF                lda     (TXTPTR),y
0006BEr 1  85 89                sta     CURLIN
0006C0r 1  C8                   iny
0006C1r 1  B1 CF                lda     (TXTPTR),y
0006C3r 1  85 8A                sta     CURLIN+1
0006C5r 1  98                   tya
0006C6r 1  65 CF                adc     TXTPTR
0006C8r 1  85 CF                sta     TXTPTR
0006CAr 1  90 02                bcc     NEWSTT2
0006CCr 1  E6 D0                inc     TXTPTR+1
0006CEr 1               NEWSTT2:
0006CEr 1  20 C8 00             jsr     CHRGET
0006D1r 1  20 rr rr             jsr     EXECUTE_STATEMENT
0006D4r 1  4C rr rr             jmp     NEWSTT
0006D7r 1               
0006D7r 1               ; =============================================================================
0006D7r 1               ; EXECUTE A STATEMENT
0006D7r 1               ;
0006D7r 1               ; (A) IS FIRST CHAR OF STATEMENT
0006D7r 1               ; CARRY IS SET
0006D7r 1               ; =============================================================================
0006D7r 1               
0006D7r 1               EXECUTE_STATEMENT:
0006D7r 1  F0 70                beq     RET1
0006D9r 1  38                   sec
0006DAr 1               EXECUTE_STATEMENT1:
0006DAr 1  E9 80                sbc     #$80
0006DCr 1  B0 03 4C rr          jcc     LET                     ; old: 1 cycle more on instr.
0006E0r 1  rr           
0006E1r 1               
0006E1r 1  C9 27                cmp     #NUM_TOKENS
0006E3r 1  B0 CC                bcs     SYNERR1
0006E5r 1  0A                   asl     a
0006E6r 1  A8                   tay
0006E7r 1  B9 rr rr             lda     TOKEN_ADDRESS_TABLE+1,y
0006EAr 1  48                   pha
0006EBr 1  B9 rr rr             lda     TOKEN_ADDRESS_TABLE,y
0006EEr 1  48                   pha
0006EFr 1  4C C8 00             jmp     CHRGET
0006F2r 1               
0006F2r 1               ; =============================================================================
0006F2r 1               ; "RESTORE" STATEMENT
0006F2r 1               ; =============================================================================
0006F2r 1               
0006F2r 1               RESTORE:
0006F2r 1  38                   sec
0006F3r 1  A5 7B                lda     TXTTAB
0006F5r 1  E9 01                sbc     #$01
0006F7r 1  A4 7C                ldy     TXTTAB+1
0006F9r 1  B0 01                bcs     SETDA
0006FBr 1  88                   dey
0006FCr 1               SETDA:
0006FCr 1  85 91                sta     DATPTR
0006FEr 1  84 92                sty     DATPTR+1
000700r 1  60                   rts
000701r 1               
000701r 1               ; =============================================================================
000701r 1               ; SEE IF CONTROL-C TYPED
000701r 1               ; =============================================================================
000701r 1               
000701r 1               ISCNTC:
000701r 1  20 rr rr         JSR    MONISCNTC
000704r 1  B0 01            BCS    STOP
000706r 1  60               RTS
000707r 1               
000707r 1               ; =============================================================================
000707r 1               ; "STOP" STATEMENT
000707r 1               ; =============================================================================
000707r 1               
000707r 1               STOP:
000707r 1  B0 01                bcs     END2
000709r 1               
000709r 1               ; =============================================================================
000709r 1               ; "END" STATEMENT
000709r 1               ; =============================================================================
000709r 1               
000709r 1               END:
000709r 1  18                   clc
00070Ar 1               END2:
00070Ar 1  D0 3D                bne     RET1
00070Cr 1  A5 CF                lda     TXTPTR
00070Er 1  A4 D0                ldy     TXTPTR+1
000710r 1  F0 0C                beq     END4
000712r 1  85 8D                sta     OLDTEXT
000714r 1  84 8E                sty     OLDTEXT+1
000716r 1               CONTROL_C_TYPED:
000716r 1  A5 89                lda     CURLIN
000718r 1  A4 8A                ldy     CURLIN+1
00071Ar 1  85 8B                sta     OLDLIN
00071Cr 1  84 8C                sty     OLDLIN+1
00071Er 1               END4:
00071Er 1  68                   pla
00071Fr 1  68                   pla
000720r 1               L2701:
000720r 1  A9 rr                lda     #<QT_BREAK
000722r 1  A0 rr                ldy     #>QT_BREAK
000724r 1  A2 00                ldx     #$00
000726r 1  86 64                stx     Z14
000728r 1  90 03                bcc     L270E
00072Ar 1  4C rr rr             jmp     PRINT_ERROR_LINNUM
00072Dr 1               L270E:
00072Dr 1  4C rr rr             jmp     RESTART
000730r 1               
000730r 1               ; =============================================================================
000730r 1               ; "CONT" COMMAND
000730r 1               ; =============================================================================
000730r 1               
000730r 1               CONT:
000730r 1  D0 17                bne     RET1
000732r 1  A2 1E                ldx     #ERR_CANTCONT
000734r 1  A4 8E                ldy     OLDTEXT+1
000736r 1  D0 03                bne     L271C
000738r 1  4C rr rr             jmp     ERROR
00073Br 1               L271C:
00073Br 1  A5 8D                lda     OLDTEXT
00073Dr 1  85 CF                sta     TXTPTR
00073Fr 1  84 D0                sty     TXTPTR+1
000741r 1  A5 8B                lda     OLDLIN
000743r 1  A4 8C                ldy     OLDLIN+1
000745r 1  85 89                sta     CURLIN
000747r 1  84 8A                sty     CURLIN+1
000749r 1               RET1:
000749r 1  60                   rts
00074Ar 1               
00074Ar 1               ; =============================================================================
00074Ar 1               ; "NULL" COMMAND
00074Ar 1               ; =============================================================================
00074Ar 1               
00074Ar 1               NULL:
00074Ar 1  20 rr rr             jsr     GETBYT
00074Dr 1  D0 FA                bne     RET1
00074Fr 1  E8                   inx
000750r 1  E0 0A                cpx     #NULL_MAX
000752r 1  B0 04                bcs     L2739
000754r 1  CA                   dex
000755r 1  86 0D                stx     Z15
000757r 1  60                   rts
000758r 1               L2739:
000758r 1  4C rr rr             jmp     IQERR
00075Br 1               CLEAR:
00075Br 1  D0 EC                bne     RET1
00075Dr 1  4C rr rr             jmp     CLEARC
000760r 1               
000760r 1               ; =============================================================================
000760r 1               ; "RUN" COMMAND
000760r 1               ; =============================================================================
000760r 1               
000760r 1               RUN:
000760r 1  D0 03                bne     L27CF
000762r 1  4C rr rr             jmp     SETPTRS
000765r 1               L27CF:
000765r 1  20 rr rr             jsr     CLEARC
000768r 1  4C rr rr             jmp     L27E9
00076Br 1               
00076Br 1               ; =============================================================================
00076Br 1               ; "GOSUB" STATEMENT
00076Br 1               ;
00076Br 1               ; LEAVES 7 BYTES ON STACK:
00076Br 1               ; 2 -- RETURN ADDRESS (NEWSTT)
00076Br 1               ; 2 -- TXTPTR
00076Br 1               ; 2 -- LINE #
00076Br 1               ; 1 -- GOSUB TOKEN
00076Br 1               ; =============================================================================
00076Br 1               
00076Br 1               GOSUB:
00076Br 1  A9 03                lda     #$03
00076Dr 1  20 rr rr             jsr     CHKMEM
000770r 1  A5 D0                lda     TXTPTR+1
000772r 1  48                   pha
000773r 1  A5 CF                lda     TXTPTR
000775r 1  48                   pha
000776r 1  A5 8A                lda     CURLIN+1
000778r 1  48                   pha
000779r 1  A5 89                lda     CURLIN
00077Br 1  48                   pha
00077Cr 1  A9 8C                lda     #TOKEN_GOSUB
00077Er 1  48                   pha
00077Fr 1               L27E9:
00077Fr 1  20 CE 00             jsr     CHRGOT
000782r 1  20 rr rr             jsr     GOTO
000785r 1  4C rr rr             jmp     NEWSTT
000788r 1               
000788r 1               ; =============================================================================
000788r 1               ; "GOTO" STATEMENT
000788r 1               ; ALSO USED BY "RUN" AND "GOSUB"
000788r 1               ; =============================================================================
000788r 1               
000788r 1               GOTO:
000788r 1  20 rr rr             jsr     LINGET
00078Br 1  20 rr rr             jsr     REMN
00078Er 1  A5 8A                lda     CURLIN+1
000790r 1  C5 12                cmp     LINNUM+1
000792r 1  B0 0B                bcs     L2809
000794r 1  98                   tya
000795r 1  38                   sec
000796r 1  65 CF                adc     TXTPTR
000798r 1  A6 D0                ldx     TXTPTR+1
00079Ar 1  90 07                bcc     L280D
00079Cr 1  E8                   inx
00079Dr 1  B0 04                bcs     L280D
00079Fr 1               L2809:
00079Fr 1  A5 7B                lda     TXTTAB
0007A1r 1  A6 7C                ldx     TXTTAB+1
0007A3r 1               L280D:
0007A3r 1  20 rr rr             jsr     FL1
0007A6r 1  90 1E                bcc     UNDERR
0007A8r 1  A5 AC                lda     LOWTRX
0007AAr 1  E9 01                sbc     #$01
0007ACr 1  85 CF                sta     TXTPTR
0007AEr 1  A5 AD                lda     LOWTRX+1
0007B0r 1  E9 00                sbc     #$00
0007B2r 1  85 D0                sta     TXTPTR+1
0007B4r 1               L281E:
0007B4r 1  60                   rts
0007B5r 1               
0007B5r 1               ; =============================================================================
0007B5r 1               ; "POP" AND "RETURN" STATEMENTS
0007B5r 1               ; =============================================================================
0007B5r 1               
0007B5r 1               POP:
0007B5r 1  D0 FD                bne     L281E
0007B7r 1  A9 FF                lda     #$FF
0007B9r 1  85 99                sta     FORPNT
0007BBr 1  20 rr rr             jsr     GTFORPNT
0007BEr 1  9A                   txs
0007BFr 1  C9 8C                cmp     #TOKEN_GOSUB
0007C1r 1  F0 0B                beq     RETURN
0007C3r 1  A2 04                ldx     #ERR_NOGOSUB
0007C5r 1  2C                   .byte   $2C
0007C6r 1               UNDERR:
0007C6r 1  A2 0E                ldx     #ERR_UNDEFSTAT
0007C8r 1  4C rr rr             jmp     ERROR
0007CBr 1               
0007CBr 1               ; =============================================================================
0007CBr 1               
0007CBr 1               SYNERR2:
0007CBr 1  4C rr rr             jmp     SYNERR
0007CEr 1               
0007CEr 1               ; =============================================================================
0007CEr 1               
0007CEr 1               RETURN:
0007CEr 1  68                   pla
0007CFr 1  68                   pla
0007D0r 1  85 89                sta     CURLIN
0007D2r 1  68                   pla
0007D3r 1  85 8A                sta     CURLIN+1
0007D5r 1  68                   pla
0007D6r 1  85 CF                sta     TXTPTR
0007D8r 1  68                   pla
0007D9r 1  85 D0                sta     TXTPTR+1
0007DBr 1               
0007DBr 1               ; =============================================================================
0007DBr 1               ; "DATA" STATEMENT
0007DBr 1               ; EXECUTED BY SKIPPING TO NEXT COLON OR EOL
0007DBr 1               ; =============================================================================
0007DBr 1               
0007DBr 1               DATA:
0007DBr 1  20 rr rr             jsr     DATAN
0007DEr 1               
0007DEr 1               ; =============================================================================
0007DEr 1               ; ADD (Y) TO TXTPTR
0007DEr 1               ; =============================================================================
0007DEr 1               
0007DEr 1               ADDON:
0007DEr 1  98                   tya
0007DFr 1  18                   clc
0007E0r 1  65 CF                adc     TXTPTR
0007E2r 1  85 CF                sta     TXTPTR
0007E4r 1  90 02                bcc     L2852
0007E6r 1  E6 D0                inc     TXTPTR+1
0007E8r 1               L2852:
0007E8r 1  60                   rts
0007E9r 1               
0007E9r 1               ; =============================================================================
0007E9r 1               ; SCAN AHEAD TO NEXT ":" OR EOL
0007E9r 1               ; =============================================================================
0007E9r 1               
0007E9r 1               DATAN:
0007E9r 1  A2 3A                ldx     #$3A
0007EBr 1  2C                   .byte   $2C
0007ECr 1               REMN:
0007ECr 1  A2 00                ldx     #$00
0007EEr 1  86 5B                stx     CHARAC
0007F0r 1  A0 00                ldy     #$00
0007F2r 1  84 5C                sty     ENDCHR
0007F4r 1               L285E:
0007F4r 1  A5 5C                lda     ENDCHR
0007F6r 1  A6 5B                ldx     CHARAC
0007F8r 1  85 5B                sta     CHARAC
0007FAr 1  86 5C                stx     ENDCHR
0007FCr 1               L2866:
0007FCr 1  B1 CF                lda     (TXTPTR),y
0007FEr 1  F0 E8                beq     L2852
000800r 1  C5 5C                cmp     ENDCHR
000802r 1  F0 E4                beq     L2852
000804r 1  C8                   iny
000805r 1  C9 22                cmp     #$22
000807r 1  F0 EB                beq     L285E           ; old: swap & cont is faster
000809r 1  D0 F1                bne     L2866
00080Br 1               
00080Br 1               ; =============================================================================
00080Br 1               ; "IF" STATEMENT
00080Br 1               ; =============================================================================
00080Br 1               
00080Br 1               IF:
00080Br 1  20 rr rr             jsr     FRMEVL
00080Er 1  20 CE 00             jsr     CHRGOT
000811r 1  C9 88                cmp     #TOKEN_GOTO
000813r 1  F0 05                beq     L2884
000815r 1  A9 AB                lda     #TOKEN_THEN
000817r 1  20 rr rr             jsr     SYNCHR
00081Ar 1               L2884:
00081Ar 1  A5 AE                lda     FAC
00081Cr 1  D0 05                bne     L288D
00081Er 1               
00081Er 1               ; =============================================================================
00081Er 1               ; "REM" STATEMENT, OR FALSE "IF" STATEMENT
00081Er 1               ; =============================================================================
00081Er 1               
00081Er 1               REM:
00081Er 1  20 rr rr             jsr     REMN
000821r 1  F0 BB                beq     ADDON
000823r 1               L288D:
000823r 1  20 CE 00             jsr     CHRGOT
000826r 1  B0 03                bcs     L2895
000828r 1  4C rr rr             jmp     GOTO
00082Br 1               L2895:
00082Br 1  4C rr rr             jmp     EXECUTE_STATEMENT
00082Er 1               
00082Er 1               ; =============================================================================
00082Er 1               ; "ON" STATEMENT
00082Er 1               ;
00082Er 1               ; ON <EXP> GOTO <LIST>
00082Er 1               ; ON <EXP> GOSUB <LIST>
00082Er 1               ; =============================================================================
00082Er 1               
00082Er 1               ON:
00082Er 1  20 rr rr             jsr     GETBYT
000831r 1  48                   pha
000832r 1  C9 8C                cmp     #TOKEN_GOSUB
000834r 1  F0 04                beq     L28A4
000836r 1               L28A0:
000836r 1  C9 88                cmp     #TOKEN_GOTO
000838r 1  D0 91                bne     SYNERR2
00083Ar 1               L28A4:
00083Ar 1  C6 B1                dec     FAC_LAST
00083Cr 1  D0 04                bne     L28AC
00083Er 1  68                   pla
00083Fr 1  4C rr rr             jmp     EXECUTE_STATEMENT1
000842r 1               L28AC:
000842r 1  20 C8 00             jsr     CHRGET
000845r 1  20 rr rr             jsr     LINGET
000848r 1  C9 2C                cmp     #$2C
00084Ar 1  F0 EE                beq     L28A4
00084Cr 1  68                   pla
00084Dr 1               L28B7:
00084Dr 1  60                   rts
00084Er 1               
00084Er 1               ; =============================================================================
00084Er 1               ; CONVERT LINE NUMBER
00084Er 1               ; =============================================================================
00084Er 1               
00084Er 1               LINGET:
00084Er 1               
00084Er 1  A2 00                ldx     #$00
000850r 1  86 11                stx     LINNUM
000852r 1  86 12                STX     LINNUM+1
000854r 1               
000854r 1               L28BE:
000854r 1               
000854r 1  B0 F7            bcs     L28B7
000856r 1  E9 2F                sbc     #$2F
000858r 1  85 5B                STA     CHARAC
00085Ar 1  A5 12                lda     LINNUM+1
00085Cr 1  85 73                sta     INDEX
00085Er 1  C9 19                cmp     #$19
000860r 1  B0 D4                bcs     L28A0
000862r 1               
000862r 1               ; <<<<<DANGEROUS CODE>>>>>
000862r 1               ; NOTE THAT IF (A) = $AB ON THE LINE ABOVE,
000862r 1               ; ON.1 WILL COMPARE = AND CAUSE A CATASTROPHIC
000862r 1               ; JUMP TO $22D9 (FOR GOTO), OR OTHER LOCATIONS
000862r 1               ; FOR OTHER CALLS TO LINGET.
000862r 1               ;
000862r 1               ; YOU CAN SEE THIS IS YOU FIRST PUT "BRK" IN $22D9,
000862r 1               ; THEN TYPE "GO TO 437761".
000862r 1               ;
000862r 1               ; ANY VALUE FROM 437760 THROUGH 440319 WILL CAUSE
000862r 1               ; THE PROBLEM.  ($AB00 - $ABFF)
000862r 1               ; <<<<<DANGEROUS CODE>>>>>
000862r 1               
000862r 1  A5 11                LDA     LINNUM
000864r 1  0A                   asl     a
000865r 1  26 73                rol     INDEX
000867r 1  0A                   asl     a
000868r 1  26 73                rol     INDEX
00086Ar 1  65 11                adc     LINNUM
00086Cr 1  85 11                sta     LINNUM
00086Er 1  A5 73                lda     INDEX
000870r 1  65 12                adc     LINNUM+1
000872r 1  85 12                sta     LINNUM+1
000874r 1  06 11                asl     LINNUM
000876r 1  26 12                rol     LINNUM+1
000878r 1  A5 11                lda     LINNUM
00087Ar 1  65 5B                adc     CHARAC
00087Cr 1  85 11                sta     LINNUM
00087Er 1  90 02                bcc     L28EC
000880r 1  E6 12                INC     LINNUM+1
000882r 1               
000882r 1               
000882r 1               L28EC:
000882r 1  20 C8 00             jsr     CHRGET
000885r 1  4C rr rr             jmp     L28BE
000888r 1               
000888r 1               ; =============================================================================
000888r 1               ; "LET" STATEMENT
000888r 1               ;
000888r 1               ; LET <VAR> = <EXP>
000888r 1               ; <VAR> = <EXP>
000888r 1               ; =============================================================================
000888r 1               
000888r 1               LET:
000888r 1  20 rr rr             jsr     PTRGET
00088Br 1  85 99                sta     FORPNT
00088Dr 1  84 9A                sty     FORPNT+1
00088Fr 1  A9 B6                lda     #TOKEN_EQUAL
000891r 1  20 rr rr             jsr     SYNCHR
000894r 1  A5 5F                lda     VALTYP
000896r 1  48                   pha
000897r 1  20 rr rr             jsr     FRMEVL
00089Ar 1  68                   pla
00089Br 1  2A                   rol     a
00089Cr 1  20 rr rr             jsr     CHKVAL
00089Fr 1  D0 03                bne     LETSTRING
0008A1r 1               
0008A1r 1               ; =============================================================================
0008A1r 1               ; REAL VARIABLE = EXPRESSION
0008A1r 1               ; =============================================================================
0008A1r 1               
0008A1r 1  4C rr rr             jmp     SETFOR
0008A4r 1               
0008A4r 1               LETSTRING:
0008A4r 1               
0008A4r 1               ; =============================================================================
0008A4r 1               ; INSTALL STRING, DESCRIPTOR ADDRESS IS AT FAC+3,4
0008A4r 1               ; =============================================================================
0008A4r 1               
0008A4r 1  A0 02                ldy     #$02
0008A6r 1  B1 B0                lda     (FAC_LAST-1),y
0008A8r 1  C5 84                cmp     FRETOP+1
0008AAr 1  90 17                bcc     L2946
0008ACr 1  D0 07                bne     L2938
0008AEr 1  88                   dey
0008AFr 1  B1 B0                lda     (FAC_LAST-1),y
0008B1r 1  C5 83                cmp     FRETOP
0008B3r 1  90 0E                bcc     L2946
0008B5r 1               L2938:
0008B5r 1  A4 B1                ldy     FAC_LAST
0008B7r 1  C4 7E                cpy     VARTAB+1
0008B9r 1  90 08                bcc     L2946
0008BBr 1  D0 0D                bne     L294D
0008BDr 1  A5 B0                lda     FAC_LAST-1
0008BFr 1  C5 7D                cmp     VARTAB
0008C1r 1  B0 07                bcs     L294D
0008C3r 1               L2946:
0008C3r 1  A5 B0                lda     FAC_LAST-1
0008C5r 1  A4 B1                ldy     FAC_LAST
0008C7r 1  4C rr rr             jmp     L2963
0008CAr 1               L294D:
0008CAr 1  A0 00                ldy     #$00
0008CCr 1  B1 B0                lda     (FAC_LAST-1),y
0008CEr 1  20 rr rr             jsr     STRINI
0008D1r 1  A5 A0                lda     DSCPTR
0008D3r 1  A4 A1                ldy     DSCPTR+1
0008D5r 1  85 BA                sta     STRNG1
0008D7r 1  84 BB                sty     STRNG1+1
0008D9r 1  20 rr rr             jsr     MOVINS
0008DCr 1  A9 AE                lda     #FAC
0008DEr 1  A0 00                ldy     #$00
0008E0r 1               L2963:
0008E0r 1  85 A0                sta     DSCPTR
0008E2r 1  84 A1                sty     DSCPTR+1
0008E4r 1  20 rr rr             jsr     FRETMS
0008E7r 1  A0 00                ldy     #$00
0008E9r 1  B1 A0                lda     (DSCPTR),y
0008EBr 1  91 99                sta     (FORPNT),y
0008EDr 1  C8                   iny
0008EEr 1  B1 A0                lda     (DSCPTR),y
0008F0r 1  91 99                sta     (FORPNT),y
0008F2r 1  C8                   iny
0008F3r 1  B1 A0                lda     (DSCPTR),y
0008F5r 1  91 99                sta     (FORPNT),y
0008F7r 1  60                   rts
0008F8r 1               PRSTRING:
0008F8r 1  20 rr rr             jsr     STRPRT
0008FBr 1               L297E:
0008FBr 1  20 CE 00             jsr     CHRGOT
0008FEr 1               
0008FEr 1               ; =============================================================================
0008FEr 1               ; "PRINT" STATEMENT
0008FEr 1               ; =============================================================================
0008FEr 1               
0008FEr 1               PRINT:
0008FEr 1  F0 3B                beq     CRDO
000900r 1               PRINT2:
000900r 1  F0 57                beq     L29DD
000902r 1  C9 A7                cmp     #TOKEN_TAB
000904r 1  F0 6B                beq     L29F5
000906r 1  C9 AA                cmp     #TOKEN_SPC
000908r 1  F0 67                beq     L29F5
00090Ar 1  C9 2C                cmp     #','
00090Cr 1  F0 4C                beq     L29DE
00090Er 1  C9 3B                cmp     #$3B
000910r 1  F0 7A                beq     L2A0D
000912r 1  20 rr rr             jsr     FRMEVL
000915r 1  24 5F                bit     VALTYP
000917r 1  30 DF                bmi     PRSTRING
000919r 1  20 rr rr             jsr     FOUT
00091Cr 1  20 rr rr             jsr     STRLIT
00091Fr 1  A0 00                ldy     #$00
000921r 1  B1 B0                lda     (FAC_LAST-1),y
000923r 1  18                   clc
000924r 1  65 0E                adc     POSX
000926r 1  C5 0F                cmp     Z17
000928r 1  90 03                bcc     L29B1
00092Ar 1  20 rr rr             jsr     CRDO
00092Dr 1               L29B1:
00092Dr 1  20 rr rr             jsr     STRPRT
000930r 1  20 rr rr             jsr     OUTSP
000933r 1  D0 C6                bne     L297E ; branch always
000935r 1               L29B9:
000935r 1  A0 00                ldy     #$00
000937r 1  94 13                STY     INPUTBUFFER,x
000939r 1  A2 12                LDX     #LINNUM+1
00093Br 1               
00093Br 1               CRDO:
00093Br 1  A9 0D                lda     #CRLF_1
00093Dr 1  85 0E                sta     POSX
00093Fr 1  20 rr rr             jsr     OUTDO
000942r 1  A9 0A                lda     #CRLF_2
000944r 1  20 rr rr             jsr     OUTDO
000947r 1               
000947r 1               PRINTNULLS:
000947r 1  8A                   txa
000948r 1  48                   pha
000949r 1  A6 0D                ldx     Z15
00094Br 1  F0 08                beq     L29D9
00094Dr 1  A9 00                lda     #$00
00094Fr 1               L29D3:
00094Fr 1  20 rr rr             jsr     OUTDO
000952r 1  CA                   dex
000953r 1  D0 FA                bne     L29D3
000955r 1               L29D9:
000955r 1  86 0E                stx     POSX
000957r 1  68                   pla
000958r 1  AA                   tax
000959r 1               L29DD:
000959r 1  60                   rts
00095Ar 1               L29DE:
00095Ar 1  A5 0E                lda     POSX
00095Cr 1  C5 10                cmp     Z18
00095Er 1  90 06                bcc     L29EA
000960r 1  20 rr rr             jsr     CRDO
000963r 1  4C rr rr             jmp     L2A0D
000966r 1               L29EA:
000966r 1  38                   sec
000967r 1               L29EB:
000967r 1  E9 0E                sbc     #$0E
000969r 1  B0 FC                bcs     L29EB
00096Br 1  49 FF                eor     #$FF
00096Dr 1  69 01                adc     #$01
00096Fr 1  D0 14                bne     L2A08
000971r 1               L29F5:
000971r 1  48                   pha
000972r 1  20 rr rr             jsr     GTBYTC
000975r 1  C9 29                cmp     #')'
000977r 1  D0 76                bne     SYNERR4
000979r 1  68                   pla
00097Ar 1  C9 A7                cmp     #TOKEN_TAB
00097Cr 1  D0 08                bne     L2A0A
00097Er 1  8A                   txa
00097Fr 1  E5 0E                sbc     POSX
000981r 1  90 09                bcc     L2A0D
000983r 1  F0 07                beq     L2A0D
000985r 1               L2A08:
000985r 1  AA                   tax
000986r 1               L2A0A:
000986r 1  20 rr rr             jsr     OUTSP
000989r 1  CA                   dex
00098Ar 1  D0 FA                bne     L2A0A
00098Cr 1               L2A0D:
00098Cr 1  20 C8 00             jsr     CHRGET
00098Fr 1  4C rr rr             jmp     PRINT2
000992r 1               
000992r 1               ; =============================================================================
000992r 1               ; PRINT STRING AT (Y,A)
000992r 1               ; =============================================================================
000992r 1               
000992r 1               STROUT:
000992r 1  20 rr rr             jsr     STRLIT
000995r 1               
000995r 1               ; =============================================================================
000995r 1               ; PRINT STRING AT (FACMO,FACLO)
000995r 1               ; =============================================================================
000995r 1               
000995r 1               STRPRT:
000995r 1  20 rr rr             jsr     FREFAC
000998r 1  AA                   tax
000999r 1  A0 00                ldy     #$00
00099Br 1  E8                   inx
00099Cr 1               L2A22:
00099Cr 1  CA                   dex
00099Dr 1  F0 BA                beq     L29DD
00099Fr 1  B1 73                lda     (INDEX),y
0009A1r 1  20 rr rr             jsr     OUTDO
0009A4r 1  C8                   iny
0009A5r 1  C9 0D                cmp     #$0D
0009A7r 1  D0 F3                bne     L2A22
0009A9r 1  20 rr rr             jsr     PRINTNULLS
0009ACr 1  4C rr rr             jmp     L2A22
0009AFr 1               ; =============================================================================
0009AFr 1               
0009AFr 1               OUTSP:
0009AFr 1  A9 20                lda     #$20
0009B1r 1  2C                   .byte   $2C
0009B2r 1               OUTQUES:
0009B2r 1  A9 3F                lda     #$3F
0009B4r 1               
0009B4r 1               ; =============================================================================
0009B4r 1               ; PRINT CHAR FROM (A)
0009B4r 1               ; =============================================================================
0009B4r 1               
0009B4r 1               OUTDO:
0009B4r 1  24 64                bit     Z14
0009B6r 1  30 1C                bmi     L2A56
0009B8r 1               ; Commodore forgot to remove this in CBM1
0009B8r 1  48                   pha
0009B9r 1  C9 07                cmp     #$07    ; Bell.
0009BBr 1  F0 1A                beq     OUTDO_bell
0009BDr 1               OUTDO_1:
0009BDr 1  C9 20                cmp     #$20
0009BFr 1  90 0B                BCC     L2A4E
0009C1r 1  A5 0E                LDA     POSX
0009C3r 1  C5 0F                cmp     Z17    ; Screen width.
0009C5r 1  D0 03                BNE     L2A4C
0009C7r 1  20 rr rr             jsr     CRDO
0009CAr 1               L2A4C:
0009CAr 1  E6 0E                inc     POSX
0009CCr 1               L2A4E:
0009CCr 1               ; Commodore forgot to remove this in CBM1
0009CCr 1  68                   PLA
0009CDr 1  20 rr rr             jsr     MONCOUT
0009D0r 1  EA                   nop
0009D1r 1  EA                   nop
0009D2r 1  EA                   nop
0009D3r 1  EA                   nop
0009D4r 1               L2A56:
0009D4r 1  29 FF                and     #$FF
0009D6r 1  60                   rts
0009D7r 1               OUTDO_bell:
0009D7r 1  20 rr rr             jsr     Beep1
0009DAr 1  4C rr rr             jmp     OUTDO_1
0009DDr 1               
0009DDr 1               
0009DDr 1               ; =============================================================================
0009DDr 1               ; ???
0009DDr 1               ; INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
0009DDr 1               ; IN NUMERIC FIELD.  MUST DISTINGUISH
0009DDr 1               ; BETWEEN INPUT, READ, AND GET
0009DDr 1               ; =============================================================================
0009DDr 1               
0009DDr 1               INPUTERR:
0009DDr 1  A5 62                lda     INPUTFLG
0009DFr 1  F0 11                beq     RESPERR     ; INPUT
0009E1r 1                                           ; without this, it treats GET errors
0009E1r 1                                           ; like READ errors
0009E1r 1               
0009E1r 1  30 04        		BMI     L2A63		; READ
0009E3r 1  A0 FF        		LDY     #$FF		; GET
0009E5r 1  D0 04        		BNE     L2A67
0009E7r 1               
0009E7r 1               
0009E7r 1               L2A63:
0009E7r 1  A5 8F                lda     Z8C
0009E9r 1  A4 90                LDY     Z8C+1
0009EBr 1               L2A67:
0009EBr 1  85 89                sta     CURLIN
0009EDr 1  84 8A                sty     CURLIN+1
0009EFr 1               SYNERR4:
0009EFr 1  4C rr rr             jmp     SYNERR
0009F2r 1               RESPERR:
0009F2r 1  A9 rr                lda     #<ERRREENTRY
0009F4r 1  A0 rr                ldy     #>ERRREENTRY
0009F6r 1  20 rr rr             jsr     STROUT
0009F9r 1  A5 8D                lda     OLDTEXT
0009FBr 1  A4 8E                ldy     OLDTEXT+1
0009FDr 1  85 CF                sta     TXTPTR
0009FFr 1  84 D0                sty     TXTPTR+1
000A01r 1  60                   rts
000A02r 1               
000A02r 1               ; =============================================================================
000A02r 1               ; "GET" STATEMENT
000A02r 1               ; SJ April 2014. Added back in GET functionality.
000A02r 1               ; =============================================================================
000A02r 1               GET:
000A02r 1  20 rr rr     	jsr     ERRDIR
000A05r 1  A2 14        	LDX     #<(INPUTBUFFER+1)
000A07r 1  A0 00        	LDY     #>(INPUTBUFFER+1)
000A09r 1               
000A09r 1  84 14        	STY     INPUTBUFFER+1
000A0Br 1  A9 40        	LDA     #$40
000A0Dr 1               
000A0Dr 1  20 rr rr     	JSR     PROCESS_INPUT_LIST
000A10r 1  60           	RTS
000A11r 1               
000A11r 1               ; =============================================================================
000A11r 1               ; "INPUT#" STATEMENT
000A11r 1               ; "INPUT" STATEMENT
000A11r 1               ; =============================================================================
000A11r 1               
000A11r 1               INPUT:
000A11r 1  46 64                lsr     Z14
000A13r 1  C9 22                cmp     #$22
000A15r 1  D0 0B                bne     L2A9E
000A17r 1  20 rr rr             jsr     STRTXT
000A1Ar 1  A9 3B                lda     #$3B
000A1Cr 1  20 rr rr             jsr     SYNCHR
000A1Fr 1  20 rr rr             jsr     STRPRT
000A22r 1               L2A9E:
000A22r 1  20 rr rr             jsr     ERRDIR
000A25r 1  A9 2C                lda     #$2C
000A27r 1  85 12                sta     INPUTBUFFER-1
000A29r 1  20 rr rr             jsr     NXIN
000A2Cr 1  A5 13                lda     INPUTBUFFER
000A2Er 1  D0 12                bne     L2ABE
000A30r 1  18                   clc
000A31r 1  4C rr rr             jmp     CONTROL_C_TYPED
000A34r 1               NXIN:
000A34r 1  20 rr rr             jsr     OUTQUES    ; '?'
000A37r 1  20 rr rr             jsr     OUTSP
000A3Ar 1  4C rr rr             jmp     INLIN
000A3Dr 1               
000A3Dr 1               ; =============================================================================
000A3Dr 1               ; "GETC" STATEMENT
000A3Dr 1               ; "READ" STATEMENT
000A3Dr 1               ; =============================================================================
000A3Dr 1               
000A3Dr 1               READ:
000A3Dr 1  A6 91                ldx     DATPTR
000A3Fr 1  A4 92                ldy     DATPTR+1
000A41r 1               ; AppleSoft II, too
000A41r 1  A9                   .byte   $A9    ; LDA #$98
000A42r 1               L2ABE:
000A42r 1  98                   tya
000A43r 1               
000A43r 1               ; =============================================================================
000A43r 1               ; PROCESS INPUT LIST
000A43r 1               ;
000A43r 1               ; (Y,X) IS ADDRESS OF INPUT DATA STRING
000A43r 1               ; (A) = VALUE FOR INPUTFLG:  $00 FOR INPUT
000A43r 1               ;                 $40 FOR GET
000A43r 1               ;                $98 FOR READ
000A43r 1               ; =============================================================================
000A43r 1               PROCESS_INPUT_LIST:
000A43r 1  85 62                sta     INPUTFLG
000A45r 1  86 93                stx     INPTR
000A47r 1  84 94                sty     INPTR+1
000A49r 1               PROCESS_INPUT_ITEM:
000A49r 1  20 rr rr             jsr     PTRGET
000A4Cr 1  85 99                sta     FORPNT
000A4Er 1  84 9A                sty     FORPNT+1
000A50r 1  A5 CF                lda     TXTPTR
000A52r 1  A4 D0                ldy     TXTPTR+1
000A54r 1  85 11                sta     TXPSV
000A56r 1  84 12                sty     TXPSV+1
000A58r 1  A6 93                ldx     INPTR
000A5Ar 1  A4 94                ldy     INPTR+1
000A5Cr 1  86 CF                stx     TXTPTR
000A5Er 1  84 D0                sty     TXTPTR+1
000A60r 1  20 CE 00             jsr     CHRGOT
000A63r 1  D0 1F                bne     INSTART
000A65r 1  24 62                BIT     INPUTFLG
000A67r 1  50 0F                BVC		L2AF0			; SJ April 2014. Adding GET back in.
000A69r 1               
000A69r 1  20 rr rr             JSR     Matrix_Scan     ; Scan the key matrix.
000A6Cr 1  AD rr rr         	LDA     key_pressed     ; Will return the ASCII value of the key or zero.
000A6Fr 1  85 13                STA 	INPUTBUFFER		; Store it.
000A71r 1               
000A71r 1               ; BUG: The beq/bne L2AF8 below is supposed
000A71r 1               ; to be always taken. For this to happen,
000A71r 1               ; the last load must be a 0 for beq
000A71r 1               ; and != 0 for bne. The original Microsoft
000A71r 1               ; code had ldx/ldy/bne here, which was only
000A71r 1               ; correct for a non-ZP INPUTBUFFER. Commodore
000A71r 1               ; fixed it in CBMBASIC V1 by swapping the
000A71r 1               ; ldx and the ldy. It was broken on KIM,
000A71r 1               ; but okay on APPLE and CBM2, because
000A71r 1               ; these used a non-ZP INPUTBUFFER.
000A71r 1               ; Microsoft fixed this somewhere after KIM
000A71r 1               ; and before MICROTAN, by using beq instead
000A71r 1               ; of bne in the ZP case.
000A71r 1               
000A71r 1  A0 00                LDY     #>(INPUTBUFFER-1)
000A73r 1               
000A73r 1  A2 12                LDX		#<(INPUTBUFFER-1)
000A75r 1  4C rr rr             jmp     L2AF8	; Always. SJ April changed branch to jump.
000A78r 1               
000A78r 1               L2AF0:
000A78r 1  30 6F                BMI     FINDATA
000A7Ar 1  20 rr rr             jsr     OUTQUES
000A7Dr 1  20 rr rr             JSR     NXIN
000A80r 1               L2AF8:
000A80r 1  86 CF                stx     TXTPTR
000A82r 1  84 D0                sty     TXTPTR+1
000A84r 1               ; =============================================================================
000A84r 1               
000A84r 1               INSTART:
000A84r 1  20 C8 00             jsr     CHRGET
000A87r 1  24 5F                bit     VALTYP
000A89r 1  10 31                bpl     L2B34
000A8Br 1               
000A8Br 1  24 62                BIT     INPUTFLG	; SJ April 2014. Adding GET back in.
000A8Dr 1  50 09                bvc     L2B10
000A8Fr 1               
000A8Fr 1  E8                 	INX
000A90r 1  86 CF             	STX     TXTPTR
000A92r 1  A9 00             	LDA     #$00
000A94r 1  85 5B             	STA     CHARAC
000A96r 1  F0 0C             	beq     L2B1C
000A98r 1               
000A98r 1               L2B10:
000A98r 1  85 5B                STA     CHARAC
000A9Ar 1  C9 22                cmp     #$22
000A9Cr 1  F0 07                beq     L2B1D
000A9Er 1  A9 3A                lda     #$3A
000AA0r 1  85 5B                sta     CHARAC
000AA2r 1  A9 2C                LDA     #$2C
000AA4r 1               L2B1C:
000AA4r 1  18                   clc
000AA5r 1               L2B1D:
000AA5r 1  85 5C                sta     ENDCHR
000AA7r 1  A5 CF                lda     TXTPTR
000AA9r 1  A4 D0                ldy     TXTPTR+1
000AABr 1  69 00                adc     #$00
000AADr 1  90 01                bcc     L2B28
000AAFr 1  C8                   iny
000AB0r 1               L2B28:
000AB0r 1  20 rr rr             jsr     STRLT2
000AB3r 1  20 rr rr             jsr     POINT
000AB6r 1  20 rr rr             jsr     LETSTRING
000AB9r 1  4C rr rr             jmp     INPUT_MORE
000ABCr 1               
000ABCr 1               ; =============================================================================
000ABCr 1               L2B34:
000ABCr 1  20 rr rr             jsr     FIN
000ABFr 1  20 rr rr             jsr     SETFOR
000AC2r 1               ; =============================================================================
000AC2r 1               
000AC2r 1               INPUT_MORE:
000AC2r 1  20 CE 00             jsr     CHRGOT
000AC5r 1  F0 07                beq     L2B48
000AC7r 1  C9 2C                cmp     #$2C
000AC9r 1  F0 03                beq     L2B48
000ACBr 1  4C rr rr             jmp     INPUTERR
000ACEr 1               L2B48:
000ACEr 1  A5 CF                lda     TXTPTR
000AD0r 1  A4 D0                ldy     TXTPTR+1
000AD2r 1  85 93                sta     INPTR
000AD4r 1  84 94                sty     INPTR+1
000AD6r 1  A5 11                lda     TXPSV
000AD8r 1  A4 12                ldy     TXPSV+1
000ADAr 1  85 CF                sta     TXTPTR
000ADCr 1  84 D0                sty     TXTPTR+1
000ADEr 1  20 CE 00             jsr     CHRGOT
000AE1r 1  F0 2C                beq     INPDONE
000AE3r 1  20 rr rr             jsr     CHKCOM
000AE6r 1  4C rr rr             jmp     PROCESS_INPUT_ITEM
000AE9r 1               
000AE9r 1               ; =============================================================================
000AE9r 1               
000AE9r 1               FINDATA:
000AE9r 1  20 rr rr             jsr     DATAN
000AECr 1  C8                   iny
000AEDr 1  AA                   tax
000AEEr 1  D0 12                bne     L2B7C
000AF0r 1  A2 06                ldx     #ERR_NODATA
000AF2r 1  C8                   iny
000AF3r 1  B1 CF                lda     (TXTPTR),y
000AF5r 1  F0 69                beq     GERR
000AF7r 1  C8                   iny
000AF8r 1  B1 CF                lda     (TXTPTR),y
000AFAr 1  85 8F                sta     Z8C
000AFCr 1  C8                   iny
000AFDr 1  B1 CF                lda     (TXTPTR),y
000AFFr 1  C8                   iny
000B00r 1  85 90                sta     Z8C+1
000B02r 1               L2B7C:
000B02r 1  B1 CF                lda     (TXTPTR),y
000B04r 1  AA                   tax
000B05r 1  20 rr rr             jsr     ADDON
000B08r 1  E0 83                cpx     #$83
000B0Ar 1  D0 DD                bne     FINDATA
000B0Cr 1  4C rr rr             jmp     INSTART
000B0Fr 1               ; ---NO MORE INPUT REQUESTED------
000B0Fr 1               INPDONE:
000B0Fr 1  A5 93                lda     INPTR
000B11r 1  A4 94                ldy     INPTR+1
000B13r 1  A6 62                ldx     INPUTFLG
000B15r 1  10 03                bpl     L2B94       ; INPUT or GET
000B17r 1  4C rr rr             jmp     SETDA
000B1Ar 1               L2B94:
000B1Ar 1  A0 00                ldy     #$00
000B1Cr 1  B1 93                lda     (INPTR),y
000B1Er 1  F0 07                beq     L2BA1
000B20r 1  A9 rr                lda     #<ERREXTRA
000B22r 1  A0 rr                ldy     #>ERREXTRA
000B24r 1  4C rr rr             jmp     STROUT
000B27r 1               L2BA1:
000B27r 1  60                   rts
000B28r 1               ; =============================================================================
000B28r 1               
000B28r 1               ERREXTRA:
000B28r 1  3F 45 58 54          .byte   "?EXTRA IGNORED"
000B2Cr 1  52 41 20 49  
000B30r 1  47 4E 4F 52  
000B36r 1               
000B36r 1               
000B36r 1  0D 0A 00             .byte   $0D,$0A,$00
000B39r 1               ERRREENTRY:
000B39r 1  3F 52 45 44          .byte   "?REDO FROM START"
000B3Dr 1  4F 20 46 52  
000B41r 1  4F 4D 20 53  
000B49r 1               
000B49r 1               
000B49r 1  0D 0A 00             .byte   $0D,$0A,$00
000B4Cr 1               
000B4Cr 1               ; =============================================================================
000B4Cr 1               ; "NEXT" STATEMENT
000B4Cr 1               ; =============================================================================
000B4Cr 1               
000B4Cr 1               NEXT:
000B4Cr 1  D0 04                bne     NEXT1
000B4Er 1  A0 00                ldy     #$00
000B50r 1  F0 03                beq     NEXT2
000B52r 1               NEXT1:
000B52r 1  20 rr rr             jsr     PTRGET
000B55r 1               NEXT2:
000B55r 1  85 99                sta     FORPNT
000B57r 1  84 9A                sty     FORPNT+1
000B59r 1  20 rr rr             jsr     GTFORPNT
000B5Cr 1  F0 04                beq     NEXT3
000B5Er 1  A2 00                ldx     #$00
000B60r 1               GERR:
000B60r 1  F0 68                beq     JERROR
000B62r 1               NEXT3:
000B62r 1  9A                   txs
000B63r 1  E8                   inx
000B64r 1  E8                   inx
000B65r 1  E8                   inx
000B66r 1  E8                   inx
000B67r 1  8A                   txa
000B68r 1  E8                   inx
000B69r 1  E8                   inx
000B6Ar 1  E8                   inx
000B6Br 1  E8                   inx
000B6Cr 1  E8                   inx
000B6Dr 1  86 75                stx     DEST
000B6Fr 1  A0 01                ldy     #>STACK
000B71r 1  20 rr rr             jsr     LOAD_FAC_FROM_YA
000B74r 1  BA                   tsx
000B75r 1  BD 08 01             lda     STACK+BYTES_FP+4,x
000B78r 1  85 B2                sta     FACSIGN
000B7Ar 1  A5 99                lda     FORPNT
000B7Cr 1  A4 9A                ldy     FORPNT+1
000B7Er 1  20 rr rr             jsr     FADD
000B81r 1  20 rr rr             jsr     SETFOR
000B84r 1  A0 01                ldy     #>STACK
000B86r 1  20 rr rr             jsr     FCOMP2
000B89r 1  BA                   tsx
000B8Ar 1  38                   sec
000B8Br 1  FD 08 01             sbc     STACK+BYTES_FP+4,x
000B8Er 1  F0 17                beq     L2C22
000B90r 1  BD 0D 01             lda     STACK+2*BYTES_FP+5,x
000B93r 1  85 89                sta     CURLIN
000B95r 1  BD 0E 01             lda     STACK+2*BYTES_FP+6,x
000B98r 1  85 8A                sta     CURLIN+1
000B9Ar 1  BD 10 01             lda     STACK+2*BYTES_FP+8,x
000B9Dr 1  85 CF                sta     TXTPTR
000B9Fr 1  BD 0F 01             lda     STACK+2*BYTES_FP+7,x
000BA2r 1  85 D0                sta     TXTPTR+1
000BA4r 1               L2C1F:
000BA4r 1  4C rr rr             jmp     NEWSTT
000BA7r 1               L2C22:
000BA7r 1  8A                   txa
000BA8r 1  69 0F                adc     #2*BYTES_FP+7
000BAAr 1  AA                   tax
000BABr 1  9A                   txs
000BACr 1  20 CE 00             jsr     CHRGOT
000BAFr 1  C9 2C                cmp     #$2C
000BB1r 1  D0 F1                bne     L2C1F
000BB3r 1  20 C8 00             jsr     CHRGET
000BB6r 1  20 rr rr             jsr     NEXT1
000BB9r 1               
000BB9r 1               ; =============================================================================
000BB9r 1               ; EVALUATE EXPRESSION, MAKE SURE IT IS NUMERIC
000BB9r 1               ; =============================================================================
000BB9r 1               
000BB9r 1               FRMNUM:
000BB9r 1  20 rr rr             jsr     FRMEVL
000BBCr 1               
000BBCr 1               ; =============================================================================
000BBCr 1               ; MAKE SURE (FAC) IS NUMERIC
000BBCr 1               ; =============================================================================
000BBCr 1               CHKNUM:
000BBCr 1  18                   clc
000BBDr 1  24                   .byte   $24
000BBEr 1               
000BBEr 1               ; =============================================================================
000BBEr 1               ; MAKE SURE (FAC) IS STRING
000BBEr 1               ; =============================================================================
000BBEr 1               CHKSTR:
000BBEr 1  38                   sec
000BBFr 1               
000BBFr 1               ; =============================================================================
000BBFr 1               ; MAKE SURE (FAC) IS CORRECT TYPE
000BBFr 1               ; IF C=0, TYPE MUST BE NUMERIC
000BBFr 1               ; IF C=1, TYPE MUST BE STRING
000BBFr 1               ; =============================================================================
000BBFr 1               
000BBFr 1               CHKVAL:
000BBFr 1  24 5F                bit     VALTYP
000BC1r 1  30 03                bmi     L2C41
000BC3r 1  B0 03                bcs     L2C43
000BC5r 1               L2C40:
000BC5r 1  60                   rts
000BC6r 1               L2C41:
000BC6r 1  B0 FD                bcs     L2C40
000BC8r 1               L2C43:
000BC8r 1  A2 18                ldx     #ERR_BADTYPE
000BCAr 1               JERROR:
000BCAr 1  4C rr rr             jmp     ERROR
000BCDr 1               
000BCDr 1               ; =============================================================================
000BCDr 1               ; EVALUATE THE EXPRESSION AT TXTPTR, LEAVING THE
000BCDr 1               ; RESULT IN FAC.  WORKS FOR BOTH STRING AND NUMERIC
000BCDr 1               ; EXPRESSIONS.
000BCDr 1               ; =============================================================================
000BCDr 1               
000BCDr 1               FRMEVL:
000BCDr 1  A6 CF                ldx     TXTPTR
000BCFr 1  D0 02                bne     L2C4E
000BD1r 1  C6 D0                dec     TXTPTR+1
000BD3r 1               L2C4E:
000BD3r 1  C6 CF                dec     TXTPTR
000BD5r 1  A2 00                ldx     #$00
000BD7r 1  24                   .byte   $24
000BD8r 1               FRMEVL1:
000BD8r 1  48                   pha
000BD9r 1  8A                   txa
000BDAr 1  48                   pha
000BDBr 1  A9 01                lda     #$01
000BDDr 1  20 rr rr             jsr     CHKMEM
000BE0r 1  20 rr rr             jsr     FRM_ELEMENT
000BE3r 1  A9 00                lda     #$00
000BE5r 1  85 9D                sta     CPRTYP
000BE7r 1               FRMEVL2:
000BE7r 1  20 CE 00             jsr     CHRGOT
000BEAr 1               L2C65:
000BEAr 1  38                   sec
000BEBr 1  E9 B5                sbc     #TOKEN_GREATER
000BEDr 1  90 17                bcc     L2C81
000BEFr 1  C9 03                cmp     #$03
000BF1r 1  B0 13                bcs     L2C81
000BF3r 1  C9 01                cmp     #$01
000BF5r 1  2A                   rol     a
000BF6r 1  49 01                eor     #$01
000BF8r 1  45 9D                eor     CPRTYP
000BFAr 1  C5 9D                cmp     CPRTYP
000BFCr 1  90 61                bcc     SNTXERR
000BFEr 1  85 9D                sta     CPRTYP
000C00r 1  20 C8 00             jsr     CHRGET
000C03r 1  4C rr rr             jmp     L2C65
000C06r 1               L2C81:
000C06r 1  A6 9D                ldx     CPRTYP
000C08r 1  D0 2C                bne     FRM_RELATIONAL
000C0Ar 1  B0 78                bcs     L2D02
000C0Cr 1  69 07                adc     #$07
000C0Er 1  90 74                bcc     L2D02
000C10r 1  65 5F                adc     VALTYP
000C12r 1  D0 03                bne     L2C92
000C14r 1  4C rr rr             jmp     CAT
000C17r 1               L2C92:
000C17r 1  69 FF                adc     #$FF
000C19r 1  85 73                sta     INDEX
000C1Br 1  0A                   asl     a
000C1Cr 1  65 73                adc     INDEX
000C1Er 1  A8                   tay
000C1Fr 1               FRM_PRECEDENCE_TEST:
000C1Fr 1  68                   pla
000C20r 1  D9 rr rr             cmp     MATHTBL,y
000C23r 1  B0 64                bcs     FRM_PERFORM1
000C25r 1  20 rr rr             jsr     CHKNUM
000C28r 1               L2CA3:
000C28r 1  48                   pha
000C29r 1               L2CA4:
000C29r 1  20 rr rr             jsr     FRM_RECURSE
000C2Cr 1  68                   pla
000C2Dr 1  A4 9B                ldy     LASTOP
000C2Fr 1  10 17                bpl     PREFNC
000C31r 1  AA                   tax
000C32r 1  F0 53                beq     GOEX
000C34r 1  D0 5C                bne     FRM_PERFORM2
000C36r 1               
000C36r 1               ; =============================================================================
000C36r 1               ; FOUND ONE OR MORE RELATIONAL OPERATORS <,=,>
000C36r 1               ; =============================================================================
000C36r 1               
000C36r 1               FRM_RELATIONAL:
000C36r 1  46 5F                lsr     VALTYP
000C38r 1  8A                   txa
000C39r 1  2A                   rol     a
000C3Ar 1  A6 CF                ldx     TXTPTR
000C3Cr 1  D0 02                bne     L2CBB
000C3Er 1  C6 D0                dec     TXTPTR+1
000C40r 1               L2CBB:
000C40r 1  C6 CF                dec     TXTPTR
000C42r 1  A0 1B                ldy     #$1B
000C44r 1  85 9D                sta     CPRTYP
000C46r 1  D0 D7                bne     FRM_PRECEDENCE_TEST
000C48r 1               PREFNC:
000C48r 1  D9 rr rr             cmp     MATHTBL,y
000C4Br 1  B0 45                bcs     FRM_PERFORM2
000C4Dr 1  90 D9                bcc     L2CA3
000C4Fr 1               
000C4Fr 1               ; =============================================================================
000C4Fr 1               ; STACK THIS OPERATION AND CALL FRMEVL FOR
000C4Fr 1               ; ANOTHER ONE
000C4Fr 1               ; =============================================================================
000C4Fr 1               
000C4Fr 1               FRM_RECURSE:
000C4Fr 1  B9 rr rr             lda     MATHTBL+2,y
000C52r 1  48                   pha
000C53r 1  B9 rr rr             lda     MATHTBL+1,y
000C56r 1  48                   pha
000C57r 1  20 rr rr             jsr     FRM_STACK1
000C5Ar 1  A5 9D                lda     CPRTYP
000C5Cr 1  4C rr rr             jmp     FRMEVL1
000C5Fr 1               SNTXERR:
000C5Fr 1  4C rr rr             jmp     SYNERR
000C62r 1               
000C62r 1               ; =============================================================================
000C62r 1               ; STACK (FAC)
000C62r 1               ; THREE ENTRY POINTS:
000C62r 1               ;     1, FROM FRMEVL
000C62r 1               ;    2, FROM "STEP"
000C62r 1               ;    3, FROM "FOR"
000C62r 1               ; =============================================================================
000C62r 1               
000C62r 1               FRM_STACK1:
000C62r 1  A5 B2                lda     FACSIGN
000C64r 1  BE rr rr             ldx     MATHTBL,y
000C67r 1               
000C67r 1               ; =============================================================================
000C67r 1               ; ENTER HERE FROM "STEP", TO PUSH STEP SIGN AND VALUE
000C67r 1               ; =============================================================================
000C67r 1               
000C67r 1               FRM_STACK2:
000C67r 1  A8                   tay
000C68r 1  68                   pla
000C69r 1  85 73                sta     INDEX
000C6Br 1  E6 73                inc     INDEX ; bug: assumes not on page boundary
000C6Dr 1               ; bug exists on AppleSoft II
000C6Dr 1  68                   pla
000C6Er 1  85 74                sta     INDEX+1
000C70r 1  98                   tya
000C71r 1  48                   pha
000C72r 1               
000C72r 1               ; =============================================================================
000C72r 1               ; ENTER HERE FROM "FOR", WITH (INDEX) = STEP,
000C72r 1               ; TO PUSH INITIAL VALUE OF "FOR" VARIABLE
000C72r 1               ; =============================================================================
000C72r 1               
000C72r 1               FRM_STACK3:
000C72r 1  20 rr rr             jsr     ROUND_FAC
000C75r 1  A5 B1                lda     FAC+3
000C77r 1  48                   pha
000C78r 1  A5 B0                lda     FAC+2
000C7Ar 1  48                   pha
000C7Br 1  A5 AF                lda     FAC+1
000C7Dr 1  48                   pha
000C7Er 1  A5 AE                lda     FAC
000C80r 1  48                   pha
000C81r 1  6C 73 00             jmp     (INDEX)
000C84r 1               L2D02:
000C84r 1  A0 FF                ldy     #$FF
000C86r 1  68                   pla
000C87r 1               GOEX:
000C87r 1  F0 20                beq     EXIT
000C89r 1               
000C89r 1               ; =============================================================================
000C89r 1               ; PERFORM STACKED OPERATION
000C89r 1               ;
000C89r 1               ; (A) = PRECEDENCE BYTE
000C89r 1               ; STACK:  1 -- CPRMASK
000C89r 1               ;    5 -- (ARG)
000C89r 1               ;    2 -- ADDR OF PERFORMER
000C89r 1               ; =============================================================================
000C89r 1               
000C89r 1               FRM_PERFORM1:
000C89r 1  C9 64                cmp     #$64
000C8Br 1  F0 03                beq     L2D0E
000C8Dr 1  20 rr rr             jsr     CHKNUM
000C90r 1               L2D0E:
000C90r 1  84 9B                sty     LASTOP
000C92r 1               FRM_PERFORM2:
000C92r 1  68                   pla
000C93r 1  4A                   lsr     a
000C94r 1  85 63                sta     CPRMASK
000C96r 1  68                   pla
000C97r 1  85 B5                sta     ARG
000C99r 1  68                   pla
000C9Ar 1  85 B6                sta     ARG+1
000C9Cr 1  68                   pla
000C9Dr 1  85 B7                sta     ARG+2
000C9Fr 1  68                   pla
000CA0r 1  85 B8                sta     ARG+3
000CA2r 1  68                   pla
000CA3r 1  85 B9                sta     ARGSIGN
000CA5r 1  45 B2                eor     FACSIGN
000CA7r 1  85 BA                sta     SGNCPR
000CA9r 1               EXIT:
000CA9r 1  A5 AE                lda     FAC
000CABr 1  60                   rts
000CACr 1               
000CACr 1               ; =============================================================================
000CACr 1               ; GET ELEMENT IN EXPRESSION
000CACr 1               ;
000CACr 1               ; GET VALUE OF VARIABLE OR NUMBER AT TXTPNT, OR POINT
000CACr 1               ; TO STRING DESCRIPTOR IF A STRING, AND PUT IN FAC.
000CACr 1               ; =============================================================================
000CACr 1               
000CACr 1               FRM_ELEMENT:
000CACr 1  A9 00                lda     #$00
000CAEr 1  85 5F                sta     VALTYP
000CB0r 1               L2D31:
000CB0r 1  20 C8 00             jsr     CHRGET
000CB3r 1  B0 03                bcs     L2D39
000CB5r 1               L2D36:
000CB5r 1  4C rr rr             jmp     FIN
000CB8r 1               L2D39:
000CB8r 1  20 rr rr             jsr     ISLETC
000CBBr 1  B0 67                bcs     FRM_VARIABLE
000CBDr 1               CON_PI:
000CBDr 1  C9 2E                cmp     #$2E
000CBFr 1  F0 F4                beq     L2D36
000CC1r 1  C9 AF                cmp     #TOKEN_MINUS
000CC3r 1  F0 58                beq     MIN
000CC5r 1  C9 AE                cmp     #TOKEN_PLUS
000CC7r 1  F0 E7                beq     L2D31
000CC9r 1  C9 22                cmp     #$22
000CCBr 1  D0 0F                bne     NOT_
000CCDr 1               
000CCDr 1               ; =============================================================================
000CCDr 1               ; STRING CONSTANT ELEMENT
000CCDr 1               ;
000CCDr 1               ; SET Y,A = (TXTPTR)+CARRY
000CCDr 1               ; =============================================================================
000CCDr 1               
000CCDr 1               STRTXT:
000CCDr 1  A5 CF                lda     TXTPTR
000CCFr 1  A4 D0                ldy     TXTPTR+1
000CD1r 1  69 00                adc     #$00
000CD3r 1  90 01                bcc     L2D57
000CD5r 1  C8                   iny
000CD6r 1               L2D57:
000CD6r 1  20 rr rr             jsr     STRLIT
000CD9r 1  4C rr rr             jmp     POINT
000CDCr 1               
000CDCr 1               ; =============================================================================
000CDCr 1               ; "NOT" FUNCTION
000CDCr 1               ; IF FAC=0, RETURN FAC=1
000CDCr 1               ; IF FAC<>0, RETURN FAC=0
000CDCr 1               ; =============================================================================
000CDCr 1               
000CDCr 1               NOT_:
000CDCr 1  C9 AC                cmp     #TOKEN_NOT
000CDEr 1  D0 13                bne     L2D74
000CE0r 1  A0 18                ldy     #$18
000CE2r 1  D0 3B                bne     EQUL
000CE4r 1               
000CE4r 1               ; =============================================================================
000CE4r 1               ; COMPARISON FOR EQUALITY (= OPERATOR)
000CE4r 1               ; ALSO USED TO EVALUATE "NOT" FUNCTION
000CE4r 1               ; =============================================================================
000CE4r 1               
000CE4r 1               EQUOP:
000CE4r 1  20 rr rr             jsr     AYINT
000CE7r 1  A5 B1                lda     FAC_LAST
000CE9r 1  49 FF                eor     #$FF
000CEBr 1  A8                   tay
000CECr 1  A5 B0                lda     FAC_LAST-1
000CEEr 1  49 FF                eor     #$FF
000CF0r 1  4C rr rr             jmp     GIVAYF
000CF3r 1               L2D74:
000CF3r 1  C9 A9                cmp     #TOKEN_FN
000CF5r 1  D0 03                bne     L2D7B
000CF7r 1  4C rr rr             jmp     L31F3
000CFAr 1               L2D7B:
000CFAr 1  C9 B8                cmp     #TOKEN_SGN
000CFCr 1  90 03                bcc     PARCHK
000CFEr 1  4C rr rr             jmp     UNARY
000D01r 1               
000D01r 1               ; =============================================================================
000D01r 1               ; EVALUATE "(EXPRESSION)"
000D01r 1               ; =============================================================================
000D01r 1               
000D01r 1               PARCHK:
000D01r 1  20 rr rr             jsr     CHKOPN
000D04r 1  20 rr rr             jsr     FRMEVL
000D07r 1               CHKCLS:
000D07r 1  A9 29                lda     #$29
000D09r 1  2C                   .byte   $2C
000D0Ar 1               CHKOPN:
000D0Ar 1  A9 28                lda     #$28
000D0Cr 1  2C                   .byte   $2C
000D0Dr 1               CHKCOM:
000D0Dr 1  A9 2C                lda     #$2C
000D0Fr 1               
000D0Fr 1               ; =============================================================================
000D0Fr 1               ; UNLESS CHAR AT TXTPTR = (A), SYNTAX ERROR
000D0Fr 1               ; =============================================================================
000D0Fr 1               
000D0Fr 1               SYNCHR:    ; XXX all CBM code calls SYNCHR instead of CHKCOM
000D0Fr 1  A0 00                ldy     #$00
000D11r 1  D1 CF                cmp     (TXTPTR),y
000D13r 1  D0 03                bne     SYNERR
000D15r 1  4C C8 00             jmp     CHRGET
000D18r 1               
000D18r 1               ; =============================================================================
000D18r 1               
000D18r 1               SYNERR:
000D18r 1  A2 02                ldx     #ERR_SYNTAX
000D1Ar 1  4C rr rr             jmp     ERROR
000D1Dr 1               
000D1Dr 1               ; =============================================================================
000D1Dr 1               
000D1Dr 1               MIN:
000D1Dr 1  A0 15                ldy     #$15
000D1Fr 1               EQUL:
000D1Fr 1  68                   pla
000D20r 1  68                   pla
000D21r 1  4C rr rr             jmp     L2CA4
000D24r 1               
000D24r 1               ; =============================================================================
000D24r 1               
000D24r 1               FRM_VARIABLE:
000D24r 1  20 rr rr             jsr     PTRGET
000D27r 1               
000D27r 1               FRM_VARIABLE_CALL    = *-1
000D27r 1  85 B0                sta     FAC_LAST-1
000D29r 1  84 B1                sty     FAC_LAST
000D2Br 1  A6 5F                ldx     VALTYP
000D2Dr 1  F0 01                beq     L2DB1
000D2Fr 1               ; bugfix?
000D2Fr 1               ; fixed on AppleSoft II, not on any CBM
000D2Fr 1  60                   rts
000D30r 1               L2DB1:
000D30r 1  4C rr rr             jmp     LOAD_FAC_FROM_YA
000D33r 1               
000D33r 1               ; =============================================================================
000D33r 1               
000D33r 1               UNARY:
000D33r 1  0A                   asl     a
000D34r 1  48                   pha
000D35r 1  AA                   tax
000D36r 1  20 C8 00             jsr     CHRGET
000D39r 1  E0 97                cpx     #<(TOKEN_LEFTSTR*2-1)
000D3Br 1  90 20                bcc     L2DEF
000D3Dr 1  20 rr rr             jsr     CHKOPN
000D40r 1  20 rr rr             jsr     FRMEVL
000D43r 1  20 rr rr             jsr     CHKCOM
000D46r 1  20 rr rr             jsr     CHKSTR
000D49r 1  68                   pla
000D4Ar 1  AA                   tax
000D4Br 1  A5 B1                lda     FAC_LAST
000D4Dr 1  48                   pha
000D4Er 1  A5 B0                lda     FAC_LAST-1
000D50r 1  48                   pha
000D51r 1  8A                   txa
000D52r 1  48                   pha
000D53r 1  20 rr rr             jsr     GETBYT
000D56r 1  68                   pla
000D57r 1  A8                   tay
000D58r 1  8A                   txa
000D59r 1  48                   pha
000D5Ar 1  4C rr rr             jmp     L2DF4
000D5Dr 1               L2DEF:
000D5Dr 1  20 rr rr             jsr     PARCHK
000D60r 1  68                   pla
000D61r 1  A8                   tay
000D62r 1               L2DF4:
000D62r 1  B9 rr rr             lda     UNFNC+($80-TOKEN_SGN)*2,y
000D65r 1  85 A4                sta     JMPADRS+1
000D67r 1  B9 rr rr             lda     UNFNC+($80-TOKEN_SGN)*2+1,y
000D6Ar 1  85 A5                sta     JMPADRS+2
000D6Cr 1  20 A3 00             jsr     JMPADRS
000D6Fr 1  4C rr rr             jmp     CHKNUM
000D72r 1               
000D72r 1               ; =============================================================================
000D72r 1               
000D72r 1               OR:
000D72r 1  A0 FF                ldy     #$FF
000D74r 1  2C                   .byte   $2C
000D75r 1               
000D75r 1               ; =============================================================================
000D75r 1               
000D75r 1               TAND:
000D75r 1  A0 00                ldy     #$00
000D77r 1  84 5D                sty     EOLPNTR
000D79r 1  20 rr rr             jsr     AYINT
000D7Cr 1  A5 B0                lda     FAC_LAST-1
000D7Er 1  45 5D                eor     EOLPNTR
000D80r 1  85 5B                sta     CHARAC
000D82r 1  A5 B1                lda     FAC_LAST
000D84r 1  45 5D                eor     EOLPNTR
000D86r 1  85 5C                sta     ENDCHR
000D88r 1  20 rr rr             jsr     COPY_ARG_TO_FAC
000D8Br 1  20 rr rr             jsr     AYINT
000D8Er 1  A5 B1                lda     FAC_LAST
000D90r 1  45 5D                eor     EOLPNTR
000D92r 1  25 5C                and     ENDCHR
000D94r 1  45 5D                eor     EOLPNTR
000D96r 1  A8                   tay
000D97r 1  A5 B0                lda     FAC_LAST-1
000D99r 1  45 5D                eor     EOLPNTR
000D9Br 1  25 5B                and     CHARAC
000D9Dr 1  45 5D                eor     EOLPNTR
000D9Fr 1  4C rr rr             jmp     GIVAYF
000DA2r 1               
000DA2r 1               ; =============================================================================
000DA2r 1               ; PERFORM RELATIONAL OPERATIONS
000DA2r 1               ; =============================================================================
000DA2r 1               
000DA2r 1               RELOPS:
000DA2r 1  20 rr rr             jsr     CHKVAL
000DA5r 1  B0 13                bcs     STRCMP
000DA7r 1  A5 B9                lda     ARGSIGN
000DA9r 1  09 7F                ora     #$7F
000DABr 1  25 B6                and     ARG+1
000DADr 1  85 B6                sta     ARG+1
000DAFr 1  A9 B5                lda     #<ARG
000DB1r 1  A0 00                ldy     #$00
000DB3r 1  20 rr rr             jsr     FCOMP
000DB6r 1  AA                   tax
000DB7r 1  4C rr rr             jmp     NUMCMP
000DBAr 1               
000DBAr 1               ; =============================================================================
000DBAr 1               ; STRING COMPARISON
000DBAr 1               ; =============================================================================
000DBAr 1               
000DBAr 1               STRCMP:
000DBAr 1  A9 00                lda     #$00
000DBCr 1  85 5F                sta     VALTYP
000DBEr 1  C6 9D                dec     CPRTYP
000DC0r 1  20 rr rr             jsr     FREFAC
000DC3r 1  85 AE                sta     FAC
000DC5r 1  86 AF                stx     FAC+1
000DC7r 1  84 B0                sty     FAC+2
000DC9r 1  A5 B7                lda     ARG_LAST-1
000DCBr 1  A4 B8                ldy     ARG_LAST
000DCDr 1  20 rr rr             jsr     FRETMP
000DD0r 1  86 B7                stx     ARG_LAST-1
000DD2r 1  84 B8                sty     ARG_LAST
000DD4r 1  AA                   tax
000DD5r 1  38                   sec
000DD6r 1  E5 AE                sbc     FAC
000DD8r 1  F0 08                beq     L2E74
000DDAr 1  A9 01                lda     #$01
000DDCr 1  90 04                bcc     L2E74
000DDEr 1  A6 AE                ldx     FAC
000DE0r 1  A9 FF                lda     #$FF
000DE2r 1               L2E74:
000DE2r 1  85 B2                sta     FACSIGN
000DE4r 1  A0 FF                ldy     #$FF
000DE6r 1  E8                   inx
000DE7r 1               STRCMP1:
000DE7r 1  C8                   iny
000DE8r 1  CA                   dex
000DE9r 1  D0 07                bne     L2E84
000DEBr 1  A6 B2                ldx     FACSIGN
000DEDr 1               NUMCMP:
000DEDr 1  30 0F                bmi     CMPDONE
000DEFr 1  18                   clc
000DF0r 1  90 0C                bcc     CMPDONE
000DF2r 1               L2E84:
000DF2r 1  B1 B7                lda     (ARG_LAST-1),y
000DF4r 1  D1 AF                cmp     (FAC+1),y
000DF6r 1  F0 EF                beq     STRCMP1
000DF8r 1  A2 FF                ldx     #$FF
000DFAr 1  B0 02                bcs     CMPDONE
000DFCr 1  A2 01                ldx     #$01
000DFEr 1               CMPDONE:
000DFEr 1  E8                   inx
000DFFr 1  8A                   txa
000E00r 1  2A                   rol     a
000E01r 1  25 63                and     CPRMASK
000E03r 1  F0 02                beq     L2E99
000E05r 1  A9 FF                lda     #$FF
000E07r 1               L2E99:
000E07r 1  4C rr rr             jmp     FLOAT
000E0Ar 1               
000E0Ar 1               ; =============================================================================
000E0Ar 1               ; "DIM" STATEMENT
000E0Ar 1               ; =============================================================================
000E0Ar 1               
000E0Ar 1               NXDIM:
000E0Ar 1  20 rr rr             jsr     CHKCOM
000E0Dr 1               DIM:
000E0Dr 1  AA                   tax
000E0Er 1  20 rr rr             jsr     PTRGET2
000E11r 1  20 CE 00             jsr     CHRGOT
000E14r 1  D0 F4                bne     NXDIM
000E16r 1  60                   rts
000E17r 1               
000E17r 1               ; =============================================================================
000E17r 1               ; PTRGET -- GENERAL VARIABLE SCAN
000E17r 1               ;
000E17r 1               ; SCANS VARIABLE NAME AT TXTPTR, AND SEARCHES THE
000E17r 1               ; VARTAB AND ARYTAB FOR THE NAME.
000E17r 1               ; IF NOT FOUND, CREATE VARIABLE OF APPROPRIATE TYPE.
000E17r 1               ; RETURN WITH ADDRESS IN VARPNT AND Y,A
000E17r 1               ;
000E17r 1               ; ACTUAL ACTIVITY CONTROLLED SOMEWHAT BY TWO FLAGS:
000E17r 1               ;    DIMFLG -- NONZERO IF CALLED FROM "DIM"
000E17r 1               ;        ELSE = 0
000E17r 1               ;
000E17r 1               ;    SUBFLG -- = $00
000E17r 1               ;        = $40 IF CALLED FROM "GETARYPT"
000E17r 1               ; =============================================================================
000E17r 1               
000E17r 1               PTRGET:
000E17r 1  A2 00                ldx     #$00
000E19r 1  20 CE 00             jsr     CHRGOT
000E1Cr 1               PTRGET2:
000E1Cr 1  86 5E                stx     DIMFLG
000E1Er 1               PTRGET3:
000E1Er 1  85 95                sta     VARNAM
000E20r 1  20 CE 00             jsr     CHRGOT
000E23r 1  20 rr rr             jsr     ISLETC
000E26r 1  B0 03                bcs     NAMOK
000E28r 1  4C rr rr             jmp     SYNERR
000E2Br 1               NAMOK:
000E2Br 1  A2 00                ldx     #$00
000E2Dr 1  86 5F                stx     VALTYP
000E2Fr 1  20 C8 00             jsr     CHRGET
000E32r 1  90 05                bcc     L2ECD
000E34r 1  20 rr rr             jsr     ISLETC
000E37r 1  90 0B                bcc     L2ED8
000E39r 1               L2ECD:
000E39r 1  AA                   tax
000E3Ar 1               L2ECE:
000E3Ar 1  20 C8 00             jsr     CHRGET
000E3Dr 1  90 FB                bcc     L2ECE
000E3Fr 1  20 rr rr             jsr     ISLETC
000E42r 1  B0 F6                bcs     L2ECE
000E44r 1               L2ED8:
000E44r 1  C9 24                cmp     #$24
000E46r 1  D0 0B                bne     L2EF9
000E48r 1  A9 FF                lda     #$FF
000E4Ar 1  85 5F                sta     VALTYP
000E4Cr 1  8A                   txa
000E4Dr 1  09 80                ora     #$80
000E4Fr 1  AA                   tax
000E50r 1  20 C8 00             jsr     CHRGET
000E53r 1               L2EF9:
000E53r 1  86 96                stx     VARNAM+1
000E55r 1  38                   sec
000E56r 1  05 61                ora     SUBFLG
000E58r 1  E9 28                sbc     #$28
000E5Ar 1  D0 03                bne     L2F05
000E5Cr 1  4C rr rr             jmp     ARRAY
000E5Fr 1               L2F05:
000E5Fr 1  A9 00                lda     #$00
000E61r 1  85 61                sta     SUBFLG
000E63r 1  A5 7D                lda     VARTAB
000E65r 1  A6 7E                ldx     VARTAB+1
000E67r 1  A0 00                ldy     #$00
000E69r 1               L2F0F:
000E69r 1  86 AD                stx     LOWTR+1
000E6Br 1               L2F11:
000E6Br 1  85 AC                sta     LOWTR
000E6Dr 1  E4 80                cpx     ARYTAB+1
000E6Fr 1  D0 04                bne     L2F1B
000E71r 1  C5 7F                cmp     ARYTAB
000E73r 1  F0 22                beq     NAMENOTFOUND
000E75r 1               L2F1B:
000E75r 1  A5 95                lda     VARNAM
000E77r 1  D1 AC                cmp     (LOWTR),y
000E79r 1  D0 08                bne     L2F29
000E7Br 1  A5 96                lda     VARNAM+1
000E7Dr 1  C8                   iny
000E7Er 1  D1 AC                cmp     (LOWTR),y
000E80r 1  F0 61                beq     SET_VARPNT_AND_YA
000E82r 1  88                   dey
000E83r 1               L2F29:
000E83r 1  18                   clc
000E84r 1  A5 AC                lda     LOWTR
000E86r 1  69 06                adc     #BYTES_PER_VARIABLE
000E88r 1  90 E1                bcc     L2F11
000E8Ar 1  E8                   inx
000E8Br 1  D0 DC                bne     L2F0F
000E8Dr 1               
000E8Dr 1               ; =============================================================================
000E8Dr 1               ; CHECK IF (A) IS ASCII LETTER A-Z
000E8Dr 1               ;
000E8Dr 1               ; RETURN CARRY = 1 IF A-Z
000E8Dr 1               ;    = 0 IF NOT
000E8Dr 1               ; =============================================================================
000E8Dr 1               
000E8Dr 1               ISLETC:
000E8Dr 1  C9 41                cmp     #$41
000E8Fr 1  90 05                bcc     L2F3C
000E91r 1  E9 5B                sbc     #$5B
000E93r 1  38                   sec
000E94r 1  E9 A5                sbc     #$A5
000E96r 1               L2F3C:
000E96r 1  60                   rts
000E97r 1               
000E97r 1               ; =============================================================================
000E97r 1               ; VARIABLE NOT FOUND, SO MAKE ONE
000E97r 1               ; =============================================================================
000E97r 1               
000E97r 1               NAMENOTFOUND:
000E97r 1  68                   pla
000E98r 1  48                   pha
000E99r 1  C9 rr                cmp     #<FRM_VARIABLE_CALL
000E9Br 1  D0 07                bne     MAKENEWVARIABLE
000E9Dr 1  A9 rr                lda     #<C_ZERO
000E9Fr 1  A0 rr                ldy     #>C_ZERO
000EA1r 1  60                   rts
000EA2r 1               
000EA2r 1               ; =============================================================================
000EA2r 1               
000EA2r 1               C_ZERO:
000EA2r 1  00 00                .byte   $00,$00
000EA4r 1               
000EA4r 1               ; =============================================================================
000EA4r 1               ; MAKE A NEW SIMPLE VARIABLE
000EA4r 1               ;
000EA4r 1               ; MOVE ARRAYS UP 7 BYTES TO MAKE ROOM FOR NEW VARIABLE
000EA4r 1               ; ENTER 7-BYTE VARIABLE DATA IN THE HOLE
000EA4r 1               ; =============================================================================
000EA4r 1               
000EA4r 1               MAKENEWVARIABLE:
000EA4r 1  A5 7F                lda     ARYTAB
000EA6r 1  A4 80                ldy     ARYTAB+1
000EA8r 1  85 AC                sta     LOWTR
000EAAr 1  84 AD                sty     LOWTR+1
000EACr 1  A5 81                lda     STREND
000EAEr 1  A4 82                ldy     STREND+1
000EB0r 1  85 A8                sta     HIGHTR
000EB2r 1  84 A9                sty     HIGHTR+1
000EB4r 1  18                   clc
000EB5r 1  69 06                adc     #BYTES_PER_VARIABLE
000EB7r 1  90 01                bcc     L2F68
000EB9r 1  C8                   iny
000EBAr 1               L2F68:
000EBAr 1  85 A6                sta     HIGHDS
000EBCr 1  84 A7                sty     HIGHDS+1
000EBEr 1  20 rr rr             jsr     BLTU
000EC1r 1  A5 A6                lda     HIGHDS
000EC3r 1  A4 A7                ldy     HIGHDS+1
000EC5r 1  C8                   iny
000EC6r 1  85 7F                sta     ARYTAB
000EC8r 1  84 80                sty     ARYTAB+1
000ECAr 1  A0 00                ldy     #$00
000ECCr 1  A5 95                lda     VARNAM
000ECEr 1  91 AC                sta     (LOWTR),y
000ED0r 1  C8                   iny
000ED1r 1  A5 96                lda     VARNAM+1
000ED3r 1  91 AC                sta     (LOWTR),y
000ED5r 1  A9 00                lda     #$00
000ED7r 1  C8                   iny
000ED8r 1  91 AC                sta     (LOWTR),y
000EDAr 1  C8                   iny
000EDBr 1  91 AC                sta     (LOWTR),y
000EDDr 1  C8                   iny
000EDEr 1  91 AC                sta     (LOWTR),y
000EE0r 1  C8                   iny
000EE1r 1  91 AC                sta     (LOWTR),y
000EE3r 1               
000EE3r 1               ; =============================================================================
000EE3r 1               ; PUT ADDRESS OF VALUE OF VARIABLE IN VARPNT AND Y,A
000EE3r 1               ; =============================================================================
000EE3r 1               
000EE3r 1               SET_VARPNT_AND_YA:
000EE3r 1  A5 AC                lda     LOWTR
000EE5r 1  18                   clc
000EE6r 1  69 02                adc     #$02
000EE8r 1  A4 AD                ldy     LOWTR+1
000EEAr 1  90 01                bcc     L2F9E
000EECr 1  C8                   iny
000EEDr 1               L2F9E:
000EEDr 1  85 97                sta     VARPNT
000EEFr 1  84 98                sty     VARPNT+1
000EF1r 1  60                   rts
000EF2r 1               
000EF2r 1               ; =============================================================================
000EF2r 1               ; COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
000EF2r 1               ; ARYPNT = (LOWTR) + #DIMS*2 + 5
000EF2r 1               ; =============================================================================
000EF2r 1               
000EF2r 1               GETARY:
000EF2r 1  A5 5D                lda     EOLPNTR
000EF4r 1  0A                   asl     a
000EF5r 1  69 05                adc     #$05
000EF7r 1  65 AC                adc     LOWTR
000EF9r 1  A4 AD                ldy     LOWTR+1
000EFBr 1  90 01                bcc     L2FAF
000EFDr 1  C8                   iny
000EFEr 1               L2FAF:
000EFEr 1  85 A6                sta     HIGHDS
000F00r 1  84 A7                sty     HIGHDS+1
000F02r 1  60                   rts
000F03r 1               
000F03r 1               ; =============================================================================
000F03r 1               NEG32768:
000F03r 1  90 80 00 00          .byte   $90,$80,$00,$00
000F07r 1               
000F07r 1               ; =============================================================================
000F07r 1               ; EVALUATE NUMERIC FORMULA AT TXTPTR
000F07r 1               ; CONVERTING RESULT TO INTEGER 0 <= X <= 32767
000F07r 1               ; IN FAC+3,4
000F07r 1               ; =============================================================================
000F07r 1               
000F07r 1               MAKINT:
000F07r 1  20 C8 00             jsr     CHRGET
000F0Ar 1  20 rr rr             jsr     FRMNUM
000F0Dr 1               
000F0Dr 1               ; =============================================================================
000F0Dr 1               ; CONVERT FAC TO INTEGER
000F0Dr 1               ; MUST BE POSITIVE AND LESS THAN 32768
000F0Dr 1               ; =============================================================================
000F0Dr 1               
000F0Dr 1               MKINT:
000F0Dr 1  A5 B2                lda     FACSIGN
000F0Fr 1  30 0D                bmi     MI1
000F11r 1               
000F11r 1               ; =============================================================================
000F11r 1               ; CONVERT FAC TO INTEGER
000F11r 1               ; MUST BE -32767 <= FAC <= 32767
000F11r 1               ; =============================================================================
000F11r 1               
000F11r 1               AYINT:
000F11r 1  A5 AE                lda     FAC
000F13r 1  C9 90                cmp     #$90
000F15r 1  90 09                bcc     MI2
000F17r 1  A9 rr                lda     #<NEG32768
000F19r 1  A0 rr                ldy     #>NEG32768
000F1Br 1  20 rr rr             jsr     FCOMP
000F1Er 1               MI1:
000F1Er 1  D0 74                bne     IQERR
000F20r 1               MI2:
000F20r 1  4C rr rr             jmp     QINT
000F23r 1               
000F23r 1               ; =============================================================================
000F23r 1               ; LOCATE ARRAY ELEMENT OR CREATE AN ARRAY
000F23r 1               ; =============================================================================
000F23r 1               
000F23r 1               ARRAY:
000F23r 1  A5 5E                lda     DIMFLG
000F25r 1  48                   pha
000F26r 1  A5 5F                lda     VALTYP
000F28r 1  48                   pha
000F29r 1  A0 00                ldy     #$00
000F2Br 1               L2FDE:
000F2Br 1  98                   tya
000F2Cr 1  48                   pha
000F2Dr 1  A5 96                lda     VARNAM+1
000F2Fr 1  48                   pha
000F30r 1  A5 95                lda     VARNAM
000F32r 1  48                   pha
000F33r 1  20 rr rr             jsr     MAKINT
000F36r 1  68                   pla
000F37r 1  85 95                sta     VARNAM
000F39r 1  68                   pla
000F3Ar 1  85 96                sta     VARNAM+1
000F3Cr 1  68                   pla
000F3Dr 1  A8                   tay
000F3Er 1  BA                   tsx
000F3Fr 1  BD 02 01             lda     STACK+2,x
000F42r 1  48                   pha
000F43r 1  BD 01 01             lda     STACK+1,x
000F46r 1  48                   pha
000F47r 1  A5 B0                lda     FAC_LAST-1
000F49r 1  9D 02 01             sta     STACK+2,x
000F4Cr 1  A5 B1                lda     FAC_LAST
000F4Er 1  9D 01 01             sta     STACK+1,x
000F51r 1  C8                   iny
000F52r 1  20 CE 00             jsr     CHRGOT
000F55r 1  C9 2C                cmp     #$2C
000F57r 1  F0 D2                beq     L2FDE
000F59r 1  84 5D                sty     EOLPNTR
000F5Br 1  20 rr rr             jsr     CHKCLS
000F5Er 1  68                   pla
000F5Fr 1  85 5F                sta     VALTYP
000F61r 1  68                   pla
000F62r 1  85 5E                sta     DIMFLG
000F64r 1               
000F64r 1               ; =============================================================================
000F64r 1               ; SEARCH ARRAY TABLE FOR THIS ARRAY NAME
000F64r 1               ; =============================================================================
000F64r 1               
000F64r 1  A6 7F                ldx     ARYTAB
000F66r 1  A5 80                lda     ARYTAB+1
000F68r 1               L301F:
000F68r 1  86 AC                stx     LOWTR
000F6Ar 1  85 AD                sta     LOWTR+1
000F6Cr 1  C5 82                cmp     STREND+1
000F6Er 1  D0 04                bne     L302B
000F70r 1  E4 81                cpx     STREND
000F72r 1  F0 39                beq     MAKE_NEW_ARRAY
000F74r 1               L302B:
000F74r 1  A0 00                ldy     #$00
000F76r 1  B1 AC                lda     (LOWTR),y
000F78r 1  C8                   iny
000F79r 1  C5 95                cmp     VARNAM
000F7Br 1  D0 06                bne     L303A
000F7Dr 1  A5 96                lda     VARNAM+1
000F7Fr 1  D1 AC                cmp     (LOWTR),y
000F81r 1  F0 16                beq     USE_OLD_ARRAY
000F83r 1               L303A:
000F83r 1  C8                   iny
000F84r 1  B1 AC                lda     (LOWTR),y
000F86r 1  18                   clc
000F87r 1  65 AC                adc     LOWTR
000F89r 1  AA                   tax
000F8Ar 1  C8                   iny
000F8Br 1  B1 AC                lda     (LOWTR),y
000F8Dr 1  65 AD                adc     LOWTR+1
000F8Fr 1  90 D7                bcc     L301F
000F91r 1               
000F91r 1               ; =============================================================================
000F91r 1               ; ERROR:  BAD SUBSCRIPTS
000F91r 1               ; =============================================================================
000F91r 1               
000F91r 1               SUBERR:
000F91r 1  A2 10                ldx     #ERR_BADSUBS
000F93r 1  2C                   .byte   $2C
000F94r 1               
000F94r 1               ; =============================================================================
000F94r 1               ; ERROR:  ILLEGAL QUANTITY
000F94r 1               ; =============================================================================
000F94r 1               
000F94r 1               IQERR:
000F94r 1  A2 08                ldx     #ERR_ILLQTY
000F96r 1               JER:
000F96r 1  4C rr rr             jmp     ERROR
000F99r 1               
000F99r 1               ; =============================================================================
000F99r 1               ; FOUND THE ARRAY
000F99r 1               ; =============================================================================
000F99r 1               
000F99r 1               USE_OLD_ARRAY:
000F99r 1  A2 12                ldx     #ERR_REDIMD
000F9Br 1  A5 5E                lda     DIMFLG
000F9Dr 1  D0 F7                bne     JER
000F9Fr 1  20 rr rr             jsr     GETARY
000FA2r 1  A5 5D                lda     EOLPNTR
000FA4r 1  A0 04                ldy     #$04
000FA6r 1  D1 AC                cmp     (LOWTR),y
000FA8r 1  D0 E7                bne     SUBERR
000FAAr 1  4C rr rr             jmp     FIND_ARRAY_ELEMENT
000FADr 1               
000FADr 1               ; =============================================================================
000FADr 1               ; CREATE A NEW ARRAY, UNLESS CALLED FROM GETARYPT
000FADr 1               ; =============================================================================
000FADr 1               
000FADr 1               MAKE_NEW_ARRAY:
000FADr 1  20 rr rr             jsr     GETARY
000FB0r 1  20 rr rr             jsr     REASON
000FB3r 1  A9 00                lda     #$00
000FB5r 1  A8                   tay
000FB6r 1  85 BD                sta     STRNG2+1
000FB8r 1  A2 04                ldx     #BYTES_PER_ELEMENT
000FBAr 1  86 BC                stx     STRNG2
000FBCr 1  A5 95                lda     VARNAM
000FBEr 1  91 AC                sta     (LOWTR),y
000FC0r 1  C8                   iny
000FC1r 1  A5 96                lda     VARNAM+1
000FC3r 1  91 AC                sta     (LOWTR),y
000FC5r 1  A5 5D                lda     EOLPNTR
000FC7r 1  C8                   iny
000FC8r 1  C8                   iny
000FC9r 1  C8                   iny
000FCAr 1  91 AC                sta     (LOWTR),y
000FCCr 1               L308A:
000FCCr 1  A2 0B                ldx     #$0B
000FCEr 1  A9 00                lda     #$00
000FD0r 1  24 5E                bit     DIMFLG
000FD2r 1  50 08                bvc     L309A
000FD4r 1  68                   pla
000FD5r 1  18                   clc
000FD6r 1  69 01                adc     #$01
000FD8r 1  AA                   tax
000FD9r 1  68                   pla
000FDAr 1  69 00                adc     #$00
000FDCr 1               L309A:
000FDCr 1  C8                   iny
000FDDr 1  91 AC                sta     (LOWTR),y
000FDFr 1  C8                   iny
000FE0r 1  8A                   txa
000FE1r 1  91 AC                sta     (LOWTR),y
000FE3r 1  20 rr rr             jsr     MULTIPLY_SUBSCRIPT
000FE6r 1  86 BC                stx     STRNG2
000FE8r 1  85 BD                sta     STRNG2+1
000FEAr 1  A4 73                ldy     INDEX
000FECr 1  C6 5D                dec     EOLPNTR
000FEEr 1  D0 DC                bne     L308A
000FF0r 1  65 A7                adc     HIGHDS+1
000FF2r 1  B0 5D                bcs     GME
000FF4r 1  85 A7                sta     HIGHDS+1
000FF6r 1  A8                   tay
000FF7r 1  8A                   txa
000FF8r 1  65 A6                adc     HIGHDS
000FFAr 1  90 03                bcc     L30BD
000FFCr 1  C8                   iny
000FFDr 1  F0 52                beq     GME
000FFFr 1               L30BD:
000FFFr 1  20 rr rr             jsr     REASON
001002r 1  85 81                sta     STREND
001004r 1  84 82                sty     STREND+1
001006r 1  A9 00                lda     #$00
001008r 1  E6 BD                inc     STRNG2+1
00100Ar 1  A4 BC                ldy     STRNG2
00100Cr 1  F0 05                beq     L30D1
00100Er 1               L30CC:
00100Er 1  88                   dey
00100Fr 1  91 A6                sta     (HIGHDS),y
001011r 1  D0 FB                bne     L30CC
001013r 1               L30D1:
001013r 1  C6 A7                dec     HIGHDS+1
001015r 1  C6 BD                dec     STRNG2+1
001017r 1  D0 F5                bne     L30CC
001019r 1  E6 A7                inc     HIGHDS+1
00101Br 1  38                   sec
00101Cr 1  A5 81                lda     STREND
00101Er 1  E5 AC                sbc     LOWTR
001020r 1  A0 02                ldy     #$02
001022r 1  91 AC                sta     (LOWTR),y
001024r 1  A5 82                lda     STREND+1
001026r 1  C8                   iny
001027r 1  E5 AD                sbc     LOWTR+1
001029r 1  91 AC                sta     (LOWTR),y
00102Br 1  A5 5E                lda     DIMFLG
00102Dr 1  D0 58                bne     RTS9
00102Fr 1  C8                   iny
001030r 1               
001030r 1               ; =============================================================================
001030r 1               ; FIND SPECIFIED ARRAY ELEMENT
001030r 1               ;
001030r 1               ; (LOWTR),Y POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
001030r 1               ; THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
001030r 1               ; =============================================================================
001030r 1               
001030r 1               FIND_ARRAY_ELEMENT:
001030r 1  B1 AC                lda     (LOWTR),y
001032r 1  85 5D                sta     EOLPNTR
001034r 1  A9 00                lda     #$00
001036r 1  85 BC                sta     STRNG2
001038r 1               L30F6:
001038r 1  85 BD                sta     STRNG2+1
00103Ar 1  C8                   iny
00103Br 1  68                   pla
00103Cr 1  AA                   tax
00103Dr 1  85 B0                sta     FAC_LAST-1
00103Fr 1  68                   pla
001040r 1  85 B1                sta     FAC_LAST
001042r 1  D1 AC                cmp     (LOWTR),y
001044r 1  90 0E                bcc     FAE2
001046r 1  D0 06                bne     GSE
001048r 1  C8                   iny
001049r 1  8A                   txa
00104Ar 1  D1 AC                cmp     (LOWTR),y
00104Cr 1  90 07                bcc     FAE3
00104Er 1               
00104Er 1               ; =============================================================================
00104Er 1               
00104Er 1               GSE:
00104Er 1  4C rr rr             jmp     SUBERR
001051r 1               GME:
001051r 1  4C rr rr             jmp     MEMERR
001054r 1               
001054r 1               ; =============================================================================
001054r 1               
001054r 1               FAE2:
001054r 1  C8                   iny
001055r 1               FAE3:
001055r 1  A5 BD                lda     STRNG2+1
001057r 1  05 BC                ora     STRNG2
001059r 1  18                   clc
00105Ar 1  F0 0A                beq     L3124
00105Cr 1  20 rr rr             jsr     MULTIPLY_SUBSCRIPT
00105Fr 1  8A                   txa
001060r 1  65 B0                adc     FAC_LAST-1
001062r 1  AA                   tax
001063r 1  98                   tya
001064r 1  A4 73                ldy     INDEX
001066r 1               L3124:
001066r 1  65 B1                adc     FAC_LAST
001068r 1  86 BC                stx     STRNG2
00106Ar 1  C6 5D                dec     EOLPNTR
00106Cr 1  D0 CA                bne     L30F6
00106Er 1  06 BC                asl     STRNG2
001070r 1  2A                   rol     a
001071r 1  B0 DB                bcs     GSE
001073r 1  06 BC                asl     STRNG2
001075r 1  2A                   rol     a
001076r 1  B0 D6                bcs     GSE
001078r 1  A8                   tay
001079r 1  A5 BC                lda     STRNG2
00107Br 1  65 A6                adc     HIGHDS
00107Dr 1  85 97                sta     VARPNT
00107Fr 1  98                   tya
001080r 1  65 A7                adc     HIGHDS+1
001082r 1  85 98                sta     VARPNT+1
001084r 1  A8                   tay
001085r 1  A5 97                lda     VARPNT
001087r 1               RTS9:
001087r 1  60                   rts
001088r 1               
001088r 1               ; =============================================================================
001088r 1               ; MULTIPLY (STRNG2) BY ((LOWTR),Y)
001088r 1               ; LEAVING PRODUCT IN A,X.  (HI-BYTE ALSO IN Y.)
001088r 1               ; USED ONLY BY ARRAY SUBSCRIPT ROUTINES
001088r 1               ; =============================================================================
001088r 1               
001088r 1               MULTIPLY_SUBSCRIPT:
001088r 1  84 73                sty     INDEX
00108Ar 1  B1 AC                lda     (LOWTR),y
00108Cr 1  85 78                sta     RESULT_LAST-2
00108Er 1  88                   dey
00108Fr 1  B1 AC                lda     (LOWTR),y
001091r 1  85 79                sta     RESULT_LAST-1
001093r 1  A9 10                lda     #$10
001095r 1  85 AA                sta     INDX
001097r 1  A2 00                ldx     #$00
001099r 1  A0 00                ldy     #$00
00109Br 1               L3163:
00109Br 1  8A                   txa
00109Cr 1  0A                   asl     a
00109Dr 1  AA                   tax
00109Er 1  98                   tya
00109Fr 1  2A                   rol     a
0010A0r 1  A8                   tay
0010A1r 1  B0 AE                bcs     GME
0010A3r 1  06 BC                asl     STRNG2
0010A5r 1  26 BD                rol     STRNG2+1
0010A7r 1  90 0B                bcc     L317C
0010A9r 1  18                   clc
0010AAr 1  8A                   txa
0010ABr 1  65 78                adc     RESULT_LAST-2
0010ADr 1  AA                   tax
0010AEr 1  98                   tya
0010AFr 1  65 79                adc     RESULT_LAST-1
0010B1r 1  A8                   tay
0010B2r 1  B0 9D                bcs     GME
0010B4r 1               L317C:
0010B4r 1  C6 AA                dec     INDX
0010B6r 1  D0 E3                bne     L3163
0010B8r 1  60                   rts
0010B9r 1               
0010B9r 1               ; =============================================================================
0010B9r 1               ; "FRE" FUNCTION
0010B9r 1               ;
0010B9r 1               ; COLLECTS GARBAGE AND RETURNS # BYTES OF MEMORY LEFT
0010B9r 1               ; =============================================================================
0010B9r 1               
0010B9r 1               FRE:
0010B9r 1  A5 5F                lda     VALTYP
0010BBr 1  F0 03                beq     L3188
0010BDr 1  20 rr rr             jsr     FREFAC
0010C0r 1               L3188:
0010C0r 1  20 rr rr             jsr     GARBAG
0010C3r 1  38                   sec
0010C4r 1  A5 83                lda     FRETOP
0010C6r 1  E5 81                sbc     STREND
0010C8r 1  A8                   tay
0010C9r 1  A5 84                lda     FRETOP+1
0010CBr 1  E5 82                sbc     STREND+1
0010CDr 1               ; FALL INTO GIVAYF TO FLOAT THE VALUE
0010CDr 1               ; NOTE THAT VALUES OVER 32767 WILL RETURN AS NEGATIVE
0010CDr 1               
0010CDr 1               ; =============================================================================
0010CDr 1               ; FLOAT THE SIGNED INTEGER IN A,Y
0010CDr 1               ; =============================================================================
0010CDr 1               
0010CDr 1               GIVAYF:
0010CDr 1  A2 00                ldx     #$00
0010CFr 1  86 5F                stx     VALTYP
0010D1r 1  85 AF                sta     FAC+1
0010D3r 1  84 B0                sty     FAC+2
0010D5r 1  A2 90                ldx     #$90
0010D7r 1  4C rr rr             jmp     FLOAT1
0010DAr 1               POS:
0010DAr 1  A4 0E                ldy     POSX
0010DCr 1               
0010DCr 1               ; =============================================================================
0010DCr 1               ; FLOAT (Y) INTO FAC, GIVING VALUE 0-255
0010DCr 1               ; =============================================================================
0010DCr 1               
0010DCr 1               SNGFLT:
0010DCr 1  A9 00                lda     #$00
0010DEr 1  F0 ED                beq     GIVAYF
0010E0r 1               
0010E0r 1               ; =============================================================================
0010E0r 1               ; CHECK FOR DIRECT OR RUNNING MODE
0010E0r 1               ; GIVING ERROR IF DIRECT MODE
0010E0r 1               ; =============================================================================
0010E0r 1               
0010E0r 1               ERRDIR:
0010E0r 1  A6 8A                ldx     CURLIN+1
0010E2r 1  E8                   inx
0010E3r 1  D0 A2                bne     RTS9
0010E5r 1  A2 16                ldx     #ERR_ILLDIR
0010E7r 1               L31AF:
0010E7r 1  4C rr rr             jmp     ERROR
0010EAr 1               DEF:
0010EAr 1  20 rr rr             jsr     FNC
0010EDr 1  20 rr rr             jsr     ERRDIR
0010F0r 1  20 rr rr             jsr     CHKOPN
0010F3r 1  A9 80                lda     #$80
0010F5r 1  85 61                sta     SUBFLG
0010F7r 1  20 rr rr             jsr     PTRGET
0010FAr 1  20 rr rr             jsr     CHKNUM
0010FDr 1  20 rr rr             jsr     CHKCLS
001100r 1  A9 B6                lda     #TOKEN_EQUAL
001102r 1  20 rr rr             jsr     SYNCHR
001105r 1  A5 98                lda     VARPNT+1
001107r 1  48                   pha
001108r 1  A5 97                lda     VARPNT
00110Ar 1  48                   pha
00110Br 1  A5 D0                lda     TXTPTR+1
00110Dr 1  48                   pha
00110Er 1  A5 CF                lda     TXTPTR
001110r 1  48                   pha
001111r 1  20 rr rr             jsr     DATA
001114r 1  4C rr rr             jmp     L3250
001117r 1               FNC:
001117r 1  A9 A9                lda     #TOKEN_FN
001119r 1  20 rr rr             jsr     SYNCHR
00111Cr 1  09 80                ora     #$80
00111Er 1  85 61                sta     SUBFLG
001120r 1  20 rr rr             jsr     PTRGET3
001123r 1  85 9E                sta     FNCNAM
001125r 1  84 9F                sty     FNCNAM+1
001127r 1  4C rr rr             jmp     CHKNUM
00112Ar 1               L31F3:
00112Ar 1  20 rr rr             jsr     FNC
00112Dr 1  A5 9F                lda     FNCNAM+1
00112Fr 1  48                   pha
001130r 1  A5 9E                lda     FNCNAM
001132r 1  48                   pha
001133r 1  20 rr rr             jsr     PARCHK
001136r 1  20 rr rr             jsr     CHKNUM
001139r 1  68                   pla
00113Ar 1  85 9E                sta     FNCNAM
00113Cr 1  68                   pla
00113Dr 1  85 9F                sta     FNCNAM+1
00113Fr 1  A0 02                ldy     #$02
001141r 1  A2 20                ldx     #ERR_UNDEFFN
001143r 1  B1 9E                lda     (FNCNAM),y
001145r 1  F0 A0                beq     L31AF
001147r 1  85 97                sta     VARPNT
001149r 1  AA                   tax
00114Ar 1  C8                   iny
00114Br 1  B1 9E                lda     (FNCNAM),y
00114Dr 1  85 98                sta     VARPNT+1
00114Fr 1               L3219:
00114Fr 1  B1 97                lda     (VARPNT),y
001151r 1  48                   pha
001152r 1  88                   dey
001153r 1  10 FA                bpl     L3219
001155r 1  A4 98                ldy     VARPNT+1
001157r 1  20 rr rr             jsr     STORE_FAC_AT_YX_ROUNDED
00115Ar 1  A5 D0                lda     TXTPTR+1
00115Cr 1  48                   pha
00115Dr 1  A5 CF                lda     TXTPTR
00115Fr 1  48                   pha
001160r 1  B1 9E                lda     (FNCNAM),y
001162r 1  85 CF                sta     TXTPTR
001164r 1  C8                   iny
001165r 1  B1 9E                lda     (FNCNAM),y
001167r 1  85 D0                sta     TXTPTR+1
001169r 1  A5 98                lda     VARPNT+1
00116Br 1  48                   pha
00116Cr 1  A5 97                lda     VARPNT
00116Er 1  48                   pha
00116Fr 1  20 rr rr             jsr     FRMNUM
001172r 1  68                   pla
001173r 1  85 9E                sta     FNCNAM
001175r 1  68                   pla
001176r 1  85 9F                sta     FNCNAM+1
001178r 1  20 CE 00             jsr     CHRGOT
00117Br 1  F0 03                beq     L324A
00117Dr 1  4C rr rr             jmp     SYNERR
001180r 1               L324A:
001180r 1  68                   pla
001181r 1  85 CF                sta     TXTPTR
001183r 1  68                   pla
001184r 1  85 D0                sta     TXTPTR+1
001186r 1               L3250:
001186r 1  A0 00                ldy     #$00
001188r 1  68                   pla
001189r 1  91 9E                sta     (FNCNAM),y
00118Br 1  68                   pla
00118Cr 1  C8                   iny
00118Dr 1  91 9E                sta     (FNCNAM),y
00118Fr 1  68                   pla
001190r 1  C8                   iny
001191r 1  91 9E                sta     (FNCNAM),y
001193r 1  68                   pla
001194r 1  C8                   iny
001195r 1  91 9E                sta     (FNCNAM),y
001197r 1  60                   rts
001198r 1               ; =============================================================================
001198r 1               ; "STR$" FUNCTION
001198r 1               ; =============================================================================
001198r 1               
001198r 1               STR:
001198r 1  20 rr rr             jsr     CHKNUM
00119Br 1  A0 00                ldy     #$00
00119Dr 1  20 rr rr             jsr     FOUT1
0011A0r 1  68                   pla
0011A1r 1  68                   pla
0011A2r 1  A9 FF                lda     #$FF
0011A4r 1  A0 00                ldy     #$00
0011A6r 1  F0 12                beq     STRLIT
0011A8r 1               
0011A8r 1               ; =============================================================================
0011A8r 1               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
0011A8r 1               ; ADDRESS IS IN FAC+3,4 AND WHOSE LENGTH IS IN A-REG
0011A8r 1               ; =============================================================================
0011A8r 1               
0011A8r 1               STRINI:
0011A8r 1  A6 B0                ldx     FAC_LAST-1
0011AAr 1  A4 B1                ldy     FAC_LAST
0011ACr 1  86 A0                stx     DSCPTR
0011AEr 1  84 A1                sty     DSCPTR+1
0011B0r 1               
0011B0r 1               ; =============================================================================
0011B0r 1               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
0011B0r 1               ; ADDRESS IS IN Y,X AND WHOSE LENGTH IS IN A-REG
0011B0r 1               ; =============================================================================
0011B0r 1               
0011B0r 1               STRSPA:
0011B0r 1  20 rr rr             jsr     GETSPA
0011B3r 1  86 AF                stx     FAC+1
0011B5r 1  84 B0                sty     FAC+2
0011B7r 1  85 AE                sta     FAC
0011B9r 1  60                   rts
0011BAr 1               
0011BAr 1               ; =============================================================================
0011BAr 1               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
0011BAr 1               ; AND TERMINATED BY $00 OR QUOTATION MARK
0011BAr 1               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
0011BAr 1               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
0011BAr 1               ; =============================================================================
0011BAr 1               
0011BAr 1               STRLIT:
0011BAr 1  A2 22                ldx     #$22
0011BCr 1  86 5B                stx     CHARAC
0011BEr 1  86 5C                stx     ENDCHR
0011C0r 1               
0011C0r 1               ; =============================================================================
0011C0r 1               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
0011C0r 1               ; AND TERMINATED BY $00, (CHARAC), OR (ENDCHR)
0011C0r 1               ;
0011C0r 1               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
0011C0r 1               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
0011C0r 1               ; =============================================================================
0011C0r 1               
0011C0r 1               STRLT2:
0011C0r 1  85 BA                sta     STRNG1
0011C2r 1  84 BB                sty     STRNG1+1
0011C4r 1  85 AF                sta     FAC+1
0011C6r 1  84 B0                sty     FAC+2
0011C8r 1  A0 FF                ldy     #$FF
0011CAr 1               L3298:
0011CAr 1  C8                   iny
0011CBr 1  B1 BA                lda     (STRNG1),y
0011CDr 1  F0 0C                beq     L32A9
0011CFr 1  C5 5B                cmp     CHARAC
0011D1r 1  F0 04                beq     L32A5
0011D3r 1  C5 5C                cmp     ENDCHR
0011D5r 1  D0 F3                bne     L3298
0011D7r 1               L32A5:
0011D7r 1  C9 22                cmp     #$22
0011D9r 1  F0 01                beq     L32AA
0011DBr 1               L32A9:
0011DBr 1  18                   clc
0011DCr 1               L32AA:
0011DCr 1  84 AE                sty     FAC
0011DEr 1  98                   tya
0011DFr 1  65 BA                adc     STRNG1
0011E1r 1  85 BC                sta     STRNG2
0011E3r 1  A6 BB                ldx     STRNG1+1
0011E5r 1  90 01                bcc     L32B6
0011E7r 1  E8                   inx
0011E8r 1               L32B6:
0011E8r 1  86 BD                stx     STRNG2+1
0011EAr 1  A5 BB                lda     STRNG1+1
0011ECr 1  D0 0B                bne     PUTNEW
0011EEr 1  98                   tya
0011EFr 1  20 rr rr             jsr     STRINI
0011F2r 1  A6 BA                ldx     STRNG1
0011F4r 1  A4 BB                ldy     STRNG1+1
0011F6r 1  20 rr rr             jsr     MOVSTR
0011F9r 1               
0011F9r 1               ; =============================================================================
0011F9r 1               ; STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
0011F9r 1               ;
0011F9r 1               ; THE DESCRIPTOR IS NOW IN FAC, FAC+1, FAC+2
0011F9r 1               ; PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+3,4
0011F9r 1               ; =============================================================================
0011F9r 1               
0011F9r 1               PUTNEW:
0011F9r 1  A6 67                ldx     TEMPPT
0011FBr 1  E0 73                cpx     #TEMPST+9
0011FDr 1  D0 05                bne     PUTEMP
0011FFr 1  A2 1C                ldx     #ERR_FRMCPX
001201r 1               JERR:
001201r 1  4C rr rr             jmp     ERROR
001204r 1               PUTEMP:
001204r 1  A5 AE                lda     FAC
001206r 1  95 00                sta     0,x
001208r 1  A5 AF                lda     FAC+1
00120Ar 1  95 01                sta     1,x
00120Cr 1  A5 B0                lda     FAC+2
00120Er 1  95 02                sta     2,x
001210r 1  A0 00                ldy     #$00
001212r 1  86 B0                stx     FAC_LAST-1
001214r 1  84 B1                sty     FAC_LAST
001216r 1  88                   dey
001217r 1  84 5F                sty     VALTYP
001219r 1  86 68                stx     LASTPT
00121Br 1  E8                   inx
00121Cr 1  E8                   inx
00121Dr 1  E8                   inx
00121Er 1  86 67                stx     TEMPPT
001220r 1  60                   rts
001221r 1               
001221r 1               ; =============================================================================
001221r 1               ; MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
001221r 1               ; (A)=# BYTES SPACE TO MAKE
001221r 1               ;
001221r 1               ; RETURN WITH (A) SAME,
001221r 1               ;    AND Y,X = ADDRESS OF SPACE ALLOCATED
001221r 1               ; =============================================================================
001221r 1               
001221r 1               GETSPA:
001221r 1  46 60                lsr     DATAFLG
001223r 1               L32F1:
001223r 1  48                   pha
001224r 1  49 FF                eor     #$FF
001226r 1  38                   sec
001227r 1  65 83                adc     FRETOP
001229r 1  A4 84                ldy     FRETOP+1
00122Br 1  B0 01                bcs     L32FC
00122Dr 1  88                   dey
00122Er 1               L32FC:
00122Er 1  C4 82                cpy     STREND+1
001230r 1  90 11                bcc     L3311
001232r 1  D0 04                bne     L3306
001234r 1  C5 81                cmp     STREND
001236r 1  90 0B                bcc     L3311
001238r 1               L3306:
001238r 1  85 83                sta     FRETOP
00123Ar 1  84 84                sty     FRETOP+1
00123Cr 1  85 85                sta     FRESPC
00123Er 1  84 86                sty     FRESPC+1
001240r 1  AA                   tax
001241r 1  68                   pla
001242r 1  60                   rts
001243r 1               L3311:
001243r 1  A2 0C                ldx     #ERR_MEMFULL
001245r 1  A5 60                lda     DATAFLG
001247r 1  30 B8                bmi     JERR
001249r 1  20 rr rr             jsr     GARBAG
00124Cr 1  A9 80                lda     #$80
00124Er 1  85 60                sta     DATAFLG
001250r 1  68                   pla
001251r 1  D0 D0                bne     L32F1
001253r 1               
001253r 1               ; =============================================================================
001253r 1               ; SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
001253r 1               ; IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
001253r 1               ; BELOW STRING AREA DOWN TO STREND.
001253r 1               ;
001253r 1               ; SJ October 2013.
001253r 1               ; Garbage collector updated with fixed code from 'Fixed BASIC3 ROM' listing
001253r 1               ; available here: http://osiweb.org/software.html
001253r 1               ;
001253r 1               ; =============================================================================
001253r 1               
001253r 1                GARBAG:
001253r 1  A6 87                   LDX     MEMSIZ
001255r 1  A5 88                   LDA     MEMSIZ+1
001257r 1                FINDHIGHESTSTRING:
001257r 1  86 83                   STX     FRETOP
001259r 1  85 84                   STA     FRETOP+1
00125Br 1  A0 00                   LDY     #$00
00125Dr 1  84 9F                   STY     FNCNAM+1
00125Fr 1  84 9E                   STY     FNCNAM
001261r 1  A5 81                   LDA     STREND
001263r 1  A6 82                   LDX     STREND+1
001265r 1  85 AC                   STA     LOWTR
001267r 1  86 AD                   STX     LOWTR+1
001269r 1  A9 6A                   LDA     #TEMPST
00126Br 1  85 73                   STA     INDEX
00126Dr 1  84 74                   STY     INDEX+1
00126Fr 1                  L333D:
00126Fr 1  C5 67                   CMP     TEMPPT
001271r 1  F0 05                   BEQ     L3346
001273r 1  20 rr rr                JSR     CHECK_VARIABLE
001276r 1  F0 F7                   BEQ     L333D
001278r 1                  L3346:
001278r 1  A9 06                   LDA     #BYTES_PER_VARIABLE
00127Ar 1  85 A2                   STA     DSCLEN
00127Cr 1  A5 7D                   LDA     VARTAB
00127Er 1  A6 7E                   LDX     VARTAB+1
001280r 1  85 73                   STA     INDEX
001282r 1  86 74                   STX     INDEX+1
001284r 1                  L3352:
001284r 1  E4 80                   CPX     ARYTAB+1
001286r 1  D0 04                   BNE     L335A
001288r 1  C5 7F                   CMP     ARYTAB
00128Ar 1  F0 05                   BEQ     L335F
00128Cr 1                  L335A:
00128Cr 1  20 rr rr                JSR     CHECK_SIMPLE_VARIABLE
00128Fr 1  F0 F3                   BEQ     L3352
001291r 1                  L335F:
001291r 1  85 A6                   STA     HIGHDS
001293r 1  86 A7                   STX     HIGHDS+1
001295r 1  A9 04                   LDA     #4
001297r 1  85 A2                   STA     DSCLEN
001299r 1                  L3367:
001299r 1  A5 A6                   LDA     HIGHDS
00129Br 1  A6 A7                   LDX     HIGHDS+1
00129Dr 1                  L336B:
00129Dr 1  E4 82                   CPX     STREND+1
00129Fr 1  D0 04                   BNE     L3376
0012A1r 1  C5 81                   CMP     STREND
0012A3r 1  F0 7E                   BEQ     MOVE_HIGHEST_STRING_TO_TOP
0012A5r 1               
0012A5r 1                  L3376:
0012A5r 1  85 73                   STA     INDEX
0012A7r 1  86 74                   STX     INDEX+1
0012A9r 1  A0 01                   LDY     #$01
0012ABr 1  B1 73                   LDA     (INDEX),Y
0012ADr 1  08                      PHP
0012AEr 1  C8                      INY
0012AFr 1  B1 73                   LDA     (INDEX),Y
0012B1r 1  65 A6                   ADC     HIGHDS
0012B3r 1  85 A6                   STA     HIGHDS
0012B5r 1  C8                      INY
0012B6r 1  B1 73                   LDA     (INDEX),Y
0012B8r 1  65 A7                   ADC     HIGHDS+1
0012BAr 1  85 A7                   STA     HIGHDS+1
0012BCr 1  28                      PLP
0012BDr 1  10 DA                   BPL     L3367
0012BFr 1  C8                      INY
0012C0r 1  B1 73                   LDA     (INDEX),Y
0012C2r 1  A0 00                   LDY     #$00
0012C4r 1  0A                      ASL     A
0012C5r 1  69 05                   ADC     #$05
0012C7r 1  65 73                   ADC     INDEX
0012C9r 1  85 73                   STA     INDEX
0012CBr 1  90 02                   BCC     L33A7
0012CDr 1  E6 74                   INC     INDEX+1
0012CFr 1                  L33A7:
0012CFr 1  A6 74                   LDX     INDEX+1
0012D1r 1                  L33A9:
0012D1r 1  E4 A7                   CPX     HIGHDS+1
0012D3r 1  D0 04                   BNE     L33B1
0012D5r 1  C5 A6                   CMP     HIGHDS
0012D7r 1  F0 C4                   BEQ     L336B
0012D9r 1                  L33B1:
0012D9r 1  20 rr rr                JSR     CHECK_VARIABLE
0012DCr 1  F0 F3                   BEQ     L33A9
0012DEr 1               
0012DEr 1                CHECK_SIMPLE_VARIABLE:
0012DEr 1  C8                      INY
0012DFr 1  B1 73                   LDA     (INDEX),Y
0012E1r 1  10 30                   BPL     CHECK_BUMP
0012E3r 1  C8                      INY
0012E4r 1               
0012E4r 1                CHECK_VARIABLE:
0012E4r 1  B1 73                   LDA     (INDEX),Y
0012E6r 1  F0 2B                   BEQ     CHECK_BUMP
0012E8r 1  C8                      INY
0012E9r 1  B1 73                   LDA     (INDEX),Y
0012EBr 1  AA                      TAX
0012ECr 1  C8                      INY
0012EDr 1  B1 73                   LDA     (INDEX),Y
0012EFr 1  C5 84                   CMP     FRETOP+1
0012F1r 1  90 06                   BCC     L33D5
0012F3r 1  D0 1E                   BNE     CHECK_BUMP
0012F5r 1  E4 83                   CPX     FRETOP
0012F7r 1  B0 1A                   BCS     CHECK_BUMP
0012F9r 1                  L33D5:
0012F9r 1  C5 AD                   CMP     LOWTR+1
0012FBr 1  90 16                   BCC     CHECK_BUMP
0012FDr 1  D0 04                   BNE     L33DF
0012FFr 1  E4 AC                   CPX     LOWTR
001301r 1  90 10                   BCC     CHECK_BUMP
001303r 1                  L33DF:
001303r 1  86 AC                   STX     LOWTR
001305r 1  85 AD                   STA     LOWTR+1
001307r 1  A5 73                   LDA     INDEX
001309r 1  A6 74                   LDX     INDEX+1
00130Br 1  85 9E                   STA     FNCNAM
00130Dr 1  86 9F                   STX     FNCNAM+1
00130Fr 1  88                      DEY
001310r 1  88                      DEY
001311r 1  84 A4                   STY     Z52
001313r 1                  CHECK_BUMP:
001313r 1  A5 A2                   LDA     DSCLEN
001315r 1  18                      CLC
001316r 1  65 73                   ADC     INDEX
001318r 1  85 73                   STA     INDEX
00131Ar 1  90 02                   BCC     L33FA
00131Cr 1  E6 74                   INC     INDEX+1
00131Er 1                  L33FA:
00131Er 1  A6 74                   LDX     INDEX+1
001320r 1  A0 00                   LDY     #$00
001322r 1  60                      RTS
001323r 1               
001323r 1                  MOVE_HIGHEST_STRING_TO_TOP:
001323r 1  C6 A2                   DEC     DSCLEN
001325r 1  A5 9F                   LDA     FNCNAM+1
001327r 1  05 9E                   ORA     FNCNAM
001329r 1  F0 F3                   BEQ     L33FA
00132Br 1  A4 A4                   LDY     Z52
00132Dr 1  18                      CLC
00132Er 1  B1 9E                   LDA     (FNCNAM),Y
001330r 1  65 AC                   ADC     LOWTR
001332r 1  85 A8                   STA     HIGHTR
001334r 1  A5 AD                   LDA     LOWTR+1
001336r 1  69 00                   ADC     #$00
001338r 1  85 A9                   STA     HIGHTR+1
00133Ar 1  A5 83                   LDA     FRETOP
00133Cr 1  A6 84                   LDX     FRETOP+1
00133Er 1  85 A6                   STA     HIGHDS
001340r 1  86 A7                   STX     HIGHDS+1
001342r 1  20 rr rr                JSR     BLTU2
001345r 1  A4 A4                   LDY     Z52
001347r 1  C8                      INY
001348r 1  A5 A6                   LDA     HIGHDS
00134Ar 1  91 9E                   STA     (FNCNAM),Y
00134Cr 1  AA                      TAX
00134Dr 1  E6 A7                   INC     HIGHDS+1
00134Fr 1  A5 A7                   LDA     HIGHDS+1
001351r 1  C8                      INY
001352r 1  91 9E                   STA     (FNCNAM),Y
001354r 1  4C rr rr                JMP     FINDHIGHESTSTRING
001357r 1               
001357r 1               ; ----------------------------------------------------------------------------
001357r 1               ; CONCATENATE TWO STRINGS
001357r 1               ; ----------------------------------------------------------------------------
001357r 1               CAT:
001357r 1  A5 B1                lda     FAC_LAST
001359r 1  48                   pha
00135Ar 1  A5 B0                lda     FAC_LAST-1
00135Cr 1  48                   pha
00135Dr 1  20 rr rr             jsr     FRM_ELEMENT
001360r 1  20 rr rr             jsr     CHKSTR
001363r 1  68                   pla
001364r 1  85 BA                sta     STRNG1
001366r 1  68                   pla
001367r 1  85 BB                sta     STRNG1+1
001369r 1  A0 00                ldy     #$00
00136Br 1  B1 BA                lda     (STRNG1),y
00136Dr 1  18                   clc
00136Er 1  71 B0                adc     (FAC_LAST-1),y
001370r 1  90 05                bcc     L3454
001372r 1  A2 1A                ldx     #ERR_STRLONG
001374r 1  4C rr rr             jmp     ERROR
001377r 1               L3454:
001377r 1  20 rr rr             jsr     STRINI
00137Ar 1  20 rr rr             jsr     MOVINS
00137Dr 1  A5 A0                lda     DSCPTR
00137Fr 1  A4 A1                ldy     DSCPTR+1
001381r 1  20 rr rr             jsr     FRETMP
001384r 1  20 rr rr             jsr     MOVSTR1
001387r 1  A5 BA                lda     STRNG1
001389r 1  A4 BB                ldy     STRNG1+1
00138Br 1  20 rr rr             jsr     FRETMP
00138Er 1  20 rr rr             jsr     PUTNEW
001391r 1  4C rr rr             jmp     FRMEVL2
001394r 1               
001394r 1               ; =============================================================================
001394r 1               ; GET STRING DESCRIPTOR POINTED AT BY (STRNG1)
001394r 1               ; AND MOVE DESCRIBED STRING TO (FRESPC)
001394r 1               ; =============================================================================
001394r 1               
001394r 1               MOVINS:
001394r 1  A0 00                ldy     #$00
001396r 1  B1 BA                lda     (STRNG1),y
001398r 1  48                   pha
001399r 1  C8                   iny
00139Ar 1  B1 BA                lda     (STRNG1),y
00139Cr 1  AA                   tax
00139Dr 1  C8                   iny
00139Er 1  B1 BA                lda     (STRNG1),y
0013A0r 1  A8                   tay
0013A1r 1  68                   pla
0013A2r 1               
0013A2r 1               ; =============================================================================
0013A2r 1               ; MOVE STRING AT (Y,X) WITH LENGTH (A)
0013A2r 1               ; TO DESTINATION WHOSE ADDRESS IS IN FRESPC,FRESPC+1
0013A2r 1               ; =============================================================================
0013A2r 1               
0013A2r 1               MOVSTR:
0013A2r 1  86 73                stx     INDEX
0013A4r 1  84 74                sty     INDEX+1
0013A6r 1               MOVSTR1:
0013A6r 1  A8                   tay
0013A7r 1  F0 0A                beq     L3490
0013A9r 1  48                   pha
0013AAr 1               L3487:
0013AAr 1  88                   dey
0013ABr 1  B1 73                lda     (INDEX),y
0013ADr 1  91 85                sta     (FRESPC),y
0013AFr 1  98                   tya
0013B0r 1  D0 F8                bne     L3487
0013B2r 1  68                   pla
0013B3r 1               L3490:
0013B3r 1  18                   clc
0013B4r 1  65 85                adc     FRESPC
0013B6r 1  85 85                sta     FRESPC
0013B8r 1  90 02                bcc     L3499
0013BAr 1  E6 86                inc     FRESPC+1
0013BCr 1               L3499:
0013BCr 1  60                   rts
0013BDr 1               
0013BDr 1               ; =============================================================================
0013BDr 1               ; IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
0013BDr 1               ; =============================================================================
0013BDr 1               
0013BDr 1               FRESTR:
0013BDr 1  20 rr rr             jsr     CHKSTR
0013C0r 1               
0013C0r 1               ; =============================================================================
0013C0r 1               ; IF STRING DESCRIPTOR POINTED TO BY FAC+3,4 IS
0013C0r 1               ; A TEMPORARY STRING, RELEASE IT.
0013C0r 1               ; =============================================================================
0013C0r 1               
0013C0r 1               FREFAC:
0013C0r 1  A5 B0                lda     FAC_LAST-1
0013C2r 1  A4 B1                ldy     FAC_LAST
0013C4r 1               
0013C4r 1               ; =============================================================================
0013C4r 1               ; IF STRING DESCRIPTOR WHOSE ADDRESS IS IN Y,A IS
0013C4r 1               ; A TEMPORARY STRING, RELEASE IT.
0013C4r 1               ; =============================================================================
0013C4r 1               
0013C4r 1               FRETMP:
0013C4r 1  85 73                sta     INDEX
0013C6r 1  84 74                sty     INDEX+1
0013C8r 1  20 rr rr             jsr     FRETMS
0013CBr 1  08                   php
0013CCr 1  A0 00                ldy     #$00
0013CEr 1  B1 73                lda     (INDEX),y
0013D0r 1  48                   pha
0013D1r 1  C8                   iny
0013D2r 1  B1 73                lda     (INDEX),y
0013D4r 1  AA                   tax
0013D5r 1  C8                   iny
0013D6r 1  B1 73                lda     (INDEX),y
0013D8r 1  A8                   tay
0013D9r 1  68                   pla
0013DAr 1  28                   plp
0013DBr 1  D0 13                bne     L34CD
0013DDr 1  C4 84                cpy     FRETOP+1
0013DFr 1  D0 0F                bne     L34CD
0013E1r 1  E4 83                cpx     FRETOP
0013E3r 1  D0 0B                bne     L34CD
0013E5r 1  48                   pha
0013E6r 1  18                   clc
0013E7r 1  65 83                adc     FRETOP
0013E9r 1  85 83                sta     FRETOP
0013EBr 1  90 02                bcc     L34CC
0013EDr 1  E6 84                inc     FRETOP+1
0013EFr 1               L34CC:
0013EFr 1  68                   pla
0013F0r 1               L34CD:
0013F0r 1  86 73                stx     INDEX
0013F2r 1  84 74                sty     INDEX+1
0013F4r 1  60                   rts
0013F5r 1               
0013F5r 1               ; =============================================================================
0013F5r 1               ; RELEASE TEMPORARY DESCRIPTOR IF Y,A = LASTPT
0013F5r 1               ; =============================================================================
0013F5r 1               
0013F5r 1               FRETMS:
0013F5r 1  C4 69                cpy     LASTPT+1
0013F7r 1  D0 0C                bne     L34E2
0013F9r 1  C5 68                cmp     LASTPT
0013FBr 1  D0 08                bne     L34E2
0013FDr 1  85 67                sta     TEMPPT
0013FFr 1  E9 03                sbc     #$03
001401r 1  85 68                sta     LASTPT
001403r 1  A0 00                ldy     #$00
001405r 1               L34E2:
001405r 1  60                   rts
001406r 1               
001406r 1               ; =============================================================================
001406r 1               ; "CHR$" FUNCTION
001406r 1               ; =============================================================================
001406r 1               
001406r 1               CHRSTR:
001406r 1  20 rr rr             jsr     CONINT
001409r 1  8A                   txa
00140Ar 1  48                   pha
00140Br 1  A9 01                lda     #$01		; 1 byte string.
00140Dr 1  20 rr rr             jsr     STRSPA		; Create space for it.
001410r 1  68                   pla
001411r 1  A0 00                ldy     #$00
001413r 1  91 AF                sta     (FAC+1),y	; Store the string at that adderess.
001415r 1  68                   pla
001416r 1  68                   pla
001417r 1  4C rr rr             jmp     PUTNEW
00141Ar 1               
00141Ar 1               ; =============================================================================
00141Ar 1               ; "LEFT$" FUNCTION
00141Ar 1               ; =============================================================================
00141Ar 1               
00141Ar 1               LEFTSTR:
00141Ar 1  20 rr rr             jsr     SUBSTRING_SETUP
00141Dr 1  D1 A0                cmp     (DSCPTR),y
00141Fr 1  98                   tya
001420r 1               SUBSTRING1:
001420r 1  90 04                bcc     L3503
001422r 1  B1 A0                lda     (DSCPTR),y
001424r 1  AA                   tax
001425r 1  98                   tya
001426r 1               L3503:
001426r 1  48                   pha
001427r 1               SUBSTRING2:
001427r 1  8A                   txa
001428r 1               SUBSTRING3:
001428r 1  48                   pha
001429r 1  20 rr rr             jsr     STRSPA
00142Cr 1  A5 A0                lda     DSCPTR
00142Er 1  A4 A1                ldy     DSCPTR+1
001430r 1  20 rr rr             jsr     FRETMP
001433r 1  68                   pla
001434r 1  A8                   tay
001435r 1  68                   pla
001436r 1  18                   clc
001437r 1  65 73                adc     INDEX
001439r 1  85 73                sta     INDEX
00143Br 1  90 02                bcc     L351C
00143Dr 1  E6 74                inc     INDEX+1
00143Fr 1               L351C:
00143Fr 1  98                   tya
001440r 1  20 rr rr             jsr     MOVSTR1
001443r 1  4C rr rr             jmp     PUTNEW
001446r 1               
001446r 1               ; =============================================================================
001446r 1               ; "RIGHT$" FUNCTION
001446r 1               ; =============================================================================
001446r 1               
001446r 1               RIGHTSTR:
001446r 1  20 rr rr             jsr     SUBSTRING_SETUP
001449r 1  18                   clc
00144Ar 1  F1 A0                sbc     (DSCPTR),y
00144Cr 1  49 FF                eor     #$FF
00144Er 1  4C rr rr             jmp     SUBSTRING1
001451r 1               
001451r 1               ; =============================================================================
001451r 1               ; "MID$" FUNCTION
001451r 1               ; =============================================================================
001451r 1               
001451r 1               MIDSTR:
001451r 1  A9 FF                lda     #$FF
001453r 1  85 B1                sta     FAC_LAST
001455r 1  20 CE 00             jsr     CHRGOT
001458r 1  C9 29                cmp     #$29
00145Ar 1  F0 06                beq     L353F
00145Cr 1  20 rr rr             jsr     CHKCOM
00145Fr 1  20 rr rr             jsr     GETBYT
001462r 1               L353F:
001462r 1  20 rr rr             jsr     SUBSTRING_SETUP
001465r 1  CA                   dex
001466r 1  8A                   txa
001467r 1  48                   pha
001468r 1  18                   clc
001469r 1  A2 00                ldx     #$00
00146Br 1  F1 A0                sbc     (DSCPTR),y
00146Dr 1  B0 B8                bcs     SUBSTRING2
00146Fr 1  49 FF                eor     #$FF
001471r 1  C5 B1                cmp     FAC_LAST
001473r 1  90 B3                bcc     SUBSTRING3
001475r 1  A5 B1                lda     FAC_LAST
001477r 1  B0 AF                bcs     SUBSTRING3
001479r 1               
001479r 1               ; =============================================================================
001479r 1               ; COMMON SETUP ROUTINE FOR LEFT$, RIGHT$, MID$:
001479r 1               ; REQUIRE ")"; POP RETURN ADRS, GET DESCRIPTOR
001479r 1               ; ADDRESS, GET 1ST PARAMETER OF COMMAND
001479r 1               ; =============================================================================
001479r 1               
001479r 1               SUBSTRING_SETUP:
001479r 1  20 rr rr             jsr     CHKCLS
00147Cr 1  68                   pla
00147Dr 1  85 A4                sta     JMPADRS+1
00147Fr 1  68                   pla
001480r 1  85 A5                sta     JMPADRS+2
001482r 1  68                   pla
001483r 1  68                   pla
001484r 1  68                   pla
001485r 1  AA                   tax
001486r 1  68                   pla
001487r 1  85 A0                sta     DSCPTR
001489r 1  68                   pla
00148Ar 1  85 A1                sta     DSCPTR+1
00148Cr 1  A0 00                ldy     #$00
00148Er 1  8A                   txa
00148Fr 1  F0 21                beq     GOIQ
001491r 1  E6 A4                inc     JMPADRS+1
001493r 1  6C A4 00             jmp     (JMPADRS+1)
001496r 1               
001496r 1               ; =============================================================================
001496r 1               ; "LEN" FUNCTION
001496r 1               ; =============================================================================
001496r 1               
001496r 1               LEN:
001496r 1  20 rr rr             jsr     GETSTR
001499r 1               SNGFLT1:
001499r 1  4C rr rr             jmp     SNGFLT
00149Cr 1               
00149Cr 1               ; =============================================================================
00149Cr 1               ; IF LAST RESULT IS A TEMPORARY STRING, FREE IT
00149Cr 1               ; MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
00149Cr 1               ; =============================================================================
00149Cr 1               
00149Cr 1               GETSTR:
00149Cr 1  20 rr rr             jsr     FRESTR
00149Fr 1  A2 00                ldx     #$00
0014A1r 1  86 5F                stx     VALTYP
0014A3r 1  A8                   tay
0014A4r 1  60                   rts
0014A5r 1               
0014A5r 1               ; =============================================================================
0014A5r 1               ; "ASC" FUNCTION
0014A5r 1               ; =============================================================================
0014A5r 1               
0014A5r 1               ASC:
0014A5r 1  20 rr rr             jsr     GETSTR
0014A8r 1  F0 08                beq     GOIQ
0014AAr 1  A0 00                ldy     #$00
0014ACr 1  B1 73                lda     (INDEX),y
0014AEr 1  A8                   tay
0014AFr 1  4C rr rr             jmp     SNGFLT1
0014B2r 1               
0014B2r 1               ; =============================================================================
0014B2r 1               GOIQ:
0014B2r 1  4C rr rr             jmp     IQERR
0014B5r 1               
0014B5r 1               ; =============================================================================
0014B5r 1               ; SCAN TO NEXT CHARACTER AND CONVERT EXPRESSION
0014B5r 1               ; TO SINGLE BYTE IN X-REG
0014B5r 1               ; =============================================================================
0014B5r 1               
0014B5r 1               GTBYTC:
0014B5r 1  20 C8 00             jsr     CHRGET
0014B8r 1               
0014B8r 1               ; =============================================================================
0014B8r 1               ; EVALUATE EXPRESSION AT TXTPTR, AND
0014B8r 1               ; CONVERT IT TO SINGLE BYTE IN X-REG
0014B8r 1               ; =============================================================================
0014B8r 1               
0014B8r 1               GETBYT:
0014B8r 1  20 rr rr             jsr     FRMNUM
0014BBr 1               
0014BBr 1               ; =============================================================================
0014BBr 1               ; CONVERT (FAC) TO SINGLE BYTE INTEGER IN X-REG
0014BBr 1               ; =============================================================================
0014BBr 1               
0014BBr 1               CONINT:
0014BBr 1  20 rr rr             jsr     MKINT
0014BEr 1  A6 B0                ldx     FAC_LAST-1
0014C0r 1  D0 F0                bne     GOIQ
0014C2r 1  A6 B1                ldx     FAC_LAST
0014C4r 1  4C CE 00             jmp     CHRGOT
0014C7r 1               
0014C7r 1               ; =============================================================================
0014C7r 1               ; "VAL" FUNCTION
0014C7r 1               ; =============================================================================
0014C7r 1               
0014C7r 1               VAL:
0014C7r 1  20 rr rr             jsr     GETSTR
0014CAr 1  D0 03                bne     L35AC
0014CCr 1  4C rr rr             jmp     ZERO_FAC
0014CFr 1               L35AC:
0014CFr 1  A6 CF                ldx     TXTPTR
0014D1r 1  A4 D0                ldy     TXTPTR+1
0014D3r 1  86 BC                stx     STRNG2
0014D5r 1  84 BD                sty     STRNG2+1
0014D7r 1  A6 73                ldx     INDEX
0014D9r 1  86 CF                stx     TXTPTR
0014DBr 1  18                   clc
0014DCr 1  65 73                adc     INDEX
0014DEr 1  85 75                sta     DEST
0014E0r 1  A6 74                ldx     INDEX+1
0014E2r 1  86 D0                stx     TXTPTR+1
0014E4r 1  90 01                bcc     L35C4
0014E6r 1  E8                   inx
0014E7r 1               L35C4:
0014E7r 1  86 76                stx     DEST+1
0014E9r 1  A0 00                ldy     #$00
0014EBr 1  B1 75                lda     (DEST),y
0014EDr 1  48                   pha
0014EEr 1  A9 00                lda     #$00
0014F0r 1  91 75                sta     (DEST),y
0014F2r 1  20 CE 00             jsr     CHRGOT
0014F5r 1  20 rr rr             jsr     FIN
0014F8r 1  68                   pla
0014F9r 1  A0 00                ldy     #$00
0014FBr 1  91 75                sta     (DEST),y
0014FDr 1               
0014FDr 1               ; =============================================================================
0014FDr 1               ; COPY STRNG2 INTO TXTPTR
0014FDr 1               ; =============================================================================
0014FDr 1               
0014FDr 1               POINT:
0014FDr 1  A6 BC                ldx     STRNG2
0014FFr 1  A4 BD                ldy     STRNG2+1
001501r 1  86 CF                stx     TXTPTR
001503r 1  84 D0                sty     TXTPTR+1
001505r 1  60                   rts
001506r 1               ; =============================================================================
001506r 1               ; EVALUATE "EXP1,EXP2"
001506r 1               ;
001506r 1               ; CONVERT EXP1 TO 16-BIT NUMBER IN LINNUM
001506r 1               ; CONVERT EXP2 TO 8-BIT NUMBER IN X-REG
001506r 1               ; =============================================================================
001506r 1               
001506r 1               GTNUM:
001506r 1  20 rr rr             jsr     FRMNUM
001509r 1  20 rr rr             jsr     GETADR
00150Cr 1               
00150Cr 1               ; =============================================================================
00150Cr 1               ; EVALUATE ",EXPRESSION"
00150Cr 1               ; CONVERT EXPRESSION TO SINGLE BYTE IN X-REG
00150Cr 1               ; =============================================================================
00150Cr 1               
00150Cr 1               COMBYTE:
00150Cr 1  20 rr rr             jsr     CHKCOM
00150Fr 1  4C rr rr             jmp     GETBYT
001512r 1               
001512r 1               ; =============================================================================
001512r 1               ; CONVERT (FAC) TO A 16-BIT VALUE IN LINNUM
001512r 1               ; =============================================================================
001512r 1               
001512r 1               GETADR:
001512r 1  A5 B2                lda     FACSIGN
001514r 1  30 9C                bmi     GOIQ
001516r 1  A5 AE                lda     FAC
001518r 1  C9 91                cmp     #$91
00151Ar 1  B0 96                bcs     GOIQ
00151Cr 1  20 rr rr             jsr     QINT
00151Fr 1  A5 B0                lda     FAC_LAST-1
001521r 1  A4 B1                ldy     FAC_LAST
001523r 1  84 11                sty     LINNUM
001525r 1  85 12                sta     LINNUM+1
001527r 1  60                   rts
001528r 1               
001528r 1               ; =============================================================================
001528r 1               ; "PEEK" FUNCTION
001528r 1               ; =============================================================================
001528r 1               
001528r 1               PEEK:
001528r 1  20 rr rr             jsr     GETADR
00152Br 1  A0 00                ldy     #$00
00152Dr 1               ; disallow PEEK between $C000 and $DFFF
00152Dr 1  B1 11                lda     (LINNUM),y
00152Fr 1  A8                   tay
001530r 1  4C rr rr             jmp     SNGFLT
001533r 1               
001533r 1               ; =============================================================================
001533r 1               ; "POKE" STATEMENT
001533r 1               ; =============================================================================
001533r 1               
001533r 1               POKE:
001533r 1  20 rr rr             jsr     GTNUM
001536r 1  8A                   txa
001537r 1  A0 00                ldy     #$00
001539r 1  91 11                sta     (LINNUM),y
00153Br 1  60                   rts
00153Cr 1               
00153Cr 1               
00153Cr 1               ; =============================================================================
00153Cr 1               ; Normal.
00153Cr 1               ; In normal mode (ls_mode = 0) the serial port isn't used.
00153Cr 1               ;==============================================================================
00153Cr 1               
00153Cr 1               NORMAL:
00153Cr 1  A9 00            LDA     #$00
00153Er 1  8D rr rr         STA     ls_mode       	; Clear the load flag.
001541r 1  A9 0B            LDA     #%00001011      ; Set up N parity/echo off/tx int off/rts low/rx int off/dtr active.
001543r 1  8D 02 48         STA     acia1_cm        ; Write to ACIA command register.
001546r 1  AD 00 48         LDA     acia1_d         ; Read the ACIA data register to clear it.
001549r 1  AD 01 48         LDA     acia1_s         ; Read the ACIA status register to clear it.
00154Cr 1  20 rr rr         JSR     Beep1
00154Fr 1  60               RTS
001550r 1               
001550r 1               ; =============================================================================
001550r 1               ; Load
001550r 1               ; When in load mode (ls_mode = 1) we receive characters from the serial
001550r 1               ; port instead of the keyboard. We exit load mode (into normal mode) when
001550r 1               ; a control c is sent via the keyboard.
001550r 1               ;==============================================================================
001550r 1               
001550r 1               LOAD:
001550r 1  A9 01            LDA     #$01            ; Load.
001552r 1  8D rr rr         STA     ls_mode       	; Set the load flag.
001555r 1  A9 09            LDA     #%00001001      ; Set up N parity/echo off/tx int off/rts low/rx int on/dtr active.
001557r 1  8D 02 48         STA     acia1_cm        ; Write to ACIA command register.
00155Ar 1  AD 00 48         LDA     acia1_d         ; Read the data register to clear any errors.
00155Dr 1  20 rr rr         JSR     Beep1
001560r 1  20 rr rr         JSR     Beep2
001563r 1  60               RTS
001564r 1               
001564r 1               ; =============================================================================
001564r 1               ; Binary load.
001564r 1               ; When in binary load mode (ls_mode = 2) we receive characters from the serial
001564r 1               ; port instead of the keyboard. These are put directly into memory.
001564r 1               ; We exit bload mode (normal mode) when a control c is sent via the keyboard.
001564r 1               ;==============================================================================
001564r 1               
001564r 1               BINARY:
001564r 1  A9 02            LDA     #$02            ; Binary Load.
001566r 1  8D rr rr         STA     ls_mode       	; Set the load flag.
001569r 1  A9 00        	lda		#$00			; Reset the counter.
00156Br 1  8D rr rr     	sta		load_count
00156Er 1  8D rr rr     	sta		load_count + 1
001571r 1  A9 09            LDA     #%00001001      ; Set up N parity/echo off/tx int off/rts low/rx int on/dtr active.
001573r 1  8D 02 48         STA     acia1_cm        ; Write to ACIA command register.
001576r 1  AD 00 48         LDA     acia1_d         ; Read the data register to clear any errors.
001579r 1  20 rr rr         JSR     Beep1
00157Cr 1  20 rr rr         JSR     Beep2
00157Fr 1  60               RTS
001580r 1               
001580r 1               ; =============================================================================
001580r 1               ; Save.
001580r 1               ; In save mode (ls_mode = 4) character are echoed to the serial port.
001580r 1               ;==============================================================================
001580r 1               
001580r 1               SAVE:
001580r 1  A9 04            LDA     #$04
001582r 1  8D rr rr         STA     ls_mode       	; Set the save flag.
001585r 1  A9 0B            LDA     #%00001011      ; Set up N parity/echo off/tx int off/rts low/rx int off/dtr active.
001587r 1  8D 02 48         STA     acia1_cm        ; Write to ACIA command register.
00158Ar 1  AD 00 48         LDA     acia1_d         ; Read the ACIA data register to clear it.
00158Dr 1  AD 01 48         LDA     acia1_s         ; Read the ACIA status register to clear it.
001590r 1  20 rr rr         JSR     Beep2
001593r 1  20 rr rr         JSR     Beep1
001596r 1  60               RTS
001597r 1               
001597r 1               ; =============================================================================
001597r 1               ; CLS.
001597r 1               ; Clear the screen.
001597r 1               ; SJ Added Nov 2013.
001597r 1               ; =============================================================================
001597r 1               
001597r 1               CLS:
001597r 1  A9 0C            LDA     #$0C            ; Clear screen.
001599r 1  8D rr rr         STA		char_to_send
00159Cr 1  20 rr rr         JSR     Send_Char_Screen
00159Fr 1  60               RTS
0015A0r 1               
0015A0r 1               ; =============================================================================
0015A0r 1               ; MOVE.
0015A0r 1               ; Moves the to the co-ordinated given in x_val and y_val.
0015A0r 1               ; SJ Added Apr 2014.
0015A0r 1               ; =============================================================================
0015A0r 1               
0015A0r 1               MOVE:
0015A0r 1  A9 0F            LDA     #$0F            	; Set row.
0015A2r 1  8D rr rr         STA		char_to_send
0015A5r 1  20 rr rr         JSR     Send_Char_Screen
0015A8r 1               
0015A8r 1  AD rr rr         LDA     y_val            	; Y value.
0015ABr 1  8D rr rr         STA		char_to_send
0015AEr 1  20 rr rr         JSR     Send_Char_Screen
0015B1r 1               
0015B1r 1  A9 0E            LDA     #$0E            	; Set column.
0015B3r 1  8D rr rr         STA		char_to_send
0015B6r 1  20 rr rr         JSR     Send_Char_Screen
0015B9r 1               
0015B9r 1  AD rr rr         LDA     x_val            	; X value.
0015BCr 1  8D rr rr         STA		char_to_send
0015BFr 1  20 rr rr         JSR     Send_Char_Screen
0015C2r 1  60               RTS
0015C3r 1               
0015C3r 1               
0015C3r 1               ; =============================================================================
0015C3r 1               ; Plot.
0015C3r 1               ; Plot a pixel at this point.
0015C3r 1               ; Point set by x_val, y_val. Colour set by c_val.
0015C3r 1               ; SJ Added Jan 2014.
0015C3r 1               ; =============================================================================
0015C3r 1               
0015C3r 1               PLOT:
0015C3r 1  AD rr rr     	LDA		x_val				; Get X and Y values.
0015C6r 1  85 C2        	STA		X1
0015C8r 1  AD rr rr     	LDA		y_val
0015CBr 1  85 C3        	STA		Y1
0015CDr 1               PLOT2:
0015CDr 1               
0015CDr 1  A5 C2        	LDA     X1            		; X value.
0015CFr 1  C9 A0            CMP 	#GRAPHICSXMAX		; If either point is off the screen
0015D1r 1  B0 28            BCS 	PLOT_Done			; we don't bother to plot the point.
0015D3r 1  A5 C3            LDA     Y1	            	; Y value.
0015D5r 1  C9 64            CMP 	#GRAPHICSYMAX
0015D7r 1  B0 22            BCS 	PLOT_Done
0015D9r 1               
0015D9r 1  AD rr rr         LDA		c_val				; Check the colour.
0015DCr 1  D0 05            BNE		PLOT_White			; If anything but 0 set it to white.
0015DEr 1               PLOT_Black:
0015DEr 1  A9 06            LDA     #$06            	; Plot black pixel (clear).
0015E0r 1  4C rr rr         JMP 	PLOT_Do
0015E3r 1               PLOT_White:
0015E3r 1  A9 05            LDA     #$05            	; Plot white pixel (set).
0015E5r 1               PLOT_Do:
0015E5r 1  8D rr rr         STA		char_to_send
0015E8r 1  20 rr rr         JSR     Send_Char_Screen
0015EBr 1               
0015EBr 1  A5 C2            LDA     X1            		; X value.
0015EDr 1  8D rr rr         STA		char_to_send
0015F0r 1  20 rr rr         JSR     Send_Char_Screen
0015F3r 1               
0015F3r 1  A5 C3            LDA     Y1	            	; Y value.
0015F5r 1  8D rr rr         STA		char_to_send
0015F8r 1  20 rr rr         JSR     Send_Char_Screen
0015FBr 1                PLOT_Done:
0015FBr 1  60               RTS
0015FCr 1               
0015FCr 1               ; =============================================================================
0015FCr 1               ; Line.
0015FCr 1               ; Draw a line.
0015FCr 1               ; Points set by x_val, y_val, a_val, b_val. Colour set by c_val.
0015FCr 1               ; SJ Added Jan 2014.
0015FCr 1               ; Code originally by Daryl Rictor.
0015FCr 1               ; =============================================================================
0015FCr 1               
0015FCr 1               LINE:
0015FCr 1               
0015FCr 1  AD rr rr     	LDA		x_val			 ; Copy the variables as they change!
0015FFr 1  85 C2        	STA 	X1
001601r 1  AD rr rr     	LDA		y_val
001604r 1  85 C3        	STA 	Y1
001606r 1  AD rr rr     	LDA		a_val
001609r 1  85 C4        	STA 	X2
00160Br 1  AD rr rr     	LDA		b_val
00160Er 1  85 C5        	STA 	Y2
001610r 1               
001610r 1               LINE2:
001610r 1  8A           	TXA						 ; We use X and Y so save them here.
001611r 1  48           	PHA
001612r 1  98           	TYA
001613r 1  48           	PHA
001614r 1  A5 C4        	LDA 	X2               ; Make sure X1 < X2.
001616r 1  C5 C2        	CMP 	X1
001618r 1  B0 10        	BCS 	LINE_CONT		 ; Branch if X2 >= X1.
00161Ar 1  A5 C5        	LDA 	Y2               ; If not, swap them.
00161Cr 1  A4 C3        	LDY 	Y1
00161Er 1  85 C3        	STA 	Y1
001620r 1  84 C5        	STY 	Y2
001622r 1  A5 C2        	LDA 	X1
001624r 1  A4 C4        	LDY 	X2
001626r 1  84 C2        	STY 	X1
001628r 1  85 C4        	STA 	X2
00162Ar 1               
00162Ar 1               LINE_CONT:
00162Ar 1  A5 C4        	LDA 	X2
00162Cr 1  38           	SEC
00162Dr 1  E5 C2        	SBC 	X1
00162Fr 1               	;LSR
00162Fr 1  85 BE        	STA 	DX		            ; Set DX.
001631r 1  D0 2C        	BNE 	LINE_NVT			; SJ rearranged code here due to 128 jump limit.
001633r 1               
001633r 1               LINE_VERT:
001633r 1  38           	SEC
001634r 1  A5 C5        	LDA 	Y2                	; Calculate DY.
001636r 1  E5 C3        	SBC 	Y1
001638r 1  90 16        	BCC 	LINE_VNEG
00163Ar 1  4C rr rr     	JMP 	LINE_VP2
00163Dr 1               LINE_VP1:
00163Dr 1  E6 C3        	INC 	Y1
00163Fr 1               LINE_VP2:
00163Fr 1  20 rr rr     	JSR 	PLOT2
001642r 1  38           	SEC
001643r 1  A5 C5        	LDA 	Y2
001645r 1  E5 C3        	SBC 	Y1
001647r 1  D0 F4        	BNE 	LINE_VP1
001649r 1  68           	PLA
00164Ar 1  A8           	TAY
00164Br 1  68           	PLA
00164Cr 1  AA           	TAX
00164Dr 1  60           	RTS
00164Er 1               LINE_VN1:
00164Er 1  C6 C3            DEC 	Y1
001650r 1               LINE_VNEG:
001650r 1  20 rr rr     	JSR 	PLOT2
001653r 1  38           	SEC
001654r 1  A5 C5        	LDA 	Y2
001656r 1  E5 C3        	SBC 	Y1
001658r 1  D0 F4        	BNE 	LINE_VN1
00165Ar 1  68           	PLA
00165Br 1  A8           	TAY
00165Cr 1  68           	PLA
00165Dr 1  AA           	TAX
00165Er 1  60           	RTS
00165Fr 1               
00165Fr 1               LINE_NVT:
00165Fr 1  A9 00        	LDA 	#0
001661r 1  85 BF        	STA 	IX
001663r 1  85 C1        	STA 	IY
001665r 1  A5 C5        	LDA 	Y2               	; Calculate DY.
001667r 1  38           	SEC
001668r 1  E5 C3        	SBC 	Y1
00166Ar 1  F0 07        	BEQ 	LINE_HORZ
00166Cr 1               LINE_NHZ:
00166Cr 1  90 55        	BCC 	LINE_YNEG		    ; Negative slope.
00166Er 1  4C rr rr     	JMP		LINE_YPOS			; SJ rearranged code here to get around 128 byte jump limit.
001671r 1               LINE_HRZ:
001671r 1  E6 C2        	INC 	X1
001673r 1               LINE_HORZ:
001673r 1  20 rr rr     	JSR 	PLOT2
001676r 1  A5 C4        	LDA 	X2
001678r 1  38           	SEC
001679r 1  E5 C2        	SBC 	X1
00167Br 1  D0 F4        	BNE 	LINE_HRZ
00167Dr 1  68           	PLA
00167Er 1  A8           	TAY
00167Fr 1  68           	PLA
001680r 1  AA           	TAX
001681r 1  60           	RTS
001682r 1               
001682r 1               LINE_YPOS:
001682r 1               	;LSR
001682r 1  85 C0        	STA 	DY                	; Positive slope.
001684r 1  20 rr rr     	JSR 	PLOT2		        ; Plot X1, Y1.
001687r 1               
001687r 1               LINE_LOOP0:
001687r 1  A2 00        	LDX 	#0		            ; Plot needed flag.
001689r 1               LINE_LOOP:
001689r 1  18           	CLC
00168Ar 1  A5 BF        	LDA 	IX
00168Cr 1  65 BE        	ADC 	DX
00168Er 1  85 BF        	STA 	IX
001690r 1  90 03        	BCC 	LINE_LOOP1
001692r 1  E8           	INX			            	; Plot needed yes.
001693r 1  E6 C2        	INC 	X1
001695r 1               LINE_LOOP1:
001695r 1  18           	CLC
001696r 1  A5 C1        	LDA 	IY
001698r 1  65 C0        	ADC 	DY
00169Ar 1  85 C1        	STA 	IY
00169Cr 1  90 03        	BCC 	LINE_LOOP2
00169Er 1  E8           	INX			            	; Plot needed yes.
00169Fr 1  E6 C3        	INC 	Y1
0016A1r 1               LINE_LOOP2:
0016A1r 1  8A           	TXA
0016A2r 1  F0 E5        	BEQ 	LINE_LOOP		    ; LINE_LOOP if no plt needed.
0016A4r 1  20 rr rr     	JSR 	PLOT2
0016A7r 1  A5 C2        	LDA 	X1
0016A9r 1  C5 C4        	CMP 	X2
0016ABr 1  F0 06        	BEQ 	LINE_END
0016ADr 1  A5 C3        	LDA 	Y1
0016AFr 1  C5 C5        	CMP 	Y2
0016B1r 1  D0 D4        	BNE 	LINE_LOOP0          ; RESET X=0, LINE_LOOP again.
0016B3r 1               LINE_END:
0016B3r 1  A5 C4        	LDA 	X2
0016B5r 1  85 C2        	STA 	X1
0016B7r 1  A5 C5        	LDA 	Y2
0016B9r 1  85 C3        	STA 	Y1
0016BBr 1  20 rr rr     	JSR 	PLOT2				; Plot final point.
0016BEr 1  68           	PLA
0016BFr 1  A8           	TAY
0016C0r 1  68           	PLA
0016C1r 1  AA           	TAX
0016C2r 1  60           	RTS
0016C3r 1               
0016C3r 1               LINE_YNEG:
0016C3r 1  20 rr rr     	JSR 	PLOT2				; Plot first point.
0016C6r 1  A5 C3        	LDA 	Y1
0016C8r 1  38           	SEC
0016C9r 1  E5 C5        	SBC 	Y2
0016CBr 1               	;LSR
0016CBr 1  85 C0        	STA 	DY					; Delta Y.
0016CDr 1               
0016CDr 1               LINE_LOOPX:
0016CDr 1  A2 00        	LDX 	#0
0016CFr 1               LINE_LOOP3:
0016CFr 1  18           	CLC
0016D0r 1  A5 BF        	LDA 	IX
0016D2r 1  65 BE        	ADC 	DX
0016D4r 1  85 BF        	STA 	IX
0016D6r 1  90 03        	BCC 	LINE_LOOP4
0016D8r 1  E8           	INX
0016D9r 1  E6 C2        	INC 	X1
0016DBr 1               LINE_LOOP4:
0016DBr 1  18           	CLC
0016DCr 1  A5 C1        	LDA 	IY
0016DEr 1  65 C0        	ADC 	DY
0016E0r 1  85 C1        	STA 	IY
0016E2r 1  90 03        	BCC 	LINE_LOOP5
0016E4r 1  E8           	INX
0016E5r 1  C6 C3        	DEC 	Y1					; Only diff from YPOS code is here!
0016E7r 1               LINE_LOOP5:
0016E7r 1  8A           	TXA
0016E8r 1  F0 E5        	BEQ 	LINE_LOOP3          ; No adjustment yet.
0016EAr 1  20 rr rr     	JSR 	PLOT2
0016EDr 1  A5 C2        	LDA 	X1
0016EFr 1  C5 C4        	CMP 	X2
0016F1r 1  F0 C0        	BEQ 	LINE_END
0016F3r 1  A5 C3        	LDA 	Y1
0016F5r 1  C5 C5        	CMP 	Y2
0016F7r 1  F0 BA        	BEQ 	LINE_END			; If no 128 byte branch limit, fix this.
0016F9r 1  4C rr rr     	JMP 	LINE_LOOPX
0016FCr 1               
0016FCr 1               ; =============================================================================
0016FCr 1               ; Rect.
0016FCr 1               ; Draw a rectangular box.
0016FCr 1               ; Points set by x_val, y_val, a_val, b_val. Colour set by c_val.
0016FCr 1               ; SJ Added Jan 2014.
0016FCr 1               ; Line(x1,y1, x2,y1)
0016FCr 1               ; Line(x2,y1, x2,y2)
0016FCr 1               ; Line(x2,y2, x1,y2)
0016FCr 1               ; Line(x1,y2, x1,y1)
0016FCr 1               ; =============================================================================
0016FCr 1               
0016FCr 1               RECT:
0016FCr 1               
0016FCr 1  AD rr rr     	LDA		x_val
0016FFr 1  85 C2        	STA 	X1
001701r 1  AD rr rr     	LDA		y_val
001704r 1  85 C3        	STA 	Y1
001706r 1  AD rr rr     	LDA		a_val
001709r 1  85 C4        	STA 	X2
00170Br 1  AD rr rr     	LDA		y_val
00170Er 1  85 C5        	STA 	Y2
001710r 1  20 rr rr     	JSR		LINE2
001713r 1               
001713r 1  AD rr rr     	LDA		a_val
001716r 1  85 C2        	STA 	X1
001718r 1  AD rr rr     	LDA		y_val
00171Br 1  85 C3        	STA 	Y1
00171Dr 1  AD rr rr     	LDA		a_val
001720r 1  85 C4        	STA 	X2
001722r 1  AD rr rr     	LDA		b_val
001725r 1  85 C5        	STA 	Y2
001727r 1  20 rr rr     	JSR		LINE2
00172Ar 1               
00172Ar 1  AD rr rr     	LDA		a_val
00172Dr 1  85 C2        	STA 	X1
00172Fr 1  AD rr rr     	LDA		b_val
001732r 1  85 C3        	STA 	Y1
001734r 1  AD rr rr     	LDA		x_val
001737r 1  85 C4        	STA 	X2
001739r 1  AD rr rr     	LDA		b_val
00173Cr 1  85 C5        	STA 	Y2
00173Er 1  20 rr rr     	JSR		LINE2
001741r 1               
001741r 1  AD rr rr     	LDA		x_val
001744r 1  85 C2        	STA 	X1
001746r 1  AD rr rr     	LDA		b_val
001749r 1  85 C3        	STA 	Y1
00174Br 1  AD rr rr     	LDA		x_val
00174Er 1  85 C4        	STA 	X2
001750r 1  AD rr rr     	LDA		y_val
001753r 1  85 C5        	STA 	Y2
001755r 1  20 rr rr     	JSR		LINE2
001758r 1               
001758r 1  60           	RTS
001759r 1               
001759r 1               ; =============================================================================
001759r 1               ; Circle.
001759r 1               ; Draw a circle.
001759r 1               ; Points set by x_val, y_val.
001759r 1               ; Radius set by a_val. Colour set by c_val.
001759r 1               ; SJ Added Jan 2014.
001759r 1               ; Original code by Daryl Rictor.
001759r 1               ; Modified for 8 bit.
001759r 1               ; =============================================================================
001759r 1               
001759r 1               CIRC:
001759r 1               
001759r 1  AD rr rr     	LDA		x_val			; Store X and Y initial centre values.
00175Cr 1  85 BF        	STA		IX
00175Er 1  AD rr rr     	LDA		y_val
001761r 1  85 C1        	STA		IY
001763r 1               
001763r 1  AD rr rr     	LDA		a_val			; Store radius.
001766r 1  85 C7        	STA		Rad
001768r 1               
001768r 1  D0 0C          	bne   	CIRCLE_C1
00176Ar 1  A5 BF           	lda   	IX      		; If radius = 0, plot center point and exit.
00176Cr 1  85 C2           	sta   	X1      		; Move center point to plot point variable.
00176Er 1  A5 C1           	lda   	IY
001770r 1  85 C3           	STA   	Y1
001772r 1  4C rr rr     	jmp   	PLOT2   		; Plot as a point and exit.
001775r 1  60           	RTS
001776r 1               
001776r 1               CIRCLE_C1:
001776r 1  A5 C7           	LDA   	Rad      		; Load radius.
001778r 1  85 C0           	sta   	DY   			; Y = radius.
00177Ar 1  A9 00           	LDA   	#$00
00177Cr 1  85 BE           	STA   	DX				; X = 0.
00177Er 1               
00177Er 1  38              	sec 					; FF = 1 - radius.
00177Fr 1  A9 01           	lda   	#$01
001781r 1  E5 C7           	sbc   	Rad
001783r 1  85 C6           	sta   	FF
001785r 1               
001785r 1               CIRCLE_C2:
001785r 1  A9 01           	LDA   	#$01			; X2 = 1.
001787r 1  85 C4           	sta   	X2
001789r 1               
001789r 1  A5 C7           	lda   	Rad				; Y2 = -2 * radius.
00178Br 1  0A              	asl         			; *2
00178Cr 1  85 C5           	sta   	Y2
00178Er 1  49 FF           	EOR   	#$FF
001790r 1  85 C5           	sta   	Y2
001792r 1  E6 C5           	inc   	Y2
001794r 1  D0 00           	bne   	CIRCLE_C3
001796r 1               
001796r 1               CIRCLE_C3:
001796r 1  A5 BF           	lda   	IX				; Plot pixel (IX, IY + DY).
001798r 1  85 C2           	sta   	X1
00179Ar 1  18              	clc
00179Br 1  A5 C1           	lda   	IY
00179Dr 1  65 C0           	adc   	DY
00179Fr 1  85 C3           	sta  	Y1
0017A1r 1  20 rr rr        	jsr   	PLOT2
0017A4r 1               
0017A4r 1  38              	sec						; Plot pixel (IX, IY - DY).
0017A5r 1  A5 C1           	lda   	IY
0017A7r 1  E5 C0           	sbc  	DY
0017A9r 1  85 C3           	sta   	Y1
0017ABr 1  20 rr rr        	jsr   	PLOT2
0017AEr 1               
0017AEr 1  18              	clc						; Plot pixel (IX + DY, IY).
0017AFr 1  A5 BF           	lda  	IX
0017B1r 1  65 C0           	adc  	DY
0017B3r 1  85 C2           	sta  	X1
0017B5r 1  A5 C1           	lda  	IY
0017B7r 1  85 C3           	sta  	Y1
0017B9r 1  20 rr rr        	jsr  	PLOT2
0017BCr 1               
0017BCr 1  38              	sec						; Plot pixel (IX - DY, IY).
0017BDr 1  A5 BF           	lda   	IX
0017BFr 1  E5 C0           	sbc   	DY
0017C1r 1  85 C2           	STA  	X1
0017C3r 1  20 rr rr        	jsr  	PLOT2
0017C6r 1               
0017C6r 1               CIRCLE_CLOOP:
0017C6r 1  38              	sec						; While (x < y).
0017C7r 1  A5 BE           	lda   	DX
0017C9r 1  E5 C0           	sbc   	DY
0017CBr 1  90 01           	bcc   	CIRCLE_C4   	; If X < Y.
0017CDr 1  60              	rts						; Done.
0017CEr 1               
0017CEr 1               CIRCLE_C4:
0017CEr 1  A5 C6           	LDA   	FF
0017D0r 1  30 0F           	bmi   	CIRCLE_C6
0017D2r 1  A5 C0           	lda   	DY
0017D4r 1               
0017D4r 1               CIRCLE_C5:
0017D4r 1  C6 C0           	DEC		DY
0017D6r 1  18              	clc
0017D7r 1  A5 C5           	lda   	Y2
0017D9r 1  69 02           	adc   	#$02
0017DBr 1  85 C5           	sta   	Y2
0017DDr 1  65 C6           	adc   	FF
0017DFr 1  85 C6           	sta   	FF
0017E1r 1               
0017E1r 1               CIRCLE_C6:
0017E1r 1  E6 BE           	INC   	DX
0017E3r 1               
0017E3r 1               CIRCLE_C7:
0017E3r 1  18              	CLC
0017E4r 1  A5 C4           	lda   	X2
0017E6r 1  69 02           	adc   	#$02
0017E8r 1  85 C4           	sta   	X2
0017EAr 1  65 C6           	adc   	FF
0017ECr 1  85 C6           	sta   	FF
0017EEr 1               
0017EEr 1  20 rr rr        	JSR		PLOT8
0017F1r 1  4C rr rr        	jmp   	CIRCLE_CLOOP
0017F4r 1               
0017F4r 1               
0017F4r 1               ; =============================================================================
0017F4r 1               ; Circle.
0017F4r 1               ; Draw a circle.
0017F4r 1               ; Points set by x_val, y_val.
0017F4r 1               ; Radius set by a_val. Colour set by c_val.
0017F4r 1               ; SJ Added Jan 2014.
0017F4r 1               ; =============================================================================
0017F4r 1               
0017F4r 1               
0017F4r 1               ; =============================================================================
0017F4r 1               ; PLOT8.
0017F4r 1               ; 8 way plotting routine for circle drawing.
0017F4r 1               ; SJ Added Jan 2014.
0017F4r 1               ; Original code by Stephen Judd from here:
0017F4r 1               ; http://www.ffd2.com/fridge/chacking/c=hacking9.txt
0017F4r 1               ; =============================================================================
0017F4r 1               
0017F4r 1               PLOT8:
0017F4r 1               
0017F4r 1  48           	PHA		; Push A.
0017F5r 1               
0017F5r 1               ;40 POKE 784, DX+IX:POKE 785, DY+IY
0017F5r 1               ;50 PLOT
0017F5r 1               ;60 POKE 784, DY+IX:POKE 785, DX+IY
0017F5r 1               ;70 PLOT
0017F5r 1               
0017F5r 1               ;1.
0017F5r 1  18           	CLC
0017F6r 1  A5 BE        	LDA		DX
0017F8r 1  65 BF        	ADC		IX
0017FAr 1  85 C2        	STA		X1
0017FCr 1  18           	CLC
0017FDr 1  A5 C0        	LDA		DY
0017FFr 1  65 C1        	ADC		IY
001801r 1  85 C3        	STA		Y1
001803r 1  20 rr rr     	JSR 	PLOT2
001806r 1               
001806r 1               ;2.
001806r 1  18           	CLC
001807r 1  A5 C0        	LDA		DY
001809r 1  65 BF        	ADC		IX
00180Br 1  85 C2        	STA		X1
00180Dr 1  18           	CLC
00180Er 1  A5 BE        	LDA		DX
001810r 1  65 C1        	ADC		IY
001812r 1  85 C3        	STA		Y1
001814r 1  20 rr rr     	JSR 	PLOT2
001817r 1               
001817r 1               ;80 POKE 784, IX-DX:POKE 785, IY+DY
001817r 1               ;90 PLOT
001817r 1               ;100 POKE 784, IX-DY:POKE 785, IY+DX
001817r 1               ;110 PLOT
001817r 1               
001817r 1               ;3.
001817r 1  A5 BF        	LDA		IX
001819r 1  38           	SEC
00181Ar 1  E5 BE        	SBC		DX
00181Cr 1  85 C2        	STA		X1
00181Er 1  18           	CLC
00181Fr 1  A5 C1        	LDA		IY
001821r 1  65 C0        	ADC		DY
001823r 1  85 C3        	STA		Y1
001825r 1  20 rr rr     	JSR 	PLOT2
001828r 1               
001828r 1               ;4.
001828r 1  A5 BF        	LDA		IX
00182Ar 1  38           	SEC
00182Br 1  E5 C0        	SBC		DY
00182Dr 1  85 C2        	STA		X1
00182Fr 1  18           	CLC
001830r 1  A5 C1        	LDA		IY
001832r 1  65 BE        	ADC		DX
001834r 1  85 C3        	STA		Y1
001836r 1  20 rr rr     	JSR 	PLOT2
001839r 1               
001839r 1               ;120 POKE 784, IX-DX:POKE 785, IY-DY
001839r 1               ;130 PLOT
001839r 1               ;140 POKE 784, IX-DY:POKE 785, IY-DX
001839r 1               ;150 PLOT
001839r 1               
001839r 1               ;5.
001839r 1  A5 BF        	LDA		IX
00183Br 1  38           	SEC
00183Cr 1  E5 BE        	SBC		DX
00183Er 1  85 C2        	STA		X1
001840r 1  A5 C1        	LDA		IY
001842r 1  38           	SEC
001843r 1  E5 C0        	SBC		DY
001845r 1  85 C3        	STA		Y1
001847r 1  20 rr rr     	JSR 	PLOT2
00184Ar 1               
00184Ar 1               ;6.
00184Ar 1  A5 BF        	LDA		IX
00184Cr 1  38           	SEC
00184Dr 1  E5 C0        	SBC		DY
00184Fr 1  85 C2        	STA		X1
001851r 1  A5 C1        	LDA		IY
001853r 1  38           	SEC
001854r 1  E5 BE        	SBC		DX
001856r 1  85 C3        	STA		Y1
001858r 1  20 rr rr     	JSR 	PLOT2
00185Br 1               
00185Br 1               ;160 POKE 784, IX+DX:POKE 785, IY-DY
00185Br 1               ;170 PLOT
00185Br 1               ;180 POKE 784, IX+DY:POKE 785, IY-DX
00185Br 1               ;190 PLOT
00185Br 1               
00185Br 1               ;7.
00185Br 1  18           	CLC
00185Cr 1  A5 BF        	LDA		IX
00185Er 1  65 BE        	ADC		DX
001860r 1  85 C2        	STA		X1
001862r 1  A5 C1        	LDA		IY
001864r 1  38           	SEC
001865r 1  E5 C0        	SBC		DY
001867r 1  85 C3        	STA		Y1
001869r 1  20 rr rr     	JSR 	PLOT2
00186Cr 1               
00186Cr 1               ;8.
00186Cr 1  18           	CLC
00186Dr 1  A5 BF        	LDA		IX
00186Fr 1  65 C0        	ADC		DY
001871r 1  85 C2        	STA		X1
001873r 1  A5 C1        	LDA		IY
001875r 1  38           	SEC
001876r 1  E5 BE        	SBC		DX
001878r 1  85 C3        	STA		Y1
00187Ar 1  20 rr rr     	JSR 	PLOT2
00187Dr 1               
00187Dr 1  68           	PLA		; Pop A.
00187Er 1  60           	RTS
00187Fr 1               
00187Fr 1               ; =============================================================================
00187Fr 1               ; "WAIT" STATEMENT
00187Fr 1               ; =============================================================================
00187Fr 1               
00187Fr 1               WAIT:
00187Fr 1  20 rr rr             jsr     GTNUM
001882r 1  86 99                stx     FORPNT
001884r 1  A2 00                ldx     #$00
001886r 1  20 CE 00             jsr     CHRGOT
001889r 1  F0 03                beq     L3628
00188Br 1  20 rr rr             jsr     COMBYTE
00188Er 1               L3628:
00188Er 1  86 9A                stx     FORPNT+1
001890r 1  A0 00                ldy     #$00
001892r 1               L362C:
001892r 1  B1 11                lda     (LINNUM),y
001894r 1  45 9A                eor     FORPNT+1
001896r 1  25 99                and     FORPNT
001898r 1  F0 F8                beq     L362C
00189Ar 1               RTS3:
00189Ar 1  60                   rts
00189Br 1               TEMP1X = TEMP1+(5-BYTES_FP)
00189Br 1               ; =============================================================================
00189Br 1               ; ADD 0.5 TO FAC
00189Br 1               ; =============================================================================
00189Br 1               
00189Br 1               FADDH:
00189Br 1  A9 rr                lda     #<CON_HALF
00189Dr 1  A0 rr                ldy     #>CON_HALF
00189Fr 1  4C rr rr             jmp     FADD
0018A2r 1               
0018A2r 1               ; =============================================================================
0018A2r 1               ; FAC = (Y,A) - FAC
0018A2r 1               ; =============================================================================
0018A2r 1               
0018A2r 1               FSUB:
0018A2r 1  20 rr rr             jsr     LOAD_ARG_FROM_YA
0018A5r 1               
0018A5r 1               ; =============================================================================
0018A5r 1               ; FAC = ARG - FAC
0018A5r 1               ; =============================================================================
0018A5r 1               
0018A5r 1               FSUBT:
0018A5r 1  A5 B2                lda     FACSIGN
0018A7r 1  49 FF                eor     #$FF
0018A9r 1  85 B2                sta     FACSIGN
0018ABr 1  45 B9                eor     ARGSIGN
0018ADr 1  85 BA                sta     SGNCPR
0018AFr 1  A5 AE                lda     FAC
0018B1r 1  4C rr rr             jmp     FADDT
0018B4r 1               
0018B4r 1               ; =============================================================================
0018B4r 1               ; SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
0018B4r 1               ; =============================================================================
0018B4r 1               
0018B4r 1               FADD1:
0018B4r 1  20 rr rr             jsr     SHIFT_RIGHT
0018B7r 1  90 3C                bcc     FADD3
0018B9r 1               
0018B9r 1               ; =============================================================================
0018B9r 1               ; FAC = (Y,A) + FAC
0018B9r 1               ; =============================================================================
0018B9r 1               
0018B9r 1               FADD:
0018B9r 1  20 rr rr             jsr     LOAD_ARG_FROM_YA
0018BCr 1               
0018BCr 1               ; =============================================================================
0018BCr 1               ; FAC = ARG + FAC
0018BCr 1               ; =============================================================================
0018BCr 1               
0018BCr 1               FADDT:
0018BCr 1  D0 03                bne     L365B
0018BEr 1  4C rr rr             jmp     COPY_ARG_TO_FAC
0018C1r 1               L365B:
0018C1r 1  A6 BB                ldx     FACEXTENSION
0018C3r 1  86 A5                stx     ARGEXTENSION
0018C5r 1  A2 B5                ldx     #ARG
0018C7r 1  A5 B5                lda     ARG
0018C9r 1               FADD2:
0018C9r 1  A8                   tay
0018CAr 1  F0 CE                beq     RTS3
0018CCr 1  38                   sec
0018CDr 1  E5 AE                sbc     FAC
0018CFr 1  F0 24                beq     FADD3
0018D1r 1  90 12                bcc     L367F
0018D3r 1  84 AE                sty     FAC
0018D5r 1  A4 B9                ldy     ARGSIGN
0018D7r 1  84 B2                sty     FACSIGN
0018D9r 1  49 FF                eor     #$FF
0018DBr 1  69 00                adc     #$00
0018DDr 1  A0 00                ldy     #$00
0018DFr 1  84 A5                sty     ARGEXTENSION
0018E1r 1  A2 AE                ldx     #FAC
0018E3r 1  D0 04                bne     L3683
0018E5r 1               L367F:
0018E5r 1  A0 00                ldy     #$00
0018E7r 1  84 BB                sty     FACEXTENSION
0018E9r 1               L3683:
0018E9r 1  C9 F9                cmp     #$F9
0018EBr 1  30 C7                bmi     FADD1
0018EDr 1  A8                   tay
0018EEr 1  A5 BB                lda     FACEXTENSION
0018F0r 1  56 01                lsr     1,x
0018F2r 1  20 rr rr             jsr     SHIFT_RIGHT4
0018F5r 1               FADD3:
0018F5r 1  24 BA                bit     SGNCPR
0018F7r 1  10 4C                bpl     FADD4
0018F9r 1  A0 AE                ldy     #FAC
0018FBr 1  E0 B5                cpx     #ARG
0018FDr 1  F0 02                beq     L369B
0018FFr 1  A0 B5                ldy     #ARG
001901r 1               L369B:
001901r 1  38                   sec
001902r 1  49 FF                eor     #$FF
001904r 1  65 A5                adc     ARGEXTENSION
001906r 1  85 BB                sta     FACEXTENSION
001908r 1  B9 03 00             lda     3,y
00190Br 1  F5 03                sbc     3,x
00190Dr 1  85 B1                sta     FAC+3
00190Fr 1  B9 02 00             lda     2,y
001912r 1  F5 02                sbc     2,x
001914r 1  85 B0                sta     FAC+2
001916r 1  B9 01 00             lda     1,y
001919r 1  F5 01                sbc     1,x
00191Br 1  85 AF                sta     FAC+1
00191Dr 1               
00191Dr 1               ; =============================================================================
00191Dr 1               ; NORMALIZE VALUE IN FAC
00191Dr 1               ; =============================================================================
00191Dr 1               
00191Dr 1               NORMALIZE_FAC1:
00191Dr 1  B0 03                bcs     NORMALIZE_FAC2
00191Fr 1  20 rr rr             jsr     COMPLEMENT_FAC
001922r 1               NORMALIZE_FAC2:
001922r 1  A0 00                ldy     #$00
001924r 1  98                   tya
001925r 1  18                   clc
001926r 1               L36C7:
001926r 1  A6 AF                ldx     FAC+1
001928r 1  D0 3E                bne     NORMALIZE_FAC4
00192Ar 1  A6 B0                ldx     FAC+2
00192Cr 1  86 AF                stx     FAC+1
00192Er 1  A6 B1                ldx     FAC+3
001930r 1  86 B0                stx     FAC+2
001932r 1  A6 BB                ldx     FACEXTENSION
001934r 1  86 B1                stx     FAC+3
001936r 1  84 BB                sty     FACEXTENSION
001938r 1  69 08                adc     #$08
00193Ar 1               ; bugfix?
00193Ar 1               ; fix does not exist on AppleSoft 2
00193Ar 1  C9 18                cmp     #MANTISSA_BYTES*8
00193Cr 1  D0 E8                bne     L36C7
00193Er 1               
00193Er 1               ; =============================================================================
00193Er 1               ; SET FAC = 0
00193Er 1               ; (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
00193Er 1               ; =============================================================================
00193Er 1               
00193Er 1               ZERO_FAC:
00193Er 1  A9 00                lda     #$00
001940r 1               STA_IN_FAC_SIGN_AND_EXP:
001940r 1  85 AE                sta     FAC
001942r 1               STA_IN_FAC_SIGN:
001942r 1  85 B2                sta     FACSIGN
001944r 1  60                   rts
001945r 1               
001945r 1               ; =============================================================================
001945r 1               ; ADD MANTISSAS OF FAC AND ARG INTO FAC
001945r 1               ; =============================================================================
001945r 1               
001945r 1               FADD4:
001945r 1  65 A5                adc     ARGEXTENSION
001947r 1  85 BB                sta     FACEXTENSION
001949r 1  A5 B1                lda     FAC+3
00194Br 1  65 B8                adc     ARG+3
00194Dr 1  85 B1                sta     FAC+3
00194Fr 1  A5 B0                lda     FAC+2
001951r 1  65 B7                adc     ARG+2
001953r 1  85 B0                sta     FAC+2
001955r 1  A5 AF                lda     FAC+1
001957r 1  65 B6                adc     ARG+1
001959r 1  85 AF                sta     FAC+1
00195Br 1  4C rr rr             jmp     NORMALIZE_FAC5
00195Er 1               
00195Er 1               ; =============================================================================
00195Er 1               ; FINISH NORMALIZING FAC
00195Er 1               ; =============================================================================
00195Er 1               
00195Er 1               NORMALIZE_FAC3:
00195Er 1  69 01                adc     #$01
001960r 1  06 BB                asl     FACEXTENSION
001962r 1  26 B1                rol     FAC+3
001964r 1  26 B0                rol     FAC+2
001966r 1  26 AF                rol     FAC+1
001968r 1               NORMALIZE_FAC4:
001968r 1  10 F4                bpl     NORMALIZE_FAC3
00196Ar 1  38                   sec
00196Br 1  E5 AE                sbc     FAC
00196Dr 1  B0 CF                bcs     ZERO_FAC
00196Fr 1  49 FF                eor     #$FF
001971r 1  69 01                adc     #$01
001973r 1  85 AE                sta     FAC
001975r 1               NORMALIZE_FAC5:
001975r 1  90 0C                bcc     L3764
001977r 1               NORMALIZE_FAC6:
001977r 1  E6 AE                inc     FAC
001979r 1  F0 36                beq     OVERFLOW
00197Br 1  66 AF                ror     FAC+1
00197Dr 1  66 B0                ror     FAC+2
00197Fr 1  66 B1                ror     FAC+3
001981r 1  66 BB                ror     FACEXTENSION
001983r 1               L3764:
001983r 1  60                   rts
001984r 1               
001984r 1               ; =============================================================================
001984r 1               ; 2'S COMPLEMENT OF FAC
001984r 1               ; =============================================================================
001984r 1               
001984r 1               COMPLEMENT_FAC:
001984r 1  A5 B2                lda     FACSIGN
001986r 1  49 FF                eor     #$FF
001988r 1  85 B2                sta     FACSIGN
00198Ar 1               
00198Ar 1               ; =============================================================================
00198Ar 1               ; 2'S COMPLEMENT OF FAC MANTISSA ONLY
00198Ar 1               ; =============================================================================
00198Ar 1               
00198Ar 1               COMPLEMENT_FAC_MANTISSA:
00198Ar 1  A5 AF                lda     FAC+1
00198Cr 1  49 FF                eor     #$FF
00198Er 1  85 AF                sta     FAC+1
001990r 1  A5 B0                lda     FAC+2
001992r 1  49 FF                eor     #$FF
001994r 1  85 B0                sta     FAC+2
001996r 1  A5 B1                lda     FAC+3
001998r 1  49 FF                eor     #$FF
00199Ar 1  85 B1                sta     FAC+3
00199Cr 1  A5 BB                lda     FACEXTENSION
00199Er 1  49 FF                eor     #$FF
0019A0r 1  85 BB                sta     FACEXTENSION
0019A2r 1  E6 BB                inc     FACEXTENSION
0019A4r 1  D0 0A                bne     RTS12
0019A6r 1               
0019A6r 1               ; =============================================================================
0019A6r 1               ; INCREMENT FAC MANTISSA
0019A6r 1               ; =============================================================================
0019A6r 1               
0019A6r 1               INCREMENT_FAC_MANTISSA:
0019A6r 1  E6 B1                inc     FAC+3
0019A8r 1  D0 06                bne     RTS12
0019AAr 1  E6 B0                inc     FAC+2
0019ACr 1  D0 02                bne     RTS12
0019AEr 1  E6 AF                inc     FAC+1
0019B0r 1               RTS12:
0019B0r 1  60                   rts
0019B1r 1               OVERFLOW:
0019B1r 1  A2 0A                ldx     #ERR_OVERFLOW
0019B3r 1  4C rr rr             jmp     ERROR
0019B6r 1               
0019B6r 1               ; =============================================================================
0019B6r 1               ; SHIFT 1,X THRU 5,X RIGHT
0019B6r 1               ; (A) = NEGATIVE OF SHIFT COUNT
0019B6r 1               ; (X) = POINTER TO BYTES TO BE SHIFTED
0019B6r 1               ;
0019B6r 1               ; RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
0019B6r 1               ; =============================================================================
0019B6r 1               
0019B6r 1               SHIFT_RIGHT1:
0019B6r 1  A2 76                ldx     #RESULT-1
0019B8r 1               SHIFT_RIGHT2:
0019B8r 1  B4 03                ldy     3,x
0019BAr 1  84 BB                sty     FACEXTENSION
0019BCr 1  B4 02                ldy     2,x
0019BEr 1  94 03                sty     3,x
0019C0r 1  B4 01                ldy     1,x
0019C2r 1  94 02                sty     2,x
0019C4r 1  A4 B4                ldy     SHIFTSIGNEXT
0019C6r 1  94 01                sty     1,x
0019C8r 1               
0019C8r 1               ; =============================================================================
0019C8r 1               ; MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
0019C8r 1               ; =============================================================================
0019C8r 1               
0019C8r 1               SHIFT_RIGHT:
0019C8r 1  69 08                adc     #$08
0019CAr 1  30 EC                bmi     SHIFT_RIGHT2
0019CCr 1  F0 EA                beq     SHIFT_RIGHT2
0019CEr 1  E9 08                sbc     #$08
0019D0r 1  A8                   tay
0019D1r 1  A5 BB                lda     FACEXTENSION
0019D3r 1  B0 12                bcs     SHIFT_RIGHT5
0019D5r 1               LB588:
0019D5r 1  16 01                asl     1,x
0019D7r 1  90 02                bcc     LB58E
0019D9r 1  F6 01                inc     1,x
0019DBr 1               LB58E:
0019DBr 1  76 01                ror     1,x
0019DDr 1  76 01                ror     1,x
0019DFr 1               
0019DFr 1               ; =============================================================================
0019DFr 1               ; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
0019DFr 1               ; =============================================================================
0019DFr 1               
0019DFr 1               SHIFT_RIGHT4:
0019DFr 1  76 02                ror     2,x
0019E1r 1  76 03                ror     3,x
0019E3r 1  6A                   ror     a
0019E4r 1  C8                   iny
0019E5r 1  D0 EE                bne     LB588
0019E7r 1               SHIFT_RIGHT5:
0019E7r 1  18                   clc
0019E8r 1  60                   rts
0019E9r 1               
0019E9r 1               ; =============================================================================
0019E9r 1               
0019E9r 1               CON_ONE:
0019E9r 1  81 00 00 00          .byte   $81,$00,$00,$00
0019EDr 1               POLY_LOG:
0019EDr 1  02                   .byte    $02
0019EEr 1  80 19 56 62          .byte   $80,$19,$56,$62
0019F2r 1  80 76 22 F3          .byte   $80,$76,$22,$F3
0019F6r 1  82 38 AA 40          .byte   $82,$38,$AA,$40
0019FAr 1               CON_SQR_HALF:
0019FAr 1  80 35 04 F3          .byte   $80,$35,$04,$F3
0019FEr 1               CON_SQR_TWO:
0019FEr 1  81 35 04 F3          .byte   $81,$35,$04,$F3
001A02r 1               CON_NEG_HALF:
001A02r 1  80 80 00 00          .byte   $80,$80,$00,$00
001A06r 1               CON_LOG_TWO:
001A06r 1  80 31 72 18          .byte   $80,$31,$72,$18
001A0Ar 1               
001A0Ar 1               ; =============================================================================
001A0Ar 1               ; "LOG" FUNCTION
001A0Ar 1               ; =============================================================================
001A0Ar 1               
001A0Ar 1               LOG:
001A0Ar 1  20 rr rr             jsr     SIGN
001A0Dr 1  F0 02                beq     GIQ
001A0Fr 1  10 03                bpl     LOG2
001A11r 1               GIQ:
001A11r 1  4C rr rr             jmp     IQERR
001A14r 1               LOG2:
001A14r 1  A5 AE                lda     FAC
001A16r 1  E9 7F                sbc     #$7F
001A18r 1  48                   pha
001A19r 1  A9 80                lda     #$80
001A1Br 1  85 AE                sta     FAC
001A1Dr 1  A9 rr                lda     #<CON_SQR_HALF
001A1Fr 1  A0 rr                ldy     #>CON_SQR_HALF
001A21r 1  20 rr rr             jsr     FADD
001A24r 1  A9 rr                lda     #<CON_SQR_TWO
001A26r 1  A0 rr                ldy     #>CON_SQR_TWO
001A28r 1  20 rr rr             jsr     FDIV
001A2Br 1  A9 rr                lda     #<CON_ONE
001A2Dr 1  A0 rr                ldy     #>CON_ONE
001A2Fr 1  20 rr rr             jsr     FSUB
001A32r 1  A9 rr                lda     #<POLY_LOG
001A34r 1  A0 rr                ldy     #>POLY_LOG
001A36r 1  20 rr rr             jsr     POLYNOMIAL_ODD
001A39r 1  A9 rr                lda     #<CON_NEG_HALF
001A3Br 1  A0 rr                ldy     #>CON_NEG_HALF
001A3Dr 1  20 rr rr             jsr     FADD
001A40r 1  68                   pla
001A41r 1  20 rr rr             jsr     ADDACC
001A44r 1  A9 rr                lda     #<CON_LOG_TWO
001A46r 1  A0 rr                ldy     #>CON_LOG_TWO
001A48r 1               
001A48r 1               ; =============================================================================
001A48r 1               ; FAC = (Y,A) * FAC
001A48r 1               ; =============================================================================
001A48r 1               
001A48r 1               FMULT:
001A48r 1  20 rr rr             jsr     LOAD_ARG_FROM_YA
001A4Br 1               
001A4Br 1               ; =============================================================================
001A4Br 1               ; FAC = ARG * FAC
001A4Br 1               ; =============================================================================
001A4Br 1               
001A4Br 1               FMULTT:
001A4Br 1  F0 4C                beq     L3903
001A4Dr 1  20 rr rr             jsr     ADD_EXPONENTS
001A50r 1  A9 00                lda     #$00
001A52r 1  85 77                sta     RESULT
001A54r 1  85 78                sta     RESULT+1
001A56r 1  85 79                sta     RESULT+2
001A58r 1  A5 BB                lda     FACEXTENSION
001A5Ar 1  20 rr rr             jsr     MULTIPLY1
001A5Dr 1  A5 B1                lda     FAC+3
001A5Fr 1  20 rr rr             jsr     MULTIPLY1
001A62r 1  A5 B0                lda     FAC+2
001A64r 1  20 rr rr             jsr     MULTIPLY1
001A67r 1  A5 AF                lda     FAC+1
001A69r 1  20 rr rr             jsr     MULTIPLY2
001A6Cr 1  4C rr rr             jmp     COPY_RESULT_INTO_FAC
001A6Fr 1               
001A6Fr 1               ; =============================================================================
001A6Fr 1               ; MULTIPLY ARG BY (A) INTO RESULT
001A6Fr 1               ; =============================================================================
001A6Fr 1               
001A6Fr 1               MULTIPLY1:
001A6Fr 1  D0 03                bne     MULTIPLY2
001A71r 1  4C rr rr             jmp     SHIFT_RIGHT1
001A74r 1               MULTIPLY2:
001A74r 1  4A                   lsr     a
001A75r 1  09 80                ora     #$80
001A77r 1               L38A7:
001A77r 1  A8                   tay
001A78r 1  90 13                bcc     L38C3
001A7Ar 1  18                   clc
001A7Br 1  A5 79                lda     RESULT+2
001A7Dr 1  65 B8                adc     ARG+3
001A7Fr 1  85 79                sta     RESULT+2
001A81r 1  A5 78                lda     RESULT+1
001A83r 1  65 B7                adc     ARG+2
001A85r 1  85 78                sta     RESULT+1
001A87r 1  A5 77                lda     RESULT
001A89r 1  65 B6                adc     ARG+1
001A8Br 1  85 77                sta     RESULT
001A8Dr 1               L38C3:
001A8Dr 1  66 77                ror     RESULT
001A8Fr 1  66 78                ror     RESULT+1
001A91r 1               ; this seems to be a bad byte in the dump
001A91r 1  66 79                ror     RESULT+2
001A93r 1  66 BB                ror     FACEXTENSION
001A95r 1  98                   tya
001A96r 1  4A                   lsr     a
001A97r 1  D0 DE                bne     L38A7
001A99r 1               L3903:
001A99r 1  60                   rts
001A9Ar 1               
001A9Ar 1               ; =============================================================================
001A9Ar 1               ; UNPACK NUMBER AT (Y,A) INTO ARG
001A9Ar 1               ; =============================================================================
001A9Ar 1               
001A9Ar 1               LOAD_ARG_FROM_YA:
001A9Ar 1  85 73                sta     INDEX
001A9Cr 1  84 74                sty     INDEX+1
001A9Er 1  A0 03                ldy     #BYTES_FP-1
001AA0r 1  B1 73                lda     (INDEX),y
001AA2r 1  85 B8                sta     ARG+3
001AA4r 1  88                   dey
001AA5r 1  B1 73                lda     (INDEX),y
001AA7r 1  85 B7                sta     ARG+2
001AA9r 1  88                   dey
001AAAr 1  B1 73                lda     (INDEX),y
001AACr 1  85 B9                sta     ARGSIGN
001AAEr 1  45 B2                eor     FACSIGN
001AB0r 1  85 BA                sta     SGNCPR
001AB2r 1  A5 B9                lda     ARGSIGN
001AB4r 1  09 80                ora     #$80
001AB6r 1  85 B6                sta     ARG+1
001AB8r 1  88                   dey
001AB9r 1  B1 73                lda     (INDEX),y
001ABBr 1  85 B5                sta     ARG
001ABDr 1  A5 AE                lda     FAC
001ABFr 1  60                   rts
001AC0r 1               
001AC0r 1               ; =============================================================================
001AC0r 1               ; ADD EXPONENTS OF ARG AND FAC
001AC0r 1               ; (CALLED BY FMULT AND FDIV)
001AC0r 1               ;
001AC0r 1               ; ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
001AC0r 1               ; =============================================================================
001AC0r 1               
001AC0r 1               ADD_EXPONENTS:
001AC0r 1  A5 B5                lda     ARG
001AC2r 1               ADD_EXPONENTS1:
001AC2r 1  F0 1F                beq     ZERO
001AC4r 1  18                   clc
001AC5r 1  65 AE                adc     FAC
001AC7r 1  90 04                bcc     L393C
001AC9r 1  30 1D                bmi     JOV
001ACBr 1  18                   clc
001ACCr 1  2C                   .byte   $2C
001ACDr 1               L393C:
001ACDr 1  10 14                bpl     ZERO
001ACFr 1  69 80                adc     #$80
001AD1r 1  85 AE                sta     FAC
001AD3r 1  D0 03                bne     L3947
001AD5r 1  4C rr rr             jmp     STA_IN_FAC_SIGN
001AD8r 1               L3947:
001AD8r 1  A5 BA                lda     SGNCPR
001ADAr 1  85 B2                sta     FACSIGN
001ADCr 1  60                   rts
001ADDr 1               
001ADDr 1               ; =============================================================================
001ADDr 1               ; IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
001ADDr 1               ; IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
001ADDr 1               ; CALLED FROM "EXP" FUNCTION
001ADDr 1               ; =============================================================================
001ADDr 1               
001ADDr 1               OUTOFRNG:
001ADDr 1  A5 B2                lda     FACSIGN
001ADFr 1  49 FF                eor     #$FF
001AE1r 1  30 05                bmi     JOV
001AE3r 1               
001AE3r 1               ; =============================================================================
001AE3r 1               ; POP RETURN ADDRESS AND SET FAC=0
001AE3r 1               ; =============================================================================
001AE3r 1               
001AE3r 1               ZERO:
001AE3r 1  68                   pla
001AE4r 1  68                   pla
001AE5r 1  4C rr rr             jmp     ZERO_FAC
001AE8r 1               JOV:
001AE8r 1  4C rr rr             jmp     OVERFLOW
001AEBr 1               
001AEBr 1               ; =============================================================================
001AEBr 1               ; MULTIPLY FAC BY 10
001AEBr 1               ; =============================================================================
001AEBr 1               
001AEBr 1               MUL10:
001AEBr 1  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001AEEr 1  AA                   tax
001AEFr 1  F0 10                beq     L3970
001AF1r 1  18                   clc
001AF2r 1  69 02                adc     #$02
001AF4r 1  B0 F2                bcs     JOV
001AF6r 1  A2 00                ldx     #$00
001AF8r 1  86 BA                stx     SGNCPR
001AFAr 1  20 rr rr             jsr     FADD2
001AFDr 1  E6 AE                inc     FAC
001AFFr 1  F0 E7                beq     JOV
001B01r 1               L3970:
001B01r 1  60                   rts
001B02r 1               
001B02r 1               ; =============================================================================
001B02r 1               CONTEN:
001B02r 1  84 20 00 00          .byte   $84,$20,$00,$00
001B06r 1               
001B06r 1               ; =============================================================================
001B06r 1               ; DIVIDE FAC BY 10
001B06r 1               ; =============================================================================
001B06r 1               
001B06r 1               DIV10:
001B06r 1  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001B09r 1  A9 rr                lda     #<CONTEN
001B0Br 1  A0 rr                ldy     #>CONTEN
001B0Dr 1  A2 00                ldx     #$00
001B0Fr 1               
001B0Fr 1               ; =============================================================================
001B0Fr 1               ; FAC = ARG / (Y,A)
001B0Fr 1               ; =============================================================================
001B0Fr 1               
001B0Fr 1               DIV:
001B0Fr 1  86 BA                stx     SGNCPR
001B11r 1  20 rr rr             jsr     LOAD_FAC_FROM_YA
001B14r 1  4C rr rr             jmp     FDIVT
001B17r 1               
001B17r 1               ; =============================================================================
001B17r 1               ; FAC = (Y,A) / FAC
001B17r 1               ; =============================================================================
001B17r 1               
001B17r 1               FDIV:
001B17r 1  20 rr rr             jsr     LOAD_ARG_FROM_YA
001B1Ar 1               ; ----------------------------------------------------------------------------
001B1Ar 1               ; FAC = ARG / FAC
001B1Ar 1               ; ----------------------------------------------------------------------------
001B1Ar 1               FDIVT:
001B1Ar 1  F0 68                beq     L3A02
001B1Cr 1  20 rr rr             jsr     ROUND_FAC
001B1Fr 1  A9 00                lda     #$00
001B21r 1  38                   sec
001B22r 1  E5 AE                sbc     FAC
001B24r 1  85 AE                sta     FAC
001B26r 1  20 rr rr             jsr     ADD_EXPONENTS
001B29r 1  E6 AE                inc     FAC
001B2Br 1  F0 BB                beq     JOV
001B2Dr 1  A2 FD                ldx     #-MANTISSA_BYTES
001B2Fr 1  A9 01                lda     #$01
001B31r 1               L39A1:
001B31r 1  A4 B6                ldy     ARG+1
001B33r 1  C4 AF                cpy     FAC+1
001B35r 1  D0 0A                bne     L39B7
001B37r 1  A4 B7                ldy     ARG+2
001B39r 1  C4 B0                cpy     FAC+2
001B3Br 1  D0 04                bne     L39B7
001B3Dr 1  A4 B8                ldy     ARG+3
001B3Fr 1  C4 B1                cpy     FAC+3
001B41r 1               L39B7:
001B41r 1  08                   php
001B42r 1  2A                   rol     a
001B43r 1  90 09                bcc     L39C4
001B45r 1  E8                   inx
001B46r 1  95 79                sta     RESULT_LAST-1,x
001B48r 1  F0 2A                beq     L39F2
001B4Ar 1  10 2C                bpl     L39F6
001B4Cr 1  A9 01                lda     #$01
001B4Er 1               L39C4:
001B4Er 1  28                   plp
001B4Fr 1  B0 0C                bcs     L39D5
001B51r 1               L39C7:
001B51r 1  06 B8                asl     ARG_LAST
001B53r 1  26 B7                rol     ARG+2
001B55r 1  26 B6                rol     ARG+1
001B57r 1  B0 E8                bcs     L39B7
001B59r 1  30 D6                bmi     L39A1
001B5Br 1  10 E4                bpl     L39B7
001B5Dr 1               L39D5:
001B5Dr 1  A8                   tay
001B5Er 1  A5 B8                lda     ARG+3
001B60r 1  E5 B1                sbc     FAC+3
001B62r 1  85 B8                sta     ARG+3
001B64r 1  A5 B7                lda     ARG+2
001B66r 1  E5 B0                sbc     FAC+2
001B68r 1  85 B7                sta     ARG+2
001B6Ar 1  A5 B6                lda     ARG+1
001B6Cr 1  E5 AF                sbc     FAC+1
001B6Er 1  85 B6                sta     ARG+1
001B70r 1  98                   tya
001B71r 1  4C rr rr             jmp     L39C7
001B74r 1               L39F2:
001B74r 1  A9 40                lda     #$40
001B76r 1  D0 D6                bne     L39C4
001B78r 1               L39F6:
001B78r 1  0A                   asl     a
001B79r 1  0A                   asl     a
001B7Ar 1  0A                   asl     a
001B7Br 1  0A                   asl     a
001B7Cr 1  0A                   asl     a
001B7Dr 1  0A                   asl     a
001B7Er 1  85 BB                sta     FACEXTENSION
001B80r 1  28                   plp
001B81r 1  4C rr rr             jmp     COPY_RESULT_INTO_FAC
001B84r 1               L3A02:
001B84r 1  A2 14                ldx     #ERR_ZERODIV
001B86r 1  4C rr rr             jmp     ERROR
001B89r 1               
001B89r 1               ; =============================================================================
001B89r 1               ; COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
001B89r 1               ; =============================================================================
001B89r 1               
001B89r 1               COPY_RESULT_INTO_FAC:
001B89r 1  A5 77                lda     RESULT
001B8Br 1  85 AF                sta     FAC+1
001B8Dr 1  A5 78                lda     RESULT+1
001B8Fr 1  85 B0                sta     FAC+2
001B91r 1  A5 79                lda     RESULT+2
001B93r 1  85 B1                sta     FAC+3
001B95r 1  4C rr rr             jmp     NORMALIZE_FAC2
001B98r 1               
001B98r 1               ; =============================================================================
001B98r 1               ; UNPACK (Y,A) INTO FAC
001B98r 1               ; =============================================================================
001B98r 1               
001B98r 1               LOAD_FAC_FROM_YA:
001B98r 1  85 73                sta     INDEX
001B9Ar 1  84 74                sty     INDEX+1
001B9Cr 1  A0 03                ldy     #MANTISSA_BYTES
001B9Er 1  B1 73                lda     (INDEX),y
001BA0r 1  85 B1                sta     FAC+3
001BA2r 1  88                   dey
001BA3r 1  B1 73                lda     (INDEX),y
001BA5r 1  85 B0                sta     FAC+2
001BA7r 1  88                   dey
001BA8r 1  B1 73                lda     (INDEX),y
001BAAr 1  85 B2                sta     FACSIGN
001BACr 1  09 80                ora     #$80
001BAEr 1  85 AF                sta     FAC+1
001BB0r 1  88                   dey
001BB1r 1  B1 73                lda     (INDEX),y
001BB3r 1  85 AE                sta     FAC
001BB5r 1  84 BB                sty     FACEXTENSION
001BB7r 1  60                   rts
001BB8r 1               
001BB8r 1               ; =============================================================================
001BB8r 1               ; ROUND FAC, STORE IN TEMP2
001BB8r 1               ; =============================================================================
001BB8r 1               
001BB8r 1               STORE_FAC_IN_TEMP2_ROUNDED:
001BB8r 1  A2 AA                ldx     #TEMP2
001BBAr 1  2C                   .byte   $2C
001BBBr 1               
001BBBr 1               ; =============================================================================
001BBBr 1               ; ROUND FAC, STORE IN TEMP1
001BBBr 1               ; =============================================================================
001BBBr 1               
001BBBr 1               STORE_FAC_IN_TEMP1_ROUNDED:
001BBBr 1  A2 A6                ldx     #TEMP1X
001BBDr 1  A0 00                ldy     #$00
001BBFr 1  F0 04                beq     STORE_FAC_AT_YX_ROUNDED
001BC1r 1               
001BC1r 1               ; =============================================================================
001BC1r 1               ; ROUND FAC, AND STORE WHERE FORPNT POINTS
001BC1r 1               ; =============================================================================
001BC1r 1               
001BC1r 1               SETFOR:
001BC1r 1  A6 99                ldx     FORPNT
001BC3r 1  A4 9A                ldy     FORPNT+1
001BC5r 1               
001BC5r 1               ; =============================================================================
001BC5r 1               ; ROUND FAC, AND STORE AT (Y,X)
001BC5r 1               ; =============================================================================
001BC5r 1               
001BC5r 1               STORE_FAC_AT_YX_ROUNDED:
001BC5r 1  20 rr rr             jsr     ROUND_FAC
001BC8r 1  86 73                stx     INDEX
001BCAr 1  84 74                sty     INDEX+1
001BCCr 1  A0 03                ldy     #MANTISSA_BYTES
001BCEr 1  A5 B1                lda     FAC+3
001BD0r 1  91 73                sta     (INDEX),y
001BD2r 1  88                   dey
001BD3r 1  A5 B0                lda     FAC+2
001BD5r 1  91 73                sta     (INDEX),y
001BD7r 1  88                   dey
001BD8r 1  A5 B2                lda     FACSIGN
001BDAr 1  09 7F                ora     #$7F
001BDCr 1  25 AF                and     FAC+1
001BDEr 1  91 73                sta     (INDEX),y
001BE0r 1  88                   dey
001BE1r 1  A5 AE                lda     FAC
001BE3r 1  91 73                sta     (INDEX),y
001BE5r 1  84 BB                sty     FACEXTENSION
001BE7r 1  60                   rts
001BE8r 1               
001BE8r 1               ; =============================================================================
001BE8r 1               ; COPY ARG INTO FAC
001BE8r 1               ; =============================================================================
001BE8r 1               
001BE8r 1               COPY_ARG_TO_FAC:
001BE8r 1  A5 B9                lda     ARGSIGN
001BEAr 1               MFA:
001BEAr 1  85 B2                sta     FACSIGN
001BECr 1  A2 04                ldx     #BYTES_FP
001BEEr 1               L3A7A:
001BEEr 1  B5 B4                lda     SHIFTSIGNEXT,x
001BF0r 1  95 AD                sta     EXPSGN,x
001BF2r 1  CA                   dex
001BF3r 1  D0 F9                bne     L3A7A
001BF5r 1  86 BB                stx     FACEXTENSION
001BF7r 1  60                   rts
001BF8r 1               
001BF8r 1               ; =============================================================================
001BF8r 1               ; ROUND FAC AND COPY TO ARG
001BF8r 1               ; =============================================================================
001BF8r 1               
001BF8r 1               COPY_FAC_TO_ARG_ROUNDED:
001BF8r 1  20 rr rr             jsr     ROUND_FAC
001BFBr 1               MAF:
001BFBr 1  A2 05                ldx     #BYTES_FP+1
001BFDr 1               L3A89:
001BFDr 1  B5 AD                lda     EXPSGN,x
001BFFr 1  95 B4                sta     SHIFTSIGNEXT,x
001C01r 1  CA                   dex
001C02r 1  D0 F9                bne     L3A89
001C04r 1  86 BB                stx     FACEXTENSION
001C06r 1               RTS14:
001C06r 1  60                   rts
001C07r 1               
001C07r 1               ; =============================================================================
001C07r 1               ; ROUND FAC USING EXTENSION BYTE
001C07r 1               ; =============================================================================
001C07r 1               
001C07r 1               ROUND_FAC:
001C07r 1  A5 AE                lda     FAC
001C09r 1  F0 FB                beq     RTS14
001C0Br 1  06 BB                asl     FACEXTENSION
001C0Dr 1  90 F7                bcc     RTS14
001C0Fr 1               
001C0Fr 1               ; =============================================================================
001C0Fr 1               ; INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
001C0Fr 1               ; =============================================================================
001C0Fr 1               
001C0Fr 1               INCREMENT_MANTISSA:
001C0Fr 1  20 rr rr             jsr     INCREMENT_FAC_MANTISSA
001C12r 1  D0 F2                bne     RTS14
001C14r 1  4C rr rr             jmp     NORMALIZE_FAC6
001C17r 1               
001C17r 1               ; =============================================================================
001C17r 1               ; TEST FAC FOR ZERO AND SIGN
001C17r 1               ;
001C17r 1               ; FAC > 0, RETURN +1
001C17r 1               ; FAC = 0, RETURN  0
001C17r 1               ; FAC < 0, RETURN -1
001C17r 1               ; =============================================================================
001C17r 1               
001C17r 1               SIGN:
001C17r 1  A5 AE                lda     FAC
001C19r 1  F0 09                beq     RTS15
001C1Br 1               L3AA7:
001C1Br 1  A5 B2                lda     FACSIGN
001C1Dr 1               SIGN2:
001C1Dr 1  2A                   rol     a
001C1Er 1  A9 FF                lda     #$FF
001C20r 1  B0 02                bcs     RTS15
001C22r 1  A9 01                lda     #$01
001C24r 1               RTS15:
001C24r 1  60                   rts
001C25r 1               
001C25r 1               ; =============================================================================
001C25r 1               ; "SGN" FUNCTION
001C25r 1               ; =============================================================================
001C25r 1               
001C25r 1               SGN:
001C25r 1  20 rr rr             JSR     SIGN
001C28r 1               
001C28r 1               
001C28r 1               ; =============================================================================
001C28r 1               ; CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
001C28r 1               ; =============================================================================
001C28r 1               
001C28r 1               FLOAT:
001C28r 1  85 AF                sta     FAC+1
001C2Ar 1  A9 00                lda     #$00
001C2Cr 1  85 B0                sta     FAC+2
001C2Er 1  A2 88                ldx     #$88
001C30r 1               
001C30r 1               ; =============================================================================
001C30r 1               ; FLOAT UNSIGNED VALUE IN FAC+1,2
001C30r 1               ; (X) = EXPONENT
001C30r 1               ; =============================================================================
001C30r 1               
001C30r 1               FLOAT1:
001C30r 1  A5 AF                lda     FAC+1
001C32r 1  49 FF                eor     #$FF
001C34r 1  2A                   rol     a
001C35r 1               
001C35r 1               ; =============================================================================
001C35r 1               ; FLOAT UNSIGNED VALUE IN FAC+1,2
001C35r 1               ; (X) = EXPONENT
001C35r 1               ; C=0 TO MAKE VALUE NEGATIVE
001C35r 1               ; C=1 TO MAKE VALUE POSITIVE
001C35r 1               ; =============================================================================
001C35r 1               
001C35r 1               FLOAT2:
001C35r 1  A9 00                lda     #$00
001C37r 1  85 B1                sta     FAC+3
001C39r 1  86 AE                stx     FAC
001C3Br 1  85 BB                sta     FACEXTENSION
001C3Dr 1  85 B2                sta     FACSIGN
001C3Fr 1  4C rr rr             jmp     NORMALIZE_FAC1
001C42r 1               
001C42r 1               ; =============================================================================
001C42r 1               ; "ABS" FUNCTION
001C42r 1               ; =============================================================================
001C42r 1               
001C42r 1               ABS:
001C42r 1  46 B2                lsr     FACSIGN
001C44r 1  60                   rts
001C45r 1               
001C45r 1               ; =============================================================================
001C45r 1               ; SETCUR
001C45r 1               ; SJ Added Apr 2014.
001C45r 1               ; c_val contains the value to set to cursor to. 0 = off.
001C45r 1               ; =============================================================================
001C45r 1               
001C45r 1               SETCUR:
001C45r 1               
001C45r 1  A9 02        	LDA     #$02            		; Set cursor command.
001C47r 1  8D rr rr         STA		char_to_send
001C4Ar 1  20 rr rr         JSR     Send_Char_Screen
001C4Dr 1               
001C4Dr 1  AD rr rr         LDA		c_val					; Value from c_val.
001C50r 1  8D rr rr         STA		char_to_send
001C53r 1  20 rr rr         JSR     Send_Char_Screen
001C56r 1               
001C56r 1  A9 03            LDA     #$03            		; Set cursor to blink.
001C58r 1  8D rr rr         STA		char_to_send
001C5Br 1  20 rr rr         JSR     Send_Char_Screen
001C5Er 1               
001C5Er 1  60               RTS
001C5Fr 1               
001C5Fr 1               ; =============================================================================
001C5Fr 1               ; FONT
001C5Fr 1               ; SJ Added Apr 2014.
001C5Fr 1               ; c_val contains the value to set the font to.
001C5Fr 1               ; 40 Character normal = $00
001C5Fr 1               ; 80 Character normal = $01
001C5Fr 1               ; 40 Character bold = $02
001C5Fr 1               ; 80 Character bold = $03
001C5Fr 1               ; 40 Character normal double-height = $04
001C5Fr 1               ; 80 Character normal double-height = $05
001C5Fr 1               ; 40 Character bold double-height = $06
001C5Fr 1               ; 80 Character bold double-height = $07
001C5Fr 1               ; =============================================================================
001C5Fr 1               
001C5Fr 1               FONT:
001C5Fr 1  A9 18        	LDA     #$18            		; Set cursor command.
001C61r 1  8D rr rr         STA		char_to_send
001C64r 1  20 rr rr         JSR     Send_Char_Screen
001C67r 1               
001C67r 1  A9 07            LDA 	#$07					; If c_val <= $07 branch.
001C69r 1  CD rr rr         CMP 	c_val
001C6Cr 1  B0 05            BCS  	FONT_1
001C6Er 1  A9 03            LDA		#$03					; Else default to 80 column, bold.
001C70r 1  4C rr rr         JMP		FONT_2
001C73r 1               FONT_1:
001C73r 1  AD rr rr        	LDA		c_val					; Value from c_val.
001C76r 1               FONT_2:
001C76r 1  8D rr rr         STA		char_to_send
001C79r 1  20 rr rr         JSR     Send_Char_Screen
001C7Cr 1               
001C7Cr 1  60               RTS
001C7Dr 1               
001C7Dr 1               ; =============================================================================
001C7Dr 1               ; COMPARE FAC WITH PACKED # AT (Y,A)
001C7Dr 1               ; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
001C7Dr 1               ; =============================================================================
001C7Dr 1               
001C7Dr 1               FCOMP:
001C7Dr 1  85 75                sta     DEST
001C7Fr 1               
001C7Fr 1               ; =============================================================================
001C7Fr 1               ; SPECIAL ENTRY FROM "NEXT" PROCESSOR
001C7Fr 1               ; "DEST" ALREADY SET UP
001C7Fr 1               ; =============================================================================
001C7Fr 1               
001C7Fr 1               FCOMP2:
001C7Fr 1  84 76                sty     DEST+1
001C81r 1  A0 00                ldy     #$00
001C83r 1  B1 75                lda     (DEST),y
001C85r 1  C8                   iny
001C86r 1  AA                   tax
001C87r 1  F0 8E                beq     SIGN
001C89r 1  B1 75                lda     (DEST),y
001C8Br 1  45 B2                eor     FACSIGN
001C8Dr 1  30 8C                bmi     L3AA7
001C8Fr 1  E4 AE                cpx     FAC
001C91r 1  D0 1A                bne     L3B0A
001C93r 1  B1 75                lda     (DEST),y
001C95r 1  09 80                ora     #$80
001C97r 1  C5 AF                cmp     FAC+1
001C99r 1  D0 12                bne     L3B0A
001C9Br 1  C8                   iny
001C9Cr 1  B1 75                lda     (DEST),y
001C9Er 1  C5 B0                cmp     FAC+2
001CA0r 1  D0 0B                bne     L3B0A
001CA2r 1  C8                   iny
001CA3r 1  A9 7F                lda     #$7F
001CA5r 1  C5 BB                cmp     FACEXTENSION
001CA7r 1  B1 75                lda     (DEST),y
001CA9r 1  E5 B1                sbc     FAC_LAST
001CABr 1  F0 28                beq     L3B32
001CADr 1               L3B0A:
001CADr 1  A5 B2                lda     FACSIGN
001CAFr 1  90 02                bcc     L3B10
001CB1r 1  49 FF                eor     #$FF
001CB3r 1               L3B10:
001CB3r 1  4C rr rr             jmp     SIGN2
001CB6r 1               
001CB6r 1               ; =============================================================================
001CB6r 1               ; QUICK INTEGER FUNCTION
001CB6r 1               ;
001CB6r 1               ; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
001CB6r 1               ; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
001CB6r 1               ; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
001CB6r 1               ;
001CB6r 1               ; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
001CB6r 1               ; =============================================================================
001CB6r 1               
001CB6r 1               QINT:
001CB6r 1  A5 AE                lda     FAC
001CB8r 1  F0 4A                beq     QINT3
001CBAr 1  38                   sec
001CBBr 1  E9 98                sbc     #120+8*BYTES_FP
001CBDr 1  24 B2                bit     FACSIGN
001CBFr 1  10 09                bpl     L3B27
001CC1r 1  AA                   tax
001CC2r 1  A9 FF                lda     #$FF
001CC4r 1  85 B4                sta     SHIFTSIGNEXT
001CC6r 1  20 rr rr             jsr     COMPLEMENT_FAC_MANTISSA
001CC9r 1  8A                   txa
001CCAr 1               L3B27:
001CCAr 1  A2 AE                ldx     #FAC
001CCCr 1  C9 F9                cmp     #$F9
001CCEr 1  10 06                bpl     QINT2
001CD0r 1  20 rr rr             jsr     SHIFT_RIGHT
001CD3r 1  84 B4                sty     SHIFTSIGNEXT
001CD5r 1               L3B32:
001CD5r 1  60                   rts
001CD6r 1               QINT2:
001CD6r 1  A8                   tay
001CD7r 1  A5 B2                lda     FACSIGN
001CD9r 1  29 80                and     #$80
001CDBr 1  46 AF                lsr     FAC+1
001CDDr 1  05 AF                ora     FAC+1
001CDFr 1  85 AF                sta     FAC+1
001CE1r 1  20 rr rr             jsr     SHIFT_RIGHT4
001CE4r 1  84 B4                sty     SHIFTSIGNEXT
001CE6r 1  60                   rts
001CE7r 1               
001CE7r 1               ; =============================================================================
001CE7r 1               ; "INT" FUNCTION
001CE7r 1               ;
001CE7r 1               ; USES QINT TO CONVERT (FAC) TO INTEGER FORM,
001CE7r 1               ; AND THEN REFLOATS THE INTEGER.
001CE7r 1               ; =============================================================================
001CE7r 1               
001CE7r 1               INT:
001CE7r 1  A5 AE                lda     FAC
001CE9r 1  C9 98                cmp     #120+8*BYTES_FP
001CEBr 1  B0 1E                bcs     RTS17
001CEDr 1  20 rr rr             jsr     QINT
001CF0r 1  84 BB                sty     FACEXTENSION
001CF2r 1  A5 B2                lda     FACSIGN
001CF4r 1  84 B2                sty     FACSIGN
001CF6r 1  49 80                eor     #$80
001CF8r 1  2A                   rol     a
001CF9r 1  A9 98                lda     #120+8*BYTES_FP
001CFBr 1  85 AE                sta     FAC
001CFDr 1  A5 B1                lda     FAC_LAST
001CFFr 1  85 5B                sta     CHARAC
001D01r 1  4C rr rr             jmp     NORMALIZE_FAC1
001D04r 1               QINT3:
001D04r 1  85 AF                sta     FAC+1
001D06r 1  85 B0                sta     FAC+2
001D08r 1  85 B1                sta     FAC+3
001D0Ar 1  A8                   tay
001D0Br 1               RTS17:
001D0Br 1  60                   rts
001D0Cr 1               
001D0Cr 1               ; =============================================================================
001D0Cr 1               ; CONVERT STRING TO FP VALUE IN FAC
001D0Cr 1               ;
001D0Cr 1               ; STRING POINTED TO BY TXTPTR
001D0Cr 1               ; FIRST CHAR ALREADY SCANNED BY CHRGET
001D0Cr 1               ; (A) = FIRST CHAR, C=0 IF DIGIT.
001D0Cr 1               ; =============================================================================
001D0Cr 1               
001D0Cr 1               FIN:
001D0Cr 1  A0 00                ldy     #$00
001D0Er 1  A2 09                ldx     #SERLEN-TMPEXP
001D10r 1               L3B6F:
001D10r 1  94 AA                sty     TMPEXP,x
001D12r 1  CA                   dex
001D13r 1  10 FB                bpl     L3B6F
001D15r 1  90 0F                bcc     FIN2
001D17r 1  C9 2D                cmp     #$2D
001D19r 1  D0 04                bne     L3B7E
001D1Br 1  86 B3                stx     SERLEN
001D1Dr 1  F0 04                beq     FIN1
001D1Fr 1               L3B7E:
001D1Fr 1  C9 2B                cmp     #$2B
001D21r 1  D0 05                bne     FIN3
001D23r 1               FIN1:
001D23r 1  20 C8 00             jsr     CHRGET
001D26r 1               FIN2:
001D26r 1  90 5B                bcc     FIN9
001D28r 1               FIN3:
001D28r 1  C9 2E                cmp     #$2E
001D2Ar 1  F0 2E                beq     FIN10
001D2Cr 1  C9 45                cmp     #$45
001D2Er 1  D0 30                bne     FIN7
001D30r 1  20 C8 00             jsr     CHRGET
001D33r 1  90 17                bcc     FIN5
001D35r 1  C9 AF                cmp     #TOKEN_MINUS
001D37r 1  F0 0E                beq     L3BA6
001D39r 1  C9 2D                cmp     #$2D
001D3Br 1  F0 0A                beq     L3BA6
001D3Dr 1  C9 AE                cmp     #TOKEN_PLUS
001D3Fr 1  F0 08                beq     FIN4
001D41r 1  C9 2B                cmp     #$2B
001D43r 1  F0 04                beq     FIN4
001D45r 1  D0 07                bne     FIN6
001D47r 1               L3BA6:
001D47r 1  66 AD                ror     EXPSGN
001D49r 1               FIN4:
001D49r 1  20 C8 00             jsr     CHRGET
001D4Cr 1               FIN5:
001D4Cr 1  90 5C                bcc     GETEXP
001D4Er 1               FIN6:
001D4Er 1  24 AD                bit     EXPSGN
001D50r 1  10 0E                bpl     FIN7
001D52r 1  A9 00                lda     #$00
001D54r 1  38                   sec
001D55r 1  E5 AB                sbc     EXPON
001D57r 1  4C rr rr             jmp     FIN8
001D5Ar 1               
001D5Ar 1               ; =============================================================================
001D5Ar 1               ; FOUND A DECIMAL POINT
001D5Ar 1               ; =============================================================================
001D5Ar 1               
001D5Ar 1               FIN10:
001D5Ar 1  66 AC                ror     LOWTR
001D5Cr 1  24 AC                bit     LOWTR
001D5Er 1  50 C3                bvc     FIN1
001D60r 1               
001D60r 1               ; =============================================================================
001D60r 1               ; NUMBER TERMINATED, ADJUST EXPONENT NOW
001D60r 1               ; =============================================================================
001D60r 1               
001D60r 1               FIN7:
001D60r 1  A5 AB                lda     EXPON
001D62r 1               FIN8:
001D62r 1  38                   sec
001D63r 1  E5 AA                sbc     INDX
001D65r 1  85 AB                sta     EXPON
001D67r 1  F0 12                beq     L3BEE
001D69r 1  10 09                bpl     L3BE7
001D6Br 1               L3BDE:
001D6Br 1  20 rr rr             jsr     DIV10
001D6Er 1  E6 AB                inc     EXPON
001D70r 1  D0 F9                bne     L3BDE
001D72r 1  F0 07                beq     L3BEE
001D74r 1               L3BE7:
001D74r 1  20 rr rr             jsr     MUL10
001D77r 1  C6 AB                dec     EXPON
001D79r 1  D0 F9                bne     L3BE7
001D7Br 1               L3BEE:
001D7Br 1  A5 B3                lda     SERLEN
001D7Dr 1  30 01                bmi     L3BF3
001D7Fr 1  60                   rts
001D80r 1               L3BF3:
001D80r 1  4C rr rr             jmp     NEGOP
001D83r 1               
001D83r 1               ; =============================================================================
001D83r 1               ; ACCUMULATE A DIGIT INTO FAC
001D83r 1               ; =============================================================================
001D83r 1               
001D83r 1               FIN9:
001D83r 1  48                   pha
001D84r 1  24 AC                bit     LOWTR
001D86r 1  10 02                bpl     L3BFD
001D88r 1  E6 AA                inc     INDX
001D8Ar 1               L3BFD:
001D8Ar 1  20 rr rr             jsr     MUL10
001D8Dr 1  68                   pla
001D8Er 1  38                   sec
001D8Fr 1  E9 30                sbc     #$30
001D91r 1  20 rr rr             jsr     ADDACC
001D94r 1  4C rr rr             jmp     FIN1
001D97r 1               
001D97r 1               ; =============================================================================
001D97r 1               ; ADD (A) TO FAC
001D97r 1               ; =============================================================================
001D97r 1               
001D97r 1               ADDACC:
001D97r 1  48                   pha
001D98r 1  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001D9Br 1  68                   pla
001D9Cr 1  20 rr rr             jsr     FLOAT
001D9Fr 1  A5 B9                lda     ARGSIGN
001DA1r 1  45 B2                eor     FACSIGN
001DA3r 1  85 BA                sta     SGNCPR
001DA5r 1  A6 AE                ldx     FAC
001DA7r 1  4C rr rr             jmp     FADDT
001DAAr 1               
001DAAr 1               ; =============================================================================
001DAAr 1               ; ACCUMULATE DIGIT OF EXPONENT
001DAAr 1               ; =============================================================================
001DAAr 1               
001DAAr 1               GETEXP:
001DAAr 1  A5 AB                lda     EXPON
001DACr 1  C9 0A                cmp     #MAX_EXPON
001DAEr 1  90 09                bcc     L3C2C
001DB0r 1  A9 64                lda     #$64
001DB2r 1  24 AD                bit     EXPSGN
001DB4r 1  30 11                bmi     L3C3A
001DB6r 1  4C rr rr             jmp     OVERFLOW
001DB9r 1               L3C2C:
001DB9r 1  0A                   asl     a
001DBAr 1  0A                   asl     a
001DBBr 1  18                   clc
001DBCr 1  65 AB                adc     EXPON
001DBEr 1  0A                   asl     a
001DBFr 1  18                   clc
001DC0r 1  A0 00                ldy     #$00
001DC2r 1  71 CF                adc     (TXTPTR),y
001DC4r 1  38                   sec
001DC5r 1  E9 30                sbc     #$30
001DC7r 1               L3C3A:
001DC7r 1  85 AB                sta     EXPON
001DC9r 1  4C rr rr             jmp     FIN4
001DCCr 1               
001DCCr 1               ; =============================================================================
001DCCr 1               ; these values are /1000 of what the labels say
001DCCr 1               CON_99999999_9:
001DCCr 1  91 43 4F F8          .byte   $91,$43,$4F,$F8
001DD0r 1               CON_999999999:
001DD0r 1  94 74 23 F7          .byte   $94,$74,$23,$F7
001DD4r 1               CON_BILLION:
001DD4r 1  94 74 24 00          .byte   $94,$74,$24,$00
001DD8r 1               
001DD8r 1               ; =============================================================================
001DD8r 1               ; PRINT "IN <LINE #>"
001DD8r 1               ; =============================================================================
001DD8r 1               
001DD8r 1               INPRT:
001DD8r 1  A9 rr                lda     #<QT_IN
001DDAr 1  A0 rr                ldy     #>QT_IN
001DDCr 1  20 rr rr             jsr     GOSTROUT2
001DDFr 1  A5 8A                lda     CURLIN+1
001DE1r 1  A6 89                ldx     CURLIN
001DE3r 1               
001DE3r 1               ; =============================================================================
001DE3r 1               ; PRINT A,X AS DECIMAL INTEGER
001DE3r 1               ; =============================================================================
001DE3r 1               
001DE3r 1               LINPRT:
001DE3r 1  85 AF                sta     FAC+1
001DE5r 1  86 B0                stx     FAC+2
001DE7r 1  A2 90                ldx     #$90
001DE9r 1  38                   sec
001DEAr 1  20 rr rr             jsr     FLOAT2
001DEDr 1  20 rr rr             jsr     FOUT
001DF0r 1               GOSTROUT2:
001DF0r 1  4C rr rr             jmp     STROUT
001DF3r 1               
001DF3r 1               ; =============================================================================
001DF3r 1               ; CONVERT (FAC) TO STRING STARTING AT STACK
001DF3r 1               ; RETURN WITH (Y,A) POINTING AT STRING
001DF3r 1               ; =============================================================================
001DF3r 1               
001DF3r 1               FOUT:
001DF3r 1  A0 01                ldy     #$01
001DF5r 1               
001DF5r 1               ; =============================================================================
001DF5r 1               ; "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
001DF5r 1               ; SO THAT RESULT STRING STARTS AT STACK-1
001DF5r 1               ; (THIS IS USED AS A FLAG)
001DF5r 1               ; =============================================================================
001DF5r 1               
001DF5r 1               FOUT1:
001DF5r 1  A9 20                lda     #$20
001DF7r 1  24 B2                bit     FACSIGN
001DF9r 1  10 02                bpl     L3C73
001DFBr 1  A9 2D                lda     #$2D
001DFDr 1               L3C73:
001DFDr 1  99 FF 00             sta     $FF,y
001E00r 1  85 B2                sta     FACSIGN
001E02r 1  84 BC                sty     STRNG2
001E04r 1  C8                   iny
001E05r 1  A9 30                lda     #$30
001E07r 1  A6 AE                ldx     FAC
001E09r 1  D0 03                bne     L3C84
001E0Br 1  4C rr rr             jmp     FOUT4
001E0Er 1               L3C84:
001E0Er 1  A9 00                lda     #$00
001E10r 1  E0 80                cpx     #$80
001E12r 1  F0 02                beq     L3C8C
001E14r 1  B0 09                bcs     L3C95
001E16r 1               L3C8C:
001E16r 1  A9 rr                lda     #<CON_BILLION
001E18r 1  A0 rr                ldy     #>CON_BILLION
001E1Ar 1  20 rr rr             jsr     FMULT
001E1Dr 1  A9 FA                lda     #-6 ; exponent adjustment
001E1Fr 1               L3C95:
001E1Fr 1  85 AA                sta     INDX
001E21r 1               
001E21r 1               ; =============================================================================
001E21r 1               ; ADJUST UNTIL 1E8 <= (FAC) <1E9
001E21r 1               ; =============================================================================
001E21r 1               
001E21r 1               L3C97:
001E21r 1  A9 rr                lda     #<CON_999999999
001E23r 1  A0 rr                ldy     #>CON_999999999
001E25r 1  20 rr rr             jsr     FCOMP
001E28r 1  F0 1E                beq     L3CBE
001E2Ar 1  10 12                bpl     L3CB4
001E2Cr 1               L3CA2:
001E2Cr 1  A9 rr                lda     #<CON_99999999_9
001E2Er 1  A0 rr                ldy     #>CON_99999999_9
001E30r 1  20 rr rr             jsr     FCOMP
001E33r 1  F0 02                beq     L3CAD
001E35r 1  10 0E                bpl     L3CBB
001E37r 1               L3CAD:
001E37r 1  20 rr rr             jsr     MUL10
001E3Ar 1  C6 AA                dec     INDX
001E3Cr 1  D0 EE                bne     L3CA2
001E3Er 1               L3CB4:
001E3Er 1  20 rr rr             jsr     DIV10
001E41r 1  E6 AA                inc     INDX
001E43r 1  D0 DC                bne     L3C97
001E45r 1               L3CBB:
001E45r 1  20 rr rr             jsr     FADDH
001E48r 1               L3CBE:
001E48r 1  20 rr rr             jsr     QINT
001E4Br 1               
001E4Br 1               ; =============================================================================
001E4Br 1               ; FAC+1...FAC+4 IS NOW IN INTEGER FORM
001E4Br 1               ; WITH POWER OF TEN ADJUSTMENT IN TMPEXP
001E4Br 1               ;
001E4Br 1               ; IF -10 < TMPEXP > 1, PRINT IN DECIMAL FORM
001E4Br 1               ; OTHERWISE, PRINT IN EXPONENTIAL FORM
001E4Br 1               ; =============================================================================
001E4Br 1               
001E4Br 1  A2 01                ldx     #$01
001E4Dr 1  A5 AA                lda     INDX
001E4Fr 1  18                   clc
001E50r 1  69 07                adc     #3*BYTES_FP-5
001E52r 1  30 09                bmi     L3CD3
001E54r 1  C9 08                cmp     #3*BYTES_FP-4
001E56r 1  B0 06                bcs     L3CD4
001E58r 1  69 FF                adc     #$FF
001E5Ar 1  AA                   tax
001E5Br 1  A9 02                lda     #$02
001E5Dr 1               L3CD3:
001E5Dr 1  38                   sec
001E5Er 1               L3CD4:
001E5Er 1  E9 02                sbc     #$02
001E60r 1  85 AB                sta     EXPON
001E62r 1  86 AA                stx     INDX
001E64r 1  8A                   txa
001E65r 1  F0 02                beq     L3CDF
001E67r 1  10 13                bpl     L3CF2
001E69r 1               L3CDF:
001E69r 1  A4 BC                ldy     STRNG2
001E6Br 1  A9 2E                lda     #$2E
001E6Dr 1  C8                   iny
001E6Er 1  99 FF 00             sta     $FF,y
001E71r 1  8A                   txa
001E72r 1  F0 06                beq     L3CF0
001E74r 1  A9 30                lda     #$30
001E76r 1  C8                   iny
001E77r 1  99 FF 00             sta     $FF,y
001E7Ar 1               L3CF0:
001E7Ar 1  84 BC                sty     STRNG2
001E7Cr 1               
001E7Cr 1               ; =============================================================================
001E7Cr 1               ; NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
001E7Cr 1               ; =============================================================================
001E7Cr 1               
001E7Cr 1               L3CF2:
001E7Cr 1  A0 00                ldy     #$00
001E7Er 1  A2 80                ldx     #$80
001E80r 1               L3CF6:
001E80r 1  A5 B1                lda     FAC_LAST
001E82r 1  18                   clc
001E83r 1  79 rr rr             adc     DECTBL+2,y
001E86r 1  85 B1                sta     FAC+3
001E88r 1  A5 B0                lda     FAC+2
001E8Ar 1  79 rr rr             adc     DECTBL+1,y
001E8Dr 1  85 B0                sta     FAC+2
001E8Fr 1  A5 AF                lda     FAC+1
001E91r 1  79 rr rr             adc     DECTBL,y
001E94r 1  85 AF                sta     FAC+1
001E96r 1  E8                   inx
001E97r 1  B0 04                bcs     L3D1A
001E99r 1  10 E5                bpl     L3CF6
001E9Br 1  30 02                bmi     L3D1C
001E9Dr 1               L3D1A:
001E9Dr 1  30 E1                bmi     L3CF6
001E9Fr 1               L3D1C:
001E9Fr 1  8A                   txa
001EA0r 1  90 04                bcc     L3D23
001EA2r 1  49 FF                eor     #$FF
001EA4r 1  69 0A                adc     #$0A
001EA6r 1               L3D23:
001EA6r 1  69 2F                adc     #$2F
001EA8r 1  C8                   iny
001EA9r 1  C8                   iny
001EAAr 1  C8                   iny
001EABr 1  84 97                sty     VARPNT
001EADr 1  A4 BC                ldy     STRNG2
001EAFr 1  C8                   iny
001EB0r 1  AA                   tax
001EB1r 1  29 7F                and     #$7F
001EB3r 1  99 FF 00             sta     $FF,y
001EB6r 1  C6 AA                dec     INDX
001EB8r 1  D0 06                bne     L3D3E
001EBAr 1  A9 2E                lda     #$2E
001EBCr 1  C8                   iny
001EBDr 1  99 FF 00             sta     $FF,y
001EC0r 1               L3D3E:
001EC0r 1  84 BC                sty     STRNG2
001EC2r 1  A4 97                ldy     VARPNT
001EC4r 1  8A                   txa
001EC5r 1  49 FF                eor     #$FF
001EC7r 1  29 80                and     #$80
001EC9r 1  AA                   tax
001ECAr 1  C0 12                cpy     #DECTBL_END-DECTBL
001ECCr 1  D0 B2                bne     L3CF6
001ECEr 1               
001ECEr 1               ; =============================================================================
001ECEr 1               ; NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
001ECEr 1               ; BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
001ECEr 1               ; DECIMAL POINT.
001ECEr 1               ; =============================================================================
001ECEr 1               
001ECEr 1  A4 BC                ldy     STRNG2
001ED0r 1               L3D4E:
001ED0r 1  B9 FF 00             lda     $FF,y
001ED3r 1  88                   dey
001ED4r 1  C9 30                cmp     #$30
001ED6r 1  F0 F8                beq     L3D4E
001ED8r 1  C9 2E                cmp     #$2E
001EDAr 1  F0 01                beq     L3D5B
001EDCr 1  C8                   iny
001EDDr 1               L3D5B:
001EDDr 1  A9 2B                lda     #$2B
001EDFr 1  A6 AB                ldx     EXPON
001EE1r 1  F0 2E                beq     L3D8F
001EE3r 1  10 08                bpl     L3D6B
001EE5r 1  A9 00                lda     #$00
001EE7r 1  38                   sec
001EE8r 1  E5 AB                sbc     EXPON
001EEAr 1  AA                   tax
001EEBr 1  A9 2D                lda     #$2D
001EEDr 1               L3D6B:
001EEDr 1  99 01 01             sta     STACK+1,y
001EF0r 1  A9 45                lda     #$45
001EF2r 1  99 00 01             sta     STACK,y
001EF5r 1  8A                   txa
001EF6r 1  A2 2F                ldx     #$2F
001EF8r 1  38                   sec
001EF9r 1               L3D77:
001EF9r 1  E8                   inx
001EFAr 1  E9 0A                sbc     #$0A
001EFCr 1  B0 FB                bcs     L3D77
001EFEr 1  69 3A                adc     #$3A
001F00r 1  99 03 01             sta     STACK+3,y
001F03r 1  8A                   txa
001F04r 1  99 02 01             sta     STACK+2,y
001F07r 1  A9 00                lda     #$00
001F09r 1  99 04 01             sta     STACK+4,y
001F0Cr 1  F0 08                beq     L3D94
001F0Er 1               FOUT4:
001F0Er 1  99 FF 00             sta     $FF,y
001F11r 1               L3D8F:
001F11r 1  A9 00                lda     #$00
001F13r 1  99 00 01             sta     STACK,y
001F16r 1               L3D94:
001F16r 1  A9 00                lda     #$00
001F18r 1  A0 01                ldy     #$01
001F1Ar 1  60                   rts
001F1Br 1               
001F1Br 1               ; =============================================================================
001F1Br 1               CON_HALF:
001F1Br 1  80 00 00 00          .byte   $80,$00,$00,$00
001F1Fr 1               
001F1Fr 1               ; =============================================================================
001F1Fr 1               ; POWERS OF 10 FROM 1E8 DOWN TO 1,
001F1Fr 1               ; AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
001F1Fr 1               ; =============================================================================
001F1Fr 1               
001F1Fr 1               DECTBL:
001F1Fr 1  FE 79 60             .byte   $FE,$79,$60 ; -100000
001F22r 1  00 27 10             .byte    $00,$27,$10 ; 10000
001F25r 1  FF FC 18             .byte    $FF,$FC,$18 ; -1000
001F28r 1  00 00 64             .byte    $00,$00,$64 ; 100
001F2Br 1  FF FF F6             .byte    $FF,$FF,$F6 ; -10
001F2Er 1  00 00 01             .byte    $00,$00,$01 ; 1
001F31r 1               DECTBL_END:
001F31r 1               
001F31r 1               ; =============================================================================
001F31r 1               ; "SQR" FUNCTION
001F31r 1               ; =============================================================================
001F31r 1               
001F31r 1               SQR:
001F31r 1  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001F34r 1  A9 rr                lda     #<CON_HALF
001F36r 1  A0 rr                ldy     #>CON_HALF
001F38r 1  20 rr rr             jsr     LOAD_FAC_FROM_YA
001F3Br 1               
001F3Br 1               ; =============================================================================
001F3Br 1               ; EXPONENTIATION OPERATION
001F3Br 1               ;
001F3Br 1               ; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
001F3Br 1               ; =============================================================================
001F3Br 1               
001F3Br 1               FPWRT:
001F3Br 1  F0 63                beq     EXP
001F3Dr 1  A5 B5                lda     ARG
001F3Fr 1  D0 03                bne     L3DD5
001F41r 1  4C rr rr             jmp     STA_IN_FAC_SIGN_AND_EXP
001F44r 1               L3DD5:
001F44r 1  A2 9E                ldx     #TEMP3
001F46r 1  A0 00                ldy     #$00
001F48r 1  20 rr rr             jsr     STORE_FAC_AT_YX_ROUNDED
001F4Br 1  A5 B9                lda     ARGSIGN
001F4Dr 1  10 0F                bpl     L3DEF
001F4Fr 1  20 rr rr             jsr     INT
001F52r 1  A9 9E                lda     #TEMP3
001F54r 1  A0 00                ldy     #$00
001F56r 1  20 rr rr             jsr     FCOMP
001F59r 1  D0 03                bne     L3DEF
001F5Br 1  98                   tya
001F5Cr 1  A4 5B                ldy     CHARAC
001F5Er 1               L3DEF:
001F5Er 1  20 rr rr             jsr     MFA
001F61r 1  98                   tya
001F62r 1  48                   pha
001F63r 1  20 rr rr             jsr     LOG
001F66r 1  A9 9E                lda     #TEMP3
001F68r 1  A0 00                ldy     #$00
001F6Ar 1  20 rr rr             jsr     FMULT
001F6Dr 1  20 rr rr             jsr     EXP
001F70r 1  68                   pla
001F71r 1  4A                   lsr     a
001F72r 1  90 0A                bcc     L3E0F
001F74r 1               
001F74r 1               ; =============================================================================
001F74r 1               ; NEGATE VALUE IN FAC
001F74r 1               ; =============================================================================
001F74r 1               
001F74r 1               NEGOP:
001F74r 1  A5 AE                lda     FAC
001F76r 1  F0 06                beq     L3E0F
001F78r 1  A5 B2                lda     FACSIGN
001F7Ar 1  49 FF                eor     #$FF
001F7Cr 1  85 B2                sta     FACSIGN
001F7Er 1               L3E0F:
001F7Er 1  60                   rts
001F7Fr 1               
001F7Fr 1               ; =============================================================================
001F7Fr 1               
001F7Fr 1               CON_LOG_E:
001F7Fr 1  81 38 AA 3B          .byte   $81,$38,$AA,$3B
001F83r 1               POLY_EXP:
001F83r 1  06                   .byte    $06
001F84r 1  74 63 90 8C          .byte    $74,$63,$90,$8C
001F88r 1  77 23 0C AB          .byte    $77,$23,$0C,$AB
001F8Cr 1  7A 1E 94 00          .byte    $7A,$1E,$94,$00
001F90r 1  7C 63 42 80          .byte    $7C,$63,$42,$80
001F94r 1  7E 75 FE D0          .byte    $7E,$75,$FE,$D0
001F98r 1  80 31 72 15          .byte    $80,$31,$72,$15
001F9Cr 1  81 00 00 00          .byte    $81,$00,$00,$00
001FA0r 1               
001FA0r 1               ; =============================================================================
001FA0r 1               ; "EXP" FUNCTION
001FA0r 1               ;
001FA0r 1               ; FAC = E ^ FAC
001FA0r 1               ; =============================================================================
001FA0r 1               
001FA0r 1               EXP:
001FA0r 1  A9 rr                lda     #<CON_LOG_E
001FA2r 1  A0 rr                ldy     #>CON_LOG_E
001FA4r 1  20 rr rr             jsr     FMULT
001FA7r 1  A5 BB                lda     FACEXTENSION
001FA9r 1  69 50                adc     #$50
001FABr 1  90 03                bcc     L3E4E
001FADr 1  20 rr rr             jsr     INCREMENT_MANTISSA
001FB0r 1               L3E4E:
001FB0r 1  85 A5                sta     ARGEXTENSION
001FB2r 1  20 rr rr             jsr     MAF
001FB5r 1  A5 AE                lda     FAC
001FB7r 1  C9 88                cmp     #$88
001FB9r 1  90 03                bcc     L3E5C
001FBBr 1               L3E59:
001FBBr 1  20 rr rr             jsr     OUTOFRNG
001FBEr 1               L3E5C:
001FBEr 1  20 rr rr             jsr     INT
001FC1r 1  A5 5B                lda     CHARAC
001FC3r 1  18                   clc
001FC4r 1  69 81                adc     #$81
001FC6r 1  F0 F3                beq     L3E59
001FC8r 1  38                   sec
001FC9r 1  E9 01                sbc     #$01
001FCBr 1  48                   pha
001FCCr 1  A2 04                ldx     #BYTES_FP
001FCEr 1               L3E6C:
001FCEr 1  B5 B5                lda     ARG,x
001FD0r 1  B4 AE                ldy     FAC,x
001FD2r 1  95 AE                sta     FAC,x
001FD4r 1  94 B5                sty     ARG,x
001FD6r 1  CA                   dex
001FD7r 1  10 F5                bpl     L3E6C
001FD9r 1  A5 A5                lda     ARGEXTENSION
001FDBr 1  85 BB                sta     FACEXTENSION
001FDDr 1  20 rr rr             jsr     FSUBT
001FE0r 1  20 rr rr             jsr     NEGOP
001FE3r 1  A9 rr                lda     #<POLY_EXP
001FE5r 1  A0 rr                ldy     #>POLY_EXP
001FE7r 1  20 rr rr             jsr     POLYNOMIAL
001FEAr 1  A9 00                lda     #$00
001FECr 1  85 BA                sta     SGNCPR
001FEEr 1  68                   pla
001FEFr 1  20 rr rr             jsr     ADD_EXPONENTS1
001FF2r 1  60                   rts
001FF3r 1               
001FF3r 1               ; =============================================================================
001FF3r 1               ; ODD POLYNOMIAL SUBROUTINE
001FF3r 1               ;
001FF3r 1               ; F(X) = X * P(X^2)
001FF3r 1               ;
001FF3r 1               ; WHERE:  X IS VALUE IN FAC
001FF3r 1               ;    Y,A POINTS AT COEFFICIENT TABLE
001FF3r 1               ;    FIRST BYTE OF COEFF. TABLE IS N
001FF3r 1               ;    COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
001FF3r 1               ;
001FF3r 1               ; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
001FF3r 1               ; =============================================================================
001FF3r 1               
001FF3r 1               POLYNOMIAL_ODD:
001FF3r 1  85 BC                sta     STRNG2
001FF5r 1  84 BD                sty     STRNG2+1
001FF7r 1  20 rr rr             jsr     STORE_FAC_IN_TEMP1_ROUNDED
001FFAr 1  A9 A6                lda     #TEMP1X
001FFCr 1  20 rr rr             jsr     FMULT
001FFFr 1  20 rr rr             jsr     SERMAIN
002002r 1  A9 A6                lda     #TEMP1X
002004r 1  A0 00                ldy     #$00
002006r 1  4C rr rr             jmp     FMULT
002009r 1               
002009r 1               ; =============================================================================
002009r 1               ; NORMAL POLYNOMIAL SUBROUTINE
002009r 1               ;
002009r 1               ; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
002009r 1               ;
002009r 1               ; WHERE:  X IS VALUE IN FAC
002009r 1               ;    Y,A POINTS AT COEFFICIENT TABLE
002009r 1               ;    FIRST BYTE OF COEFF. TABLE IS N
002009r 1               ;    COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
002009r 1               ; =============================================================================
002009r 1               
002009r 1               POLYNOMIAL:
002009r 1  85 BC                sta     STRNG2
00200Br 1  84 BD                sty     STRNG2+1
00200Dr 1               SERMAIN:
00200Dr 1  20 rr rr             jsr     STORE_FAC_IN_TEMP2_ROUNDED
002010r 1  B1 BC                lda     (STRNG2),y
002012r 1  85 B3                sta     SERLEN
002014r 1  A4 BC                ldy     STRNG2
002016r 1  C8                   iny
002017r 1  98                   tya
002018r 1  D0 02                bne     L3EBA
00201Ar 1  E6 BD                inc     STRNG2+1
00201Cr 1               L3EBA:
00201Cr 1  85 BC                sta     STRNG2
00201Er 1  A4 BD                ldy     STRNG2+1
002020r 1               L3EBE:
002020r 1  20 rr rr             jsr     FMULT
002023r 1  A5 BC                lda     STRNG2
002025r 1  A4 BD                ldy     STRNG2+1
002027r 1  18                   clc
002028r 1  69 04                adc     #BYTES_FP
00202Ar 1  90 01                bcc     L3ECB
00202Cr 1  C8                   iny
00202Dr 1               L3ECB:
00202Dr 1  85 BC                sta     STRNG2
00202Fr 1  84 BD                sty     STRNG2+1
002031r 1  20 rr rr             jsr     FADD
002034r 1  A9 AA                lda     #TEMP2
002036r 1  A0 00                ldy     #$00
002038r 1  C6 B3                dec     SERLEN
00203Ar 1  D0 E4                bne     L3EBE
00203Cr 1               RTS19:
00203Cr 1  60                   rts
00203Dr 1               
00203Dr 1               ; =============================================================================
00203Dr 1               ; "RND" FUNCTION
00203Dr 1               ; =============================================================================
00203Dr 1               
00203Dr 1               CONRND1:
00203Dr 1  98 35 44 7A          .byte   $98,$35,$44,$7A
002041r 1               CONRND2:
002041r 1  68 28 B1 46          .byte   $68,$28,$B1,$46
002045r 1               RND:
002045r 1  20 rr rr             jsr     SIGN
002048r 1  AA                   tax
002049r 1  30 18                bmi     L3F01
00204Br 1  A9 E0                lda     #<RNDSEED
00204Dr 1  A0 00                ldy     #>RNDSEED
00204Fr 1  20 rr rr             jsr     LOAD_FAC_FROM_YA
002052r 1  8A                   txa
002053r 1  F0 E7                beq     RTS19
002055r 1  A9 rr                lda     #<CONRND1
002057r 1  A0 rr                ldy     #>CONRND1
002059r 1  20 rr rr             jsr     FMULT
00205Cr 1  A9 rr                lda     #<CONRND2
00205Er 1  A0 rr                ldy     #>CONRND2
002060r 1  20 rr rr             jsr     FADD
002063r 1               L3F01:
002063r 1  A6 B1                ldx     FAC_LAST
002065r 1  A5 AF                lda     FAC+1
002067r 1  85 B1                sta     FAC_LAST
002069r 1  86 AF                stx     FAC+1
00206Br 1  A9 00                lda     #$00
00206Dr 1  85 B2                sta     FACSIGN
00206Fr 1  A5 AE                lda     FAC
002071r 1  85 BB                sta     FACEXTENSION
002073r 1  A9 80                lda     #$80
002075r 1  85 AE                sta     FAC
002077r 1  20 rr rr             jsr     NORMALIZE_FAC2
00207Ar 1  A2 E0                ldx     #<RNDSEED
00207Cr 1  A0 00                ldy     #>RNDSEED
00207Er 1               GOMOVMF:
00207Er 1  4C rr rr             jmp     STORE_FAC_AT_YX_ROUNDED
002081r 1               
002081r 1               ; =============================================================================
002081r 1               ; "COS" FUNCTION
002081r 1               ; =============================================================================
002081r 1               
002081r 1               COS:
002081r 1  A9 rr                lda     #<CON_PI_HALF
002083r 1  A0 rr                ldy     #>CON_PI_HALF
002085r 1  20 rr rr             jsr     FADD
002088r 1               
002088r 1               ; =============================================================================
002088r 1               ; "SIN" FUNCTION
002088r 1               ; =============================================================================
002088r 1               
002088r 1               SIN:
002088r 1  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
00208Br 1  A9 rr                lda     #<CON_PI_DOUB
00208Dr 1  A0 rr                ldy     #>CON_PI_DOUB
00208Fr 1  A6 B9                ldx     ARGSIGN
002091r 1  20 rr rr             jsr     DIV
002094r 1  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
002097r 1  20 rr rr             jsr     INT
00209Ar 1  A9 00                lda     #$00
00209Cr 1  85 BA                sta     STRNG1
00209Er 1  20 rr rr             jsr     FSUBT
0020A1r 1               
0020A1r 1               ; =============================================================================
0020A1r 1               ; (FAC) = ANGLE AS A FRACTION OF A FULL CIRCLE
0020A1r 1               ;
0020A1r 1               ; NOW FOLD THE RANGE INTO A QUARTER CIRCLE
0020A1r 1               ;
0020A1r 1               ; <<< THERE ARE MUCH SIMPLER WAYS TO DO THIS >>>
0020A1r 1               ; =============================================================================
0020A1r 1               
0020A1r 1  A9 rr                lda     #<QUARTER
0020A3r 1  A0 rr                ldy     #>QUARTER
0020A5r 1  20 rr rr             jsr     FSUB
0020A8r 1  A5 B2                lda     FACSIGN
0020AAr 1  48                   pha
0020ABr 1  10 0D                bpl     SIN1
0020ADr 1  20 rr rr             jsr     FADDH
0020B0r 1  A5 B2                lda     FACSIGN
0020B2r 1  30 09                bmi     L3F5B
0020B4r 1  A5 63                lda     CPRMASK
0020B6r 1  49 FF                eor     #$FF
0020B8r 1  85 63                sta     CPRMASK
0020BAr 1               
0020BAr 1               ; =============================================================================
0020BAr 1               ; IF FALL THRU, RANGE IS 0...1/2
0020BAr 1               ; IF BRANCH HERE, RANGE IS 0...1/4
0020BAr 1               ; =============================================================================
0020BAr 1               
0020BAr 1               SIN1:
0020BAr 1  20 rr rr             jsr     NEGOP
0020BDr 1               
0020BDr 1               ; =============================================================================
0020BDr 1               ; IF FALL THRU, RANGE IS -1/2...0
0020BDr 1               ; IF BRANCH HERE, RANGE IS -1/4...0
0020BDr 1               ; =============================================================================
0020BDr 1               
0020BDr 1               L3F5B:
0020BDr 1  A9 rr                lda     #<QUARTER
0020BFr 1  A0 rr                ldy     #>QUARTER
0020C1r 1  20 rr rr             jsr     FADD
0020C4r 1  68                   pla
0020C5r 1  10 03                bpl     L3F68
0020C7r 1  20 rr rr             jsr     NEGOP
0020CAr 1               L3F68:
0020CAr 1  A9 rr                lda     #<POLY_SIN
0020CCr 1  A0 rr                ldy     #>POLY_SIN
0020CEr 1  4C rr rr             jmp     POLYNOMIAL_ODD
0020D1r 1               
0020D1r 1               ; =============================================================================
0020D1r 1               ; "TAN" FUNCTION
0020D1r 1               ;
0020D1r 1               ; COMPUTE TAN(X) = SIN(X) / COS(X)
0020D1r 1               ; =============================================================================
0020D1r 1               
0020D1r 1               TAN:
0020D1r 1  20 rr rr             jsr     STORE_FAC_IN_TEMP1_ROUNDED
0020D4r 1  A9 00                lda     #$00
0020D6r 1  85 63                sta     CPRMASK
0020D8r 1  20 rr rr             jsr     SIN
0020DBr 1  A2 9E                ldx     #TEMP3
0020DDr 1  A0 00                ldy     #$00
0020DFr 1  20 rr rr             jsr     GOMOVMF
0020E2r 1  A9 A6                lda     #TEMP1+(5-BYTES_FP)
0020E4r 1  A0 00                ldy     #$00
0020E6r 1  20 rr rr             jsr     LOAD_FAC_FROM_YA
0020E9r 1  A9 00                lda     #$00
0020EBr 1  85 B2                sta     FACSIGN
0020EDr 1  A5 63                lda     CPRMASK
0020EFr 1  20 rr rr             jsr     TAN1
0020F2r 1  A9 9E                lda     #TEMP3
0020F4r 1  A0 00                ldy     #$00
0020F6r 1  4C rr rr             jmp     FDIV
0020F9r 1               TAN1:
0020F9r 1  48                   pha
0020FAr 1  4C rr rr             jmp     SIN1
0020FDr 1               
0020FDr 1               ; =============================================================================
0020FDr 1               
0020FDr 1               CON_PI_HALF:
0020FDr 1  81 49 0F DB          .byte   $81,$49,$0F,$DB
002101r 1               CON_PI_DOUB:
002101r 1  83 49 0F DB          .byte   $83,$49,$0F,$DB
002105r 1               QUARTER:
002105r 1  7F 00 00 00          .byte   $7F,$00,$00,$00
002109r 1               POLY_SIN:
002109r 1  04 86 1E D7          .byte   $04,$86,$1E,$D7,$FB,$87,$99,$26
00210Dr 1  FB 87 99 26  
002111r 1  65 87 23 34          .byte   $65,$87,$23,$34,$58,$86,$A5,$5D
002115r 1  58 86 A5 5D  
002119r 1  E1 83 49 0F          .byte   $E1,$83,$49,$0F,$DB
00211Dr 1  DB           
00211Er 1               
00211Er 1               ; =============================================================================
00211Er 1               ; "ATN" FUNCTION
00211Er 1               ; =============================================================================
00211Er 1               
00211Er 1               ATN:
00211Er 1  A5 B2                lda     FACSIGN
002120r 1  48                   pha
002121r 1  10 03                bpl     L3FDB
002123r 1  20 rr rr             jsr     NEGOP
002126r 1               L3FDB:
002126r 1  A5 AE                lda     FAC
002128r 1  48                   pha
002129r 1  C9 81                cmp     #$81
00212Br 1  90 07                bcc     L3FE9
00212Dr 1  A9 rr                lda     #<CON_ONE
00212Fr 1  A0 rr                ldy     #>CON_ONE
002131r 1  20 rr rr             jsr     FDIV
002134r 1               
002134r 1               ; =============================================================================
002134r 1               ; 0 <= X <= 1
002134r 1               ; 0 <= ATN(X) <= PI/8
002134r 1               ; =============================================================================
002134r 1               
002134r 1               L3FE9:
002134r 1  A9 rr                lda     #<POLY_ATN
002136r 1  A0 rr                ldy     #>POLY_ATN
002138r 1  20 rr rr             jsr     POLYNOMIAL_ODD
00213Br 1  68                   pla
00213Cr 1  C9 81                cmp     #$81
00213Er 1  90 07                bcc     L3FFC
002140r 1  A9 rr                lda     #<CON_PI_HALF
002142r 1  A0 rr                ldy     #>CON_PI_HALF
002144r 1  20 rr rr             jsr     FSUB
002147r 1               L3FFC:
002147r 1  68                   pla
002148r 1  10 03                bpl     L4002
00214Ar 1  4C rr rr             jmp     NEGOP
00214Dr 1               L4002:
00214Dr 1  60                   rts
00214Er 1               
00214Er 1               ; =============================================================================
00214Er 1               
00214Er 1               POLY_ATN:
00214Er 1  08                   .byte   $08
00214Fr 1  78 3A C5 37          .byte   $78,$3A,$C5,$37
002153r 1  7B 83 A2 5C          .byte   $7B,$83,$A2,$5C
002157r 1  7C 2E DD 4D          .byte   $7C,$2E,$DD,$4D
00215Br 1  7D 99 B0 1E          .byte   $7D,$99,$B0,$1E
00215Fr 1  7D 59 ED 24          .byte   $7D,$59,$ED,$24
002163r 1  7E 91 72 00          .byte   $7E,$91,$72,$00
002167r 1  7E 4C B9 73          .byte   $7E,$4C,$B9,$73
00216Br 1  7F AA AA 53          .byte   $7F,$AA,$AA,$53
00216Fr 1  81 00 00 00          .byte   $81,$00,$00,$00
002173r 1               GENERIC_CHRGET:
002173r 1  E6 CF                inc     TXTPTR
002175r 1  D0 02                bne     GENERIC_CHRGOT
002177r 1  E6 D0                inc     TXTPTR+1
002179r 1               GENERIC_CHRGOT:
002179r 1               GENERIC_TXTPTR = GENERIC_CHRGOT + 1
002179r 1  AD 60 EA             lda     $EA60
00217Cr 1  C9 3A                cmp     #$3A
00217Er 1  B0 0A                bcs     L4058
002180r 1               GENERIC_CHRGOT2:
002180r 1  C9 20                cmp     #$20
002182r 1  F0 EF                beq     GENERIC_CHRGET
002184r 1  38                   sec
002185r 1  E9 30                sbc     #$30
002187r 1  38                   sec
002188r 1  E9 D0                sbc     #$D0
00218Ar 1               L4058:
00218Ar 1  60                   rts
00218Br 1               GENERIC_RNDSEED:
00218Br 1               ; random number seed
00218Br 1  80 4F C7 52          .byte   $80,$4F,$C7,$52
00218Fr 1               GENERIC_CHRGET_END:
00218Fr 1               
00218Fr 1               ; =============================================================================
00218Fr 1               
00218Fr 1               PR_WRITTEN_BY:
00218Fr 1  A9 rr                lda     #<QT_WRITTEN_BY
002191r 1  A0 rr                ldy     #>QT_WRITTEN_BY
002193r 1  20 rr rr             jsr     STROUT
002196r 1               COLD_START:
002196r 1  A9 00                lda     #$00
002198r 1  8D rr rr             sta     ls_mode         ; Normal mode.
00219Br 1  8D rr rr             sta     load_count
00219Er 1  8D rr rr             sta     load_count + 1
0021A1r 1               
0021A1r 1  A2 FF                ldx     #$FF
0021A3r 1  86 8A                stx     CURLIN+1
0021A5r 1  9A                   txs
0021A6r 1  A9 rr                lda     #<COLD_START
0021A8r 1  A0 rr                ldy     #>COLD_START
0021AAr 1  85 01                sta     GORESTART+1
0021ACr 1  84 02                sty     GORESTART+2
0021AEr 1  85 04                sta     GOSTROUT+1
0021B0r 1  84 05                sty     GOSTROUT+2
0021B2r 1  A9 rr                lda     #<AYINT
0021B4r 1  A0 rr                ldy     #>AYINT
0021B6r 1  85 06                sta     GOAYINT
0021B8r 1  84 07                sty     GOAYINT+1
0021BAr 1  A9 rr                lda     #<GIVAYF
0021BCr 1  A0 rr                ldy     #>GIVAYF
0021BEr 1  85 08                sta     GOGIVEAYF
0021C0r 1  84 09                sty     GOGIVEAYF+1
0021C2r 1  A9 4C                lda     #$4C
0021C4r 1  85 00                sta     GORESTART
0021C6r 1  85 03                sta     GOSTROUT
0021C8r 1  85 A3                sta     JMPADRS
0021CAr 1  85 0A                sta     USR
0021CCr 1  A9 rr                lda     #<IQERR
0021CEr 1  A0 rr                ldy     #>IQERR
0021D0r 1  85 0B                sta     USR+1
0021D2r 1  84 0C                sty     USR+2
0021D4r 1  A9 50                lda     #WIDTH
0021D6r 1  85 0F                STA     Z17
0021D8r 1  A9 38                lda     #WIDTH2
0021DAr 1  85 10                sta     Z18
0021DCr 1  A2 1C                ldx     #GENERIC_CHRGET_END-GENERIC_CHRGET
0021DEr 1               L4098:
0021DEr 1  BD rr rr             lda     GENERIC_CHRGET-1,x
0021E1r 1  95 C7                sta     CHRGET-1,x
0021E3r 1  CA                   dex
0021E4r 1  D0 F8                bne     L4098
0021E6r 1  8A                   txa
0021E7r 1  85 B4                sta     SHIFTSIGNEXT
0021E9r 1  85 69                sta     LASTPT+1
0021EBr 1  85 0D                sta     Z15
0021EDr 1  85 0E                sta     POSX
0021EFr 1  48                   pha
0021F0r 1  85 64                sta     Z14
0021F2r 1  A9 03                lda     #$03
0021F4r 1  85 A2                sta     DSCLEN
0021F6r 1  A9 2C                lda     #$2C
0021F8r 1  85 12                sta     LINNUM+1
0021FAr 1  20 rr rr             jsr     CRDO
0021FDr 1  A2 6A                ldx     #TEMPST
0021FFr 1  86 67                STX     TEMPPT
002201r 1               
002201r 1                       ;lda     #<QT_MEMORY_SIZE	; SJ April 2014. Removed memory size question.
002201r 1                       ;ldy     #>QT_MEMORY_SIZE
002201r 1                       ;jsr     STROUT
002201r 1                       ;jsr     NXIN
002201r 1                       ;stx     TXTPTR
002201r 1                       ;sty     TXTPTR+1
002201r 1                       ;JSR     CHRGET
002201r 1                       ;cmp     #$41
002201r 1                       ;beq     PR_WRITTEN_BY
002201r 1                       ;tay
002201r 1                       ;bne     L40EE
002201r 1               
002201r 1  A9 20                LDA     #<RAMSTART2
002203r 1  A0 03                ldy     #>RAMSTART2
002205r 1  85 11                sta     LINNUM
002207r 1  84 12                sty     LINNUM+1
002209r 1  A0 00                ldy     #$00
00220Br 1               L40D7:
00220Br 1  E6 11                inc     LINNUM
00220Dr 1  D0 02                bne     L40DD
00220Fr 1  E6 12                inc     LINNUM+1
002211r 1               L40DD:
002211r 1  A9 92                lda     #$92 ; 10010010 / 00100100
002213r 1  91 11                sta     (LINNUM),y
002215r 1  D1 11                cmp     (LINNUM),y
002217r 1  D0 15                bne     L40FA
002219r 1  0A                   asl     a
00221Ar 1  91 11                sta     (LINNUM),y
00221Cr 1  D1 11                cmp     (LINNUM),y
00221Er 1  F0 EB                beq     L40D7; old: faster
002220r 1  D0 0C                bne     L40FA
002222r 1               L40EE:
002222r 1  20 CE 00             jsr     CHRGOT
002225r 1  20 rr rr             jsr     LINGET
002228r 1  A8                   tay
002229r 1  F0 03                beq     L40FA
00222Br 1  4C rr rr             jmp     SYNERR
00222Er 1               L40FA:
00222Er 1  A5 11                lda     LINNUM
002230r 1  A4 12                ldy     LINNUM+1
002232r 1  85 87                sta     MEMSIZ
002234r 1  84 88                sty     MEMSIZ+1
002236r 1  85 83                sta     FRETOP
002238r 1  84 84                sty     FRETOP+1
00223Ar 1               L4106:
00223Ar 1               
00223Ar 1  20 rr rr         	jsr     CRDO
00223Dr 1               
00223Dr 1                       ;lda     #<QT_TERMINAL_WIDTH	; SJ April 2014. Removed width question.
00223Dr 1                       ;ldy     #>QT_TERMINAL_WIDTH
00223Dr 1                       ;jsr     STROUT
00223Dr 1                       ;jsr     NXIN
00223Dr 1                       ;stx     TXTPTR
00223Dr 1                       ;sty     TXTPTR+1
00223Dr 1                       ;jsr     CHRGET
00223Dr 1                       ;tay
00223Dr 1                       ;beq     L4136
00223Dr 1                       ;jsr     LINGET
00223Dr 1                       ;lda     LINNUM+1
00223Dr 1                       ;bne     L4106
00223Dr 1                       ;lda     LINNUM
00223Dr 1                       ;cmp     #$10
00223Dr 1                       ;bcc     L4106
00223Dr 1                       ;STA     Z17
00223Dr 1               
00223Dr 1               L4129:
00223Dr 1                       ;sbc     #$0E
00223Dr 1                       ;bcs     L4129
00223Dr 1                       ;eor     #$FF
00223Dr 1                       ;sbc     #$0C
00223Dr 1                       ;clc
00223Dr 1                       ;adc     Z17
00223Dr 1                       ;sta     Z18
00223Dr 1               L4136:
00223Dr 1               
00223Dr 1  A2 20                ldx     #<RAMSTART2
00223Fr 1  A0 03                ldy     #>RAMSTART2
002241r 1  86 7B                stx     TXTTAB
002243r 1  84 7C                sty     TXTTAB+1
002245r 1  A0 00                ldy     #$00
002247r 1  98                   tya
002248r 1  91 7B                sta     (TXTTAB),y
00224Ar 1  E6 7B                inc     TXTTAB
00224Cr 1  D0 02                bne     L4192
00224Er 1  E6 7C                inc     TXTTAB+1
002250r 1               L4192:
002250r 1  A5 7B                lda     TXTTAB
002252r 1  A4 7C                ldy     TXTTAB+1
002254r 1  20 rr rr             jsr     REASON
002257r 1  20 rr rr             jsr     CRDO
00225Ar 1  A5 87                lda     MEMSIZ
00225Cr 1  38                   sec
00225Dr 1  E5 7B                sbc     TXTTAB
00225Fr 1  AA                   tax
002260r 1  A5 88                lda     MEMSIZ+1
002262r 1  E5 7C                sbc     TXTTAB+1
002264r 1  20 rr rr             jsr     LINPRT
002267r 1  A9 rr                lda     #<QT_BYTES_FREE
002269r 1  A0 rr                ldy     #>QT_BYTES_FREE
00226Br 1  20 rr rr             jsr     STROUT
00226Er 1  A9 rr                lda     #<STROUT
002270r 1  A0 rr                ldy     #>STROUT
002272r 1  85 04                sta     GOSTROUT+1
002274r 1  84 05                sty     GOSTROUT+2
002276r 1  20 rr rr             jsr     SCRTCH
002279r 1  A9 rr                lda     #<RESTART
00227Br 1  A0 rr                ldy     #>RESTART
00227Dr 1  85 01                sta     GORESTART+1
00227Fr 1  84 02                sty     GORESTART+2
002281r 1  6C 01 00             jmp     (GORESTART+1)
002284r 1               ; OSI is compiled for ROM, but includes
002284r 1               ; this unused string
002284r 1  57 41 4E 54          .byte   "WANT SIN-COS-TAN-ATN"
002288r 1  20 53 49 4E  
00228Cr 1  2D 43 4F 53  
002298r 1  00                   .byte   0
002299r 1               QT_WRITTEN_BY:
002299r 1  0D 0A 0C             .byte   CR,LF,$0C ; FORM FEED
00229Cr 1  57 52 49 54          .byte   "WRITTEN BY RICHARD W. WEILAND."
0022A0r 1  54 45 4E 20  
0022A4r 1  42 59 20 52  
0022BAr 1  0D 0A 00             .byte   CR,LF,0
0022BDr 1               QT_MEMORY_SIZE:
0022BDr 1  4D 45 4D 4F          .byte   "MEMORY SIZE"
0022C1r 1  52 59 20 53  
0022C5r 1  49 5A 45     
0022C8r 1  00                   .byte   0
0022C9r 1               QT_TERMINAL_WIDTH:
0022C9r 1  54 45 52 4D          .byte   "TERMINAL WIDTH"
0022CDr 1  49 4E 41 4C  
0022D1r 1  20 57 49 44  
0022D7r 1  00                   .byte   0
0022D8r 1               QT_BYTES_FREE:
0022D8r 1  20 42 59 54          .byte   " BYTES FREE"
0022DCr 1  45 53 20 46  
0022E0r 1  52 45 45     
0022E3r 1  0D 0A 0D 0A          .byte   CR,LF,CR,LF
0022E7r 1  4F 52 57 45          .byte   "ORWELL 6502 BASIC VERSION 1.0 REV 1.8"
0022EBr 1  4C 4C 20 36  
0022EFr 1  35 30 32 20  
00230Cr 1  0D 0A                .byte   CR,LF
00230Er 1  43 4F 50 59          .byte   "COPYRIGHT 1977 BY MICROSOFT CO."
002312r 1  52 49 47 48  
002316r 1  54 20 31 39  
00232Dr 1  0D 0A 00             .byte   CR,LF,0
002330r 1               
002330r 1               ; =============================================================================
002330r 1               ; STARTUP AND SERIAL I/O ROUTINES
002330r 1               ;==============================================================================
002330r 1               
002330r 1               Reset:
002330r 1               
002330r 1  A2 FC            LDX     #STACK_TOP
002332r 1  9A               TXS                     ; Initialise stack pointer.
002333r 1               
002333r 1  D8               CLD                     ; Clear decimal mode.
002334r 1                                           ; VIA1 initialisation.
002334r 1                                           ; Set VIA1 port a up.
002334r 1  A9 00            LDA     #$00            ; Load ACC with b00000000.
002336r 1  8D 03 50         STA     via1_ddra       ; Set VIA port a all input.
002339r 1                                           ; Set VIA1 port b up.
002339r 1  A9 FF            LDA     #$FF            ; Load ACC with b11111111.
00233Br 1  8D 02 50         STA     via1_ddrb       ; Set VIA port b all output.
00233Er 1                                           ; Set VIA1 PCR.
00233Er 1  A9 CC            LDA     #$CC            ; Load ACC with b11001100
002340r 1  8D 0C 50         STA     via1_pcr        ; Set up for CB1, CB2 low outputs.
002343r 1                                           ; Set VIA1 IER.
002343r 1  A9 00            LDA     #$00            ; Load ACC with b00000000.
002345r 1  8D 0E 50         STA     via1_ier        ; Disable all VIA interrupts.
002348r 1               
002348r 1                                           ; Keyboard reading initialisation.
002348r 1  A9 19            LDA     #$19            ; Set the debounce counter.
00234Ar 1  8D rr rr         STA     key_counter     ; And store it.
00234Dr 1  A9 00            LDA     #$00            ; Load accumulator with 0.
00234Fr 1  8D rr rr         STA     key_last_key    ; Set the last key pressed value.
002352r 1  8D rr rr         STA     key_data        ; Set the data buffer
002355r 1  8D rr rr         STA     key_pressed     ; Set the key_pressed buffer.
002358r 1  8D rr rr         STA     key_status      ; Set the status.
00235Br 1               
00235Br 1  8D 00 60         STA     IO              ; Set up the IO buffer.
00235Er 1               
00235Er 1  AD 0B 50         LDA     via1_acr        ; Set up timer 1 on the VIA.
002361r 1  09 C0            ORA     #$C0            ; Free-run T1 with output on PB7.
002363r 1  8D 0B 50         STA     via1_acr        ; Don't enable T1 interrupts though
002366r 1  A9 00            LDA     #$00
002368r 1  8D 04 50         STA     via1_t1cl       ;  Set the counter values to zero.
00236Br 1  8D 05 50         STA     via1_t1ch
00236Er 1  A9 FF            LDA     #$FF            ; Set up the default beeper value.
002370r 1  8D rr rr         STA     beeper
002373r 1                                           ; Start the ACDs free running.
002373r 1  A9 0C            LDA     #$0C            ; Set CA2 to output low.
002375r 1  8D 0C 44         STA     via2_pcr
002378r 1               
002378r 1  20 rr rr         JSR     Reset_ACIA      ; Initialise the ACIA for serial send/receive.
00237Br 1               
00237Br 1  A9 rr            lda     #<ISR_V1        ; Set up interrupt vector hooks.
00237Dr 1  8D rr rr         sta     int_vector1
002380r 1  A0 rr            ldy     #>ISR_V1
002382r 1  8C rr rr         sty     int_vector1 + 1
002385r 1  A9 rr            lda     #<ISR_V2
002387r 1  8D rr rr         sta     int_vector2
00238Ar 1  A0 rr            ldy     #>ISR_V2
00238Cr 1  8C rr rr         sty     int_vector2 + 1
00238Fr 1               
00238Fr 1  58               CLI                     ; Enable interrupts.
002390r 1               
002390r 1  20 rr rr         JSR     Set_font        ; Set the default font to be 80 columns.
002393r 1               
002393r 1  A0 00            LDY #0
002395r 1               ShowStartMsg:               ; Display start-up message
002395r 1  B9 rr rr         LDA     StartupMessage,Y
002398r 1  F0 06            BEQ     WaitForKeypress
00239Ar 1  20 rr rr         JSR     MONCOUT
00239Dr 1  C8               INY
00239Er 1  D0 F5            BNE     ShowStartMsg
0023A0r 1               
0023A0r 1               
0023A0r 1               WaitForKeypress:            ; Wait for a cold/warm start selection
0023A0r 1               
0023A0r 1  20 rr rr         JSR     MONRDKEY
0023A3r 1  90 FB            BCC     WaitForKeypress
0023A5r 1               
0023A5r 1  29 DF            AND     #$DF            ; Make upper case.
0023A7r 1  C9 57            CMP     #'W'            ; Compare with [W]arm start.
0023A9r 1  F0 07            BEQ     WarmStart
0023ABr 1               
0023ABr 1  C9 43            CMP     #'C'            ; Compare with [C]old start.
0023ADr 1  D0 81            BNE     Reset
0023AFr 1               
0023AFr 1  4C rr rr         JMP     COLD_START      ; BASIC cold start.
0023B2r 1               
0023B2r 1               WarmStart:
0023B2r 1               
0023B2r 1  8D 0C 44         STA     via2_pcr
0023B5r 1  4C rr rr         JMP     RESTART         ; BASIC warm start.
0023B8r 1               
0023B8r 1               
0023B8r 1               ; =============================================================================
0023B8r 1               ; Output a character.
0023B8r 1               ;==============================================================================
0023B8r 1               
0023B8r 1               MONCOUT:
0023B8r 1  48               PHA                         ; Push the accumulator.
0023B9r 1  8D rr rr         STA		char_to_send		; Store the character we are sending.
0023BCr 1               
0023BCr 1  A9 80            LDA     #%10000000          ; If we are in a flow control condition we can't
0023BEr 1  2D rr rr         AND     ls_mode           	; transmit so don't try sending anything or we
0023C1r 1  D0 14            BNE     MONCOUT_DONE        ; get stuck polling for the transmitter to be free.
0023C3r 1               
0023C3r 1  A9 01            LDA     #%00000001       	; If we are in load mode don't echo to the screen.
0023C5r 1  2D rr rr         AND     ls_mode
0023C8r 1  D0 0D            BNE     MONCOUT_DONE
0023CAr 1               
0023CAr 1  A9 04            LDA     #%00000100          ; If we are in save mode echo to the serial port and screen.
0023CCr 1  2D rr rr         AND     ls_mode
0023CFr 1  F0 03            BEQ     MONCOUT_SEND
0023D1r 1  20 rr rr         JSR     Send_Char
0023D4r 1               
0023D4r 1                MONCOUT_SEND:
0023D4r 1  20 rr rr         JSR		Send_Char_Screen	; Send the character to the video output.
0023D7r 1               
0023D7r 1                MONCOUT_DONE:
0023D7r 1  68               PLA                         ; Pop the accumulator.
0023D8r 1  60               RTS
0023D9r 1               
0023D9r 1               ; =============================================================================
0023D9r 1               ; Check if a key is pressed. Carry set if key pressed.
0023D9r 1               ;==============================================================================
0023D9r 1               
0023D9r 1               MONRDKEY:
0023D9r 1  20 rr rr         JSR Key_Scan        ; Scan the keyboard.
0023DCr 1               
0023DCr 1  A9 80            LDA #$80            ; Check if the new data available flag is set.
0023DEr 1  2D rr rr         AND key_status      ; AND it with the keyboard status to test the bit.
0023E1r 1  F0 0F            BEQ No_Key          ; If the result is equal to zero we have no data.
0023E3r 1               
0023E3r 1  A9 7F            LDA #$7F            ; Clear the new data available bit.
0023E5r 1  2D rr rr         AND key_status
0023E8r 1  8D rr rr         STA key_status
0023EBr 1               
0023EBr 1  AD rr rr         LDA key_data        ; Get the data.
0023EEr 1  38               SEC                 ; Carry set if key available.
0023EFr 1  4C rr rr         JMP Done_Key
0023F2r 1               No_Key:
0023F2r 1  18               CLC                 ; Carry clear if no key pressed.
0023F3r 1               Done_Key:
0023F3r 1  60               RTS
0023F4r 1               
0023F4r 1               ; =============================================================================
0023F4r 1               ; Check if control-C is pressed. Carry set if pressed and cleared if not.
0023F4r 1               ;==============================================================================
0023F4r 1               
0023F4r 1               MONISCNTC:
0023F4r 1  20 rr rr         JSR     MONRDKEY
0023F7r 1  90 06            BCC     Not_CTRLC   ; If no key pressed then exit.
0023F9r 1  C9 03            CMP     #3
0023FBr 1  D0 02            BNE     Not_CTRLC   ; If CTRL-C not pressed then exit.
0023FDr 1  38               SEC                 ; Carry set if control-C pressed.
0023FEr 1  60               RTS
0023FFr 1               Not_CTRLC:
0023FFr 1  18               CLC                 ; Carry clear if control-C not pressed.
002400r 1  60               RTS
002401r 1               
002401r 1               ; =============================================================================
002401r 1               ; Keyboard map.
002401r 1               ; The keyboard is 48 keys mapped as 7 rows by 8 columns.
002401r 1               ; There are four parts to the table for normal and shifted keys, control
002401r 1               ; and function keys.
002401r 1               ; =============================================================================
002401r 1               
002401r 1               keyboard_map:
002401r 1  3D 20 0D 00  keyboard_map_row_n0: .BYTE "=", $20, $0D, 0, 0, 0, 0, 0 ;$20 = SPACE, $0D = CR
002405r 1  00 00 00 00  
002409r 1  6E 68 79 36  keyboard_map_row_n1: .BYTE "nhy6bgt5"
00240Dr 1  62 67 74 35  
002411r 1  6D 6A 75 37  keyboard_map_row_n2: .BYTE "mju7vfr4"
002415r 1  76 66 72 34  
002419r 1  2C 6B 69 38  keyboard_map_row_n3: .BYTE ",ki8cde3"
00241Dr 1  63 64 65 33  
002421r 1  2E 6C 6F 39  keyboard_map_row_n4: .BYTE ".lo9xsw2"
002425r 1  78 73 77 32  
002429r 1  2F 3B 70 30  keyboard_map_row_n5: .BYTE "/;p0zaq1"
00242Dr 1  7A 61 71 31  
002431r 1  2B 20 0D 00  keyboard_map_row_s0: .BYTE "+", $20, $0D, 0, 0, 0, 0, 0 ;$20 = SPACE, $0D = CR
002435r 1  00 00 00 00  
002439r 1  4E 48 59 5E  keyboard_map_row_s1: .BYTE "NHY^BGT%"
00243Dr 1  42 47 54 25  
002441r 1  4D 4A 55 26  keyboard_map_row_s2: .BYTE "MJU&VFR$"
002445r 1  56 46 52 24  
002449r 1  3C 4B 49 2A  keyboard_map_row_s3: .BYTE "<KI*CDE#"
00244Dr 1  43 44 45 23  
002451r 1  3E 4C 4F 28  keyboard_map_row_s4: .BYTE ">LO(XSW@"
002455r 1  58 53 57 40  
002459r 1  2D 3A 50 29  keyboard_map_row_s5: .BYTE "-:P)ZAQ!"
00245Dr 1  5A 41 51 21  
002461r 1  3D 20 0D 00  keyboard_map_row_c0: .BYTE "=", $20, $0D, 0, 0, 0, 0, 0 ;$20 = SPACE, $0D = CR
002465r 1  00 00 00 00  
002469r 1  6E 68 79 36  keyboard_map_row_c1: .BYTE "nhy6b", $07, "t5"           ;$07 = CTRL-G (bell)
00246Dr 1  62 07 74 35  
002471r 1  6D 6A 75 37  keyboard_map_row_c2: .BYTE "mju7vfr4"
002475r 1  76 66 72 34  
002479r 1  2C 6B 69 38  keyboard_map_row_c3: .BYTE ",ki8", $03, "de3"           ;$03 = CTRL-C
00247Dr 1  03 64 65 33  
002481r 1  2E 6C 6F 39  keyboard_map_row_c4: .BYTE ".lo9xsw2"
002485r 1  78 73 77 32  
002489r 1  2F 3B 70 30  keyboard_map_row_c5: .BYTE "/;p0zaq1"
00248Dr 1  7A 61 71 31  
002491r 1  3D 20 0D 00  keyboard_map_row_f0: .BYTE "=", $20, $0D, 0, 0, 0, 0, 0 ;$20 = SPACE, $0D = CR
002495r 1  00 00 00 00  
002499r 1  6E 68 79 36  keyboard_map_row_f1: .BYTE "nhy6b}]5"
00249Dr 1  62 7D 5D 35  
0024A1r 1  6D 6A 5F 37  keyboard_map_row_f2: .BYTE "mj_7v{[4"
0024A5r 1  76 7B 5B 34  
0024A9r 1  2C 6B 3F 38  keyboard_map_row_f3: .BYTE ",k?8`", $09, $1B, "3"       ; $09 = TAB, $1B = ESC
0024ADr 1  60 09 1B 33  
0024B1r 1  2E 6C 27 39  keyboard_map_row_f4: .BYTE ".l'9", $0A, $08, "~2"       ; $0A = LF, $08 = BS
0024B5r 1  0A 08 7E 32  
0024B9r 1  2F 3B 22 30  keyboard_map_row_f5: .BYTE "/;", $22, "0\|q1"           ; $22 = DOUBLE QUOTE
0024BDr 1  5C 7C 71 31  
0024C1r 1               
0024C1r 1               ; =============================================================================
0024C1r 1               ; Reset the ACIA for send and receive.
0024C1r 1               ; =============================================================================
0024C1r 1               
0024C1r 1               Reset_ACIA:
0024C1r 1               
0024C1r 1  A9 00            LDA     #$00
0024C3r 1  8D 01 48         STA     acia1_s         ; Reset the ACIA.
0024C6r 1  8D rr rr         STA     ls_mode       	; Normal mode.
0024C9r 1               
0024C9r 1  A9 1F            LDA     #%00011111      ; Set up for 19200/8/1.
0024CBr 1  8D 03 48         STA     acia1_ct        ; Write to ACIA control register.
0024CEr 1               
0024CEr 1  A9 0B            LDA     #%00001011      ; Set up N parity/echo off/tx int off/rts low/rx int off/dtr active.
0024D0r 1  8D 02 48         STA     acia1_cm        ; Write to ACIA command register.
0024D3r 1               
0024D3r 1  AD rr rr         LDA     acia1_rd_ptr    ; Set the two pointer to the same which
0024D6r 1  8D rr rr         STA     acia1_wr_ptr    ; indicated the buffer to be empty.
0024D9r 1               
0024D9r 1  AD 01 48         LDA     acia1_s         ; Read the status register to clear the interrupt flag.
0024DCr 1  AD 00 48         LDA     acia1_d         ; Read the data register to clear any errors.
0024DFr 1  60               RTS
0024E0r 1               
0024E0r 1               ; =============================================================================
0024E0r 1               ; Set the startup font to be 80 character bold double (best for small LCDs).
0024E0r 1               ; =============================================================================
0024E0r 1               
0024E0r 1               Set_font:
0024E0r 1  A9 03            LDA     #$03            ; Correct value.
0024E2r 1  8D rr rr         STA     c_val           ; Put into the c_value.
0024E5r 1  20 rr rr         JSR     FONT            ; Set the font.
0024E8r 1  A9 00            LDA     #$00            ; Clear the c_val.
0024EAr 1  8D rr rr         STA     c_val
0024EDr 1  60            RTS
0024EEr 1               
0024EEr 1               ; =============================================================================
0024EEr 1               ; Serial send char subroutine. Character is in char_to_send.
0024EEr 1               ; =============================================================================
0024EEr 1               
0024EEr 1               Send_Char:
0024EEr 1               
0024EEr 1  78               SEI                         ; Disable interrupts during send.
0024EFr 1               
0024EFr 1               Send_Char_Wait_TX:
0024EFr 1  AD 01 48         LDA     acia1_s      	    ; Read CIA staus register.
0024F2r 1  29 10            AND     #%00010000         	; Check if the TX buffer is empty.
0024F4r 1  F0 F9          	BEQ     Send_Char_Wait_TX   ; Wait if not.
0024F6r 1               
0024F6r 1  AD rr rr         LDA		char_to_send		; Get the character we are sending.
0024F9r 1  8D 00 48       	STA     acia1_d             ; Send to ACIA data register.
0024FCr 1               
0024FCr 1               Send_Char_Done:
0024FCr 1  58               CLI                         ; Re-enable interrupts.
0024FDr 1  60               RTS			                ; Return
0024FEr 1               
0024FEr 1               ; =============================================================================
0024FEr 1               ; Video send char. Character is in char_to_send.
0024FEr 1               ; =============================================================================
0024FEr 1               
0024FEr 1               Send_Char_Screen:
0024FEr 1               
0024FEr 1  AD rr rr         LDA		char_to_send		; Get the character we are sending.
002501r 1               
002501r 1  29 F0        	AND		#$F0				; Get top nibble.
002503r 1  4A           	LSR							; Shift one bit to the right.
002504r 1  8D 00 50     	STA		via1_b				; Push it to port B of the VIA.
002507r 1               
002507r 1  A9 90        	LDA     #%10010000      	; Set up the interrupt for CB1 change.
002509r 1  8D 0E 50         STA     via1_ier        	; Write to VIA interrupt enable register.
00250Cr 1               
00250Cr 1  A9 F0        	LDA     #%11110000      	; Set up for CB2 high, CB1 interrupt on positive.
00250Er 1  8D 0C 50         STA     via1_pcr        	; Write to VIA control register.
002511r 1               
002511r 1  A9 00            LDA     #$00				; Set the waiting flag to 0.
002513r 1  8D rr rr         STA		char_sending
002516r 1               Send_Char_Wait_First_Nib:
002516r 1  AD rr rr     	LDA     char_sending      	; Check the char sending flag.
002519r 1  F0 FB          	BEQ     Send_Char_Wait_First_Nib
00251Br 1               
00251Br 1  AD rr rr         LDA		char_to_send		; Get the character we are sending.
00251Er 1  29 0F        	AND		#$0F				; Get bottom nibble.
002520r 1  18           	CLC
002521r 1  2A           	ROL							; Shift 3 bits left.
002522r 1  2A           	ROL
002523r 1  2A           	ROL
002524r 1  8D 00 50     	STA		via1_b				; Push it to port B of the VIA.
002527r 1  A9 C0        	LDA     #%11000000      	; Set up for CB2 low, CB1 interrupt on negative.
002529r 1  8D 0C 50         STA     via1_pcr        	; Write to VIA control register.
00252Cr 1               
00252Cr 1  A9 00            LDA     #$00				; Set the waiting flag to 0.
00252Er 1  8D rr rr         STA		char_sending
002531r 1               Send_Char_Wait_Second_Nib:
002531r 1  AD rr rr     	LDA     char_sending      	; Check the char sending flag.
002534r 1  F0 FB          	BEQ     Send_Char_Wait_Second_Nib
002536r 1               
002536r 1  A9 00        	LDA     #%00000000      	; Turn off all interrupts on VIA.
002538r 1  8D 0E 50         STA     via1_ier        	; Write to VIA interrupt enable register.
00253Br 1               
00253Br 1  A9 00            LDA     #$00				; Clear the port.
00253Dr 1  8D 00 50         STA		via1_b
002540r 1               
002540r 1               Send_Char_Screen_Done:
002540r 1  60               RTS			                ; Return
002541r 1               
002541r 1               ; =============================================================================
002541r 1               ; Keyboard routine. This routine will set the data available flag in the
002541r 1               ; key_status register and return data in the key_data variable when valid data
002541r 1               ; is available from the keyboard. This routine scans the matrix by calling
002541r 1               ; the matrix_scan routine then handles debouncing of the value.
002541r 1               ; =============================================================================
002541r 1               
002541r 1               Key_Scan:
002541r 1  8A               TXA                     ; Preserve X.
002542r 1  48               PHA
002543r 1  98               TYA                     ; Preserve Y.
002544r 1  48               PHA
002545r 1  08               PHP                     ; Preserve status register.
002546r 1               
002546r 1  20 rr rr         JSR     Matrix_Scan     ; Scan the matrix.
002549r 1               
002549r 1  AD rr rr         LDA     key_pressed     ; Compare the key detected to the last key pressed.
00254Cr 1  CD rr rr         CMP     key_last_key    ; Is this key different?
00254Fr 1  D0 0D            BNE     Key_Change      ; The keys are different so it's changing
002551r 1               
002551r 1                                           ; It's the same.
002551r 1  AD rr rr         LDA     key_counter     ; If the counter is already at zero this is the same keypress.
002554r 1  F0 26            BEQ     Key_Scan_Done   ; If it's zero we don't do anything.
002556r 1               
002556r 1  CE rr rr         DEC     key_counter     ; Otherwise decrement the debounce counter.
002559r 1  F0 11            BEQ     Key_Debounced   ; If it's zero now we have a valid key reading.
00255Br 1  4C rr rr         JMP     Key_Scan_Done
00255Er 1               
00255Er 1               Key_Change:
00255Er 1  A9 19            LDA     #$19            ; Reset the counter.
002560r 1  8D rr rr         STA     key_counter     ; And store it.
002563r 1  AD rr rr         LDA     key_pressed     ; Update the last key pressed value with this new value.
002566r 1  8D rr rr         STA     key_last_key
002569r 1  4C rr rr         JMP     Key_Scan_Done
00256Cr 1               
00256Cr 1               Key_Debounced:              ; A valid key reading was detected.
00256Cr 1  AD rr rr         LDA     key_pressed     ; Load up the key pressed.
00256Fr 1  F0 0B            BEQ     Key_Scan_Done   ; If it was zero (no key pressed) we're done.
002571r 1  8D rr rr         STA     key_data        ; Make it available now in the data.
002574r 1               
002574r 1  A9 80            LDA     #$80            ; Set the new data available bit.
002576r 1  0D rr rr         ORA     key_status
002579r 1  8D rr rr         STA     key_status      ; Store it in the status.
00257Cr 1               
00257Cr 1               Key_Scan_Done:
00257Cr 1  28               PLP                     ; Restore status.
00257Dr 1  68               PLA                     ; Restore Y.
00257Er 1  A8               TAY
00257Fr 1  68               PLA                     ; Restore X.
002580r 1  AA               TAX
002581r 1  60               RTS
002582r 1               
002582r 1               ; =============================================================================
002582r 1               ; Keyboard matrix scan routine. The key_status (bit 6) will indicate if there
002582r 1               ; is a key currently pressed.  It also indicated if the function, control,
002582r 1               ; shift or alpha lock were on (bits 0, 1, 2 and 3)
002582r 1               ; There are 7 rows (0-6) and 8 columns.
002582r 1               ; Shift, control and function are on row 0. Alpha is on row 6. We handle
002582r 1               ; these as special cases.
002582r 1               ; The pressed key is returned in key_pressed.
002582r 1               ; =============================================================================
002582r 1               
002582r 1               Matrix_Scan:
002582r 1  A9 00            LDA     #$00                ; Load ACC with 0.
002584r 1  8D rr rr         STA     key_buffer          ; Clear the keyboard character buffer.
002587r 1  8D rr rr         STA     key_pressed         ; Clear the key pressed buffer.
00258Ar 1  A9 80            LDA     #$80                ; Load ACC with 10000000.
00258Cr 1  2D rr rr         AND     key_status          ; Clear the bottom 7 bits of the status.
00258Fr 1  8D rr rr         STA     key_status          ; Store it in the status.
002592r 1               
002592r 1               Matrix_Scan_Special:
002592r 1  A2 00            LDX     #$00                ; Read row 0.
002594r 1                                               ; Row zero is a special case as it has the shift, control and function keys.
002594r 1  8A               TXA                         ; Move the row counter to the accumulator.
002595r 1  8D 00 50         STA     via1_b              ; Push it to the VIA port b to select the row.
002598r 1  AD 01 50         LDA     via1_a              ; Read VIA input port a.
00259Br 1  49 FF            EOR     #$FF                ; Exclusive OR to get which bits are set (keys active low).
00259Dr 1  F0 16            BEQ     Matrix_Scan_Alpha   ; Can shortcut here. If this is zero no keys are being pressed on this row.
00259Fr 1                                               ; Just go straight to the next row.
00259Fr 1  8D rr rr         STA     key_buffer          ; We have some key or keys pressed. Store the port in our temp holder.
0025A2r 1  A9 07            LDA     #$07                ; Check if the special keys are pressed. Set up mask for the special keys.
0025A4r 1  2D rr rr         AND     key_buffer
0025A7r 1  0D rr rr         ORA     key_status          ; Now set those bits in the status register.
0025AAr 1  8D rr rr         STA     key_status          ; Store it in the status.
0025ADr 1               
0025ADr 1  A9 E0            LDA     #$E0                ; Now mask off the normal keys and check them.
0025AFr 1  2D rr rr         AND     key_buffer
0025B2r 1  8D rr rr         STA     key_buffer          ; Store it in the buffer.
0025B5r 1               
0025B5r 1               Matrix_Scan_Alpha:
0025B5r 1  A2 06            LDX     #$6                 ; The alpha key on row 6 is also a special case.
0025B7r 1  8A               TXA                         ; Move the row counter to the accumulator.
0025B8r 1  8D 00 50         STA     via1_b              ; Push it to the VIA port b to select the row.
0025BBr 1  AD 01 50         LDA     via1_a              ; Read VIA input port a.
0025BEr 1  49 FF            EOR     #$FF                ; Exclusive OR to get which bits are set (keys active low).
0025C0r 1  F0 08            BEQ     Matrix_Scan_Rows    ; If this is non zero the alpha key is pressed.
0025C2r 1               
0025C2r 1  A9 08            LDA     #$08                ; Set the alpha bit.
0025C4r 1  0D rr rr         ORA     key_status
0025C7r 1  8D rr rr         STA     key_status          ; Store it in the status.
0025CAr 1               
0025CAr 1               Matrix_Scan_Rows:
0025CAr 1  A2 00            LDX     #$00                ; Reset X back to the first row.
0025CCr 1  A0 00            LDY     #$00                ; Use Y as the column counter.
0025CEr 1               
0025CEr 1               Matrix_Scan_Col:
0025CEr 1  A9 80            LDA     #$80                ; Load a mask into the accumulator to check the data bit of the buffer.
0025D0r 1  2D rr rr         AND     key_buffer          ; AND it with the buffer to test the bit to see if a key was pressed.
0025D3r 1  F0 20            BEQ     Matrix_Scan_Col_Next; Branch if it is zero since that key wasn't pressed.
0025D5r 1               
0025D5r 1  A9 40            LDA     #$40                ; It's set. Check if we already have a key pressed. Test bit 6 of the keyboard status.
0025D7r 1  2D rr rr         AND     key_status          ; AND it with the keyboard status to test the bit.
0025DAr 1  F0 0B            BEQ     Matrix_Scan_Col_Data; If it's not set (result equals zero) process this new key.
0025DCr 1               
0025DCr 1               Matrix_scan_Invalid:            ; It's already set so now we have an invalid state.
0025DCr 1  A9 BF            LDA     #$BF                ; Clear the key pressed flag.
0025DEr 1  2D rr rr         AND     key_status
0025E1r 1  8D rr rr         STA     key_status          ; Set the status.
0025E4r 1  4C rr rr         JMP     Matrix_Scan_Done    ; Now finish since it was invalid.
0025E7r 1               
0025E7r 1               Matrix_Scan_Col_Data:
0025E7r 1  A9 40            LDA     #$40                ; Set the key pressed bit.
0025E9r 1  0D rr rr         ORA     key_status
0025ECr 1  8D rr rr         STA     key_status          ; Store it in the status.
0025EFr 1  8E rr rr         STX     key_row             ; Remember the row.
0025F2r 1  8C rr rr         STY     key_col             ; Remember the column.
0025F5r 1               
0025F5r 1               Matrix_Scan_Col_Next:
0025F5r 1  18               CLC                         ; Clear the carry flag.
0025F6r 1  2E rr rr         ROL     key_buffer          ; Rotate the buffer left to check the next column.
0025F9r 1  C8               INY                         ; Increment the column count.
0025FAr 1  C0 08            CPY     #$08                ; Have we done all eight columns?
0025FCr 1  D0 D0            BNE     Matrix_Scan_Col     ; Zero set if equal when we've done all eight.
0025FEr 1               
0025FEr 1               Matrix_Scan_Row_Next:
0025FEr 1  E8               INX                         ; Go onto the next row.
0025FFr 1  E0 06            CPX     #$06                ; Have we done all remaining six rows?
002601r 1  F0 13            BEQ     Matrix_Scan_Rows_Done
002603r 1  8A               TXA                         ; Not done so move the row counter to the accumulator and read the next row.
002604r 1  8D 00 50         STA     via1_b              ; Push it to the VIA port b to select the row.
002607r 1  AD 01 50         LDA     via1_a              ; Read VIA input port a.
00260Ar 1  49 FF            EOR     #$FF                ; Exclusive OR to get which bits are set (keys active low).
00260Cr 1  F0 F0            BEQ     Matrix_Scan_Row_Next; Can shortcut here. If this is zero no keys are being pressed on this row.
00260Er 1                                               ; Just go straight to the next row.
00260Er 1               
00260Er 1  8D rr rr         STA     key_buffer          ; We have some key or keys pressed. Store the port in our buffer.
002611r 1  A0 00            LDY     #$00                ; Use Y as the column counter.
002613r 1  4C rr rr         JMP     Matrix_Scan_Col     ; Check the columns for this row.
002616r 1               
002616r 1               Matrix_Scan_Rows_Done:
002616r 1  A9 40            LDA     #$40                ; Check if the data flag is set.
002618r 1  2D rr rr         AND     key_status          ; AND it with the keyboard status to test the bit.
00261Br 1  F0 61            BEQ     Matrix_Scan_Done    ; If the result is equal to zero we have no keys pressed so can finish.
00261Dr 1               
00261Dr 1               Matrix_Scan_Shift:              ; We add to the row counter depending on which special keys were pressed.
00261Dr 1  A9 04            LDA     #$04                ; Check shift first.
00261Fr 1  2C rr rr         BIT     key_status          ; Bit three in key_status.
002622r 1  F0 0C            BEQ     Matrix_Scan_Ctrl    ; Shift not pressed so test control next.
002624r 1  A9 06            LDA     #$06                ; Shift was pressed so add 6 to the row count.
002626r 1  18               CLC                         ; Clear carry flag.
002627r 1  6D rr rr         ADC     key_row             ; Add to the row count.
00262Ar 1  8D rr rr         STA     key_row             ; Store the result.
00262Dr 1  4C rr rr         JMP     Matrix_Scan_Lookup  ; Now go look up the key.
002630r 1               
002630r 1               Matrix_Scan_Ctrl:
002630r 1  A9 02            LDA     #$02                ; Check control next.
002632r 1  2C rr rr         BIT     key_status          ; Bit 2 in key_status.
002635r 1  F0 0C            BEQ     Matrix_Scan_Fctn    ; Control not pressed so test function next.
002637r 1  A9 0C            LDA     #$0C                ; Control was pressed so add 12 to the row count.
002639r 1  18               CLC                         ; Clear carry flag.
00263Ar 1  6D rr rr         ADC     key_row             ; Add to the row count.
00263Dr 1  8D rr rr         STA     key_row             ; Store the result.
002640r 1  4C rr rr         JMP     Matrix_Scan_Lookup  ; Now go look up the key.
002643r 1               
002643r 1               Matrix_Scan_Fctn:
002643r 1  A9 01            LDA     #$01                ; Finally check function.
002645r 1  2C rr rr         BIT     key_status          ; Bit one in key_status.
002648r 1  F0 09            BEQ     Matrix_Scan_Lookup  ; Function not pressed so go onto lookup the key.
00264Ar 1  A9 12            LDA     #$12                ; Function was pressed so add 18 to the row count.
00264Cr 1  18               CLC                         ; Clear carry flag.
00264Dr 1  6D rr rr         ADC     key_row             ; Add to the row count.
002650r 1  8D rr rr         STA     key_row             ; Store the result.
002653r 1               
002653r 1               Matrix_Scan_Lookup:             ; Now lookup the actual character.
002653r 1  AD rr rr         LDA     key_row             ; Get the row.
002656r 1  18               CLC                         ; Clear the carry flag.
002657r 1  2A               ROL                         ; Multiple the row counter by 8 (by using ROL).
002658r 1  18               CLC
002659r 1  2A               ROL                         ; x4
00265Ar 1  18               CLC
00265Br 1  2A               ROL                         ; x8
00265Cr 1  18               CLC
00265Dr 1  6D rr rr         ADC     key_col             ; Then add the column to get out offset into the table.
002660r 1  AA               TAX                         ; Transfer it into X.
002661r 1  BD rr rr         LDA     keyboard_map, X     ; Use this as the offset into our table. Add the offset to the start of the table
002664r 1                                               ; and get the actual character into the accumulator.
002664r 1               
002664r 1  8D rr rr         STA     key_pressed         ; Store the new character.
002667r 1               
002667r 1  A9 08            LDA     #$08                ; Check if Alpha is on.
002669r 1  2C rr rr         BIT     key_status          ; Bit four in key_status.
00266Cr 1  F0 10            BEQ     Matrix_Scan_Done    ; Alpha not pressed so just store the key.
00266Er 1                                               ; $61 = a .. $7A = z.
00266Er 1               
00266Er 1  AD rr rr         LDA     key_pressed
002671r 1  C9 61            CMP     #$61                ; Alpha is pressed so make lower case letters upper.
002673r 1  90 09            BCC     Matrix_Scan_Done    ; Less than $61.
002675r 1               
002675r 1  C9 7B            CMP     #$7B
002677r 1  B0 05            BCS     Matrix_Scan_Done    ; More than than $7A.
002679r 1               
002679r 1  29 DF            AND     #$DF                ; Make upper case.
00267Br 1  8D rr rr         STA     key_pressed         ; Store the new character.
00267Er 1               
00267Er 1               Matrix_Scan_Done:
00267Er 1  A9 00            LDA     #$00                ; Reset the VIA port to all zero.
002680r 1  8D 00 50         STA     via1_b              ; Push it to the VIA port b.
002683r 1               
002683r 1  60               RTS
002684r 1               
002684r 1               
002684r 1               ; =============================================================================
002684r 1               ; Dumps out memory. The amount is specified in dump_number.
002684r 1               ; =============================================================================
002684r 1               
002684r 1               Dump_Memory:
002684r 1               
002684r 1  08               PHP
002685r 1  48               PHA
002686r 1  8A               TXA
002687r 1  48               PHA
002688r 1  98               TYA
002689r 1  48               PHA
00268Ar 1               
00268Ar 1  A9 0C            LDA     #$0C        ; Use X as a byte counter.
00268Cr 1  AA               TAX                 ; We can fit 12 bytes across the screen.
00268Dr 1               
00268Dr 1  A9 0D            LDA     #$0D        ; Start on a new line.
00268Fr 1  20 rr rr         JSR     Send_Char
002692r 1  A9 0A            LDA     #$0A
002694r 1  20 rr rr         JSR     Send_Char
002697r 1  A0 00            LDY     #$00
002699r 1               Dump:
002699r 1  B9 20 03         LDA     RAMSTART2, Y
00269Cr 1  20 rr rr         JSR     Print_Byte
00269Fr 1  C8               INY
0026A0r 1  98               TYA
0026A1r 1  ED rr rr         SBC     dump_number  ; Number of bytes to dump out.
0026A4r 1  F0 12            BEQ     Dump_Done    ; If we've done them all we're finished.
0026A6r 1               
0026A6r 1  CA               DEX
0026A7r 1  D0 F0            BNE     Dump
0026A9r 1               
0026A9r 1  A9 0D            LDA     #$0D         ; Next line.
0026ABr 1  20 rr rr         JSR     Send_Char
0026AEr 1  A9 0A            LDA     #$0A
0026B0r 1  20 rr rr         JSR     Send_Char
0026B3r 1  A9 0C            LDA     #$0C
0026B5r 1  AA               TAX                 ; Reset X.
0026B6r 1  D0 E1            BNE     Dump
0026B8r 1               
0026B8r 1               Dump_Done:
0026B8r 1  A9 0D            LDA     #$0D         ; Next line.
0026BAr 1  20 rr rr         JSR     Send_Char
0026BDr 1  A9 0A            LDA     #$0A
0026BFr 1  20 rr rr         JSR     Send_Char
0026C2r 1               
0026C2r 1  68               PLA
0026C3r 1  A8               TAY
0026C4r 1  68               PLA
0026C5r 1  AA               TAX
0026C6r 1  68               PLA
0026C7r 1  28               PLP
0026C8r 1  60               RTS
0026C9r 1               
0026C9r 1               ; =============================================================================
0026C9r 1               ; Wait key.
0026C9r 1               ; =============================================================================
0026C9r 1               
0026C9r 1               Wait_Key:
0026C9r 1  08               PHP
0026CAr 1  48               PHA
0026CBr 1  8A               TXA
0026CCr 1  48               PHA
0026CDr 1  98               TYA
0026CEr 1  48               PHA
0026CFr 1               Wait:
0026CFr 1  20 rr rr         JSR    MONRDKEY
0026D2r 1  90 FB            BCC    Wait
0026D4r 1               
0026D4r 1  68               PLA
0026D5r 1  A8               TAY
0026D6r 1  68               PLA
0026D7r 1  AA               TAX
0026D8r 1  68               PLA
0026D9r 1  28               PLP
0026DAr 1  60               RTS
0026DBr 1               
0026DBr 1               ; =============================================================================
0026DBr 1               ; Beep
0026DBr 1               ; =============================================================================
0026DBr 1               Beep:
0026DBr 1               
0026DBr 1  48               PHA                     ; Store A.
0026DCr 1  8A               TXA                     ; Store X.
0026DDr 1  48               PHA
0026DEr 1  98               TYA                     ; Store Y.
0026DFr 1  48               PHA
0026E0r 1               
0026E0r 1  A9 00            LDA     #$00            ; Use X as inner loop counter.
0026E2r 1  AA               TAX
0026E3r 1  A9 C8            LDA     #$C8            ; Use Y as outer loop counter.
0026E5r 1  A8               TAY
0026E6r 1  AD rr rr         LDA     beeper          ; Set up the timer 1 counter.
0026E9r 1  8D 04 50         STA     via1_t1cl       ; Start playing the beep.
0026ECr 1               
0026ECr 1               Beep_2:
0026ECr 1               Beep_1:
0026ECr 1  E8               INX                     ; Increment the inner loop count.
0026EDr 1  D0 FD            BNE     Beep_1          ; Exit once counter overflows.
0026EFr 1  C8               INY
0026F0r 1  D0 FA            BNE     Beep_2          ; Exit once counter overflows.
0026F2r 1               
0026F2r 1  A9 00            LDA     #$00
0026F4r 1  8D 04 50         STA     via1_t1cl       ; Stop playing the beep.
0026F7r 1               
0026F7r 1  68               PLA
0026F8r 1  A8               TAY                     ; Restore Y.
0026F9r 1  68               PLA
0026FAr 1  AA               TAX                     ; Restore X.
0026FBr 1  68               PLA                     ; Restore A
0026FCr 1               
0026FCr 1  60               RTS
0026FDr 1               
0026FDr 1               ; =============================================================================
0026FDr 1               ; Beep1
0026FDr 1               ; =============================================================================
0026FDr 1               Beep1:
0026FDr 1               
0026FDr 1  48               PHA
0026FEr 1  A9 FF            LDA     #$FF
002700r 1  8D rr rr         STA     beeper
002703r 1  20 rr rr         JSR     Beep
002706r 1  68               PLA
002707r 1  60               RTS
002708r 1               
002708r 1               ; =============================================================================
002708r 1               ; Beep2
002708r 1               ; =============================================================================
002708r 1               Beep2:
002708r 1               
002708r 1  48               PHA
002709r 1  A9 88            LDA     #$88
00270Br 1  8D rr rr         STA     beeper
00270Er 1  20 rr rr         JSR     Beep
002711r 1  68               PLA
002712r 1  60               RTS
002713r 1               
002713r 1               ; =============================================================================
002713r 1               ; Print a byte as ASCII digits.
002713r 1               ; =============================================================================
002713r 1               
002713r 1               Print_Byte:
002713r 1  48               PHA             ; SAVE ACC FOR USE LATER ON
002714r 1  4A               LSR             ; SHIFT H.O. NIBBLE
002715r 1  4A               LSR             ; DOWN TO THE L.O. NIBBLE
002716r 1  4A               LSR             ; CLEARING THE H.O. NIBBLE
002717r 1  4A               LSR
002718r 1               
002718r 1               Print_Nibble:
002718r 1  69 30            ADC     #$30        ; CONVERT TO ASCII
00271Ar 1  C9 3A            CMP     #$3A        ; IF IT IS A DIGIT FINE, OTHER-
00271Cr 1  90 02            BCC     Print_High  ; WISE IT MUST BE CONVERTED TO A
00271Er 1  69 06            ADC     #$6         ; LETTER IN THE RANGE A-F
002720r 1               Print_High:
002720r 1  20 rr rr         JSR     Send_Char
002723r 1               
002723r 1  68               PLA                 ; GET ORIGINAL VALUE BACK
002724r 1  29 0F            AND     #$F         ; MASK H.O. NIBBLE
002726r 1               
002726r 1  69 30            ADC     #$30        ; CONVERT TO ASCII
002728r 1  C9 3A            CMP     #$3A        ; IF IT IS A DIGIT FINE, OTHER-
00272Ar 1  90 02            BCC     Print_Low   ; WISE IT MUST BE CONVERTED TO A
00272Cr 1  69 06            ADC     #$6         ; LETTER IN THE RANGE A-F
00272Er 1               Print_Low:
00272Er 1  20 rr rr         JSR     Send_Char
002731r 1  A9 20            LDA     #$20
002733r 1  20 rr rr         JSR     Send_Char
002736r 1               
002736r 1  60               RTS
002737r 1               
002737r 1               ; =============================================================================
002737r 1               ; Flow control on.
002737r 1               ; This enables sending/receiving.
002737r 1               ; =============================================================================
002737r 1               
002737r 1                Flow_On:
002737r 1  78               SEI
002738r 1  48               PHA
002739r 1  A9 09            LDA     #%00001001      ; Set bit 3 to set RTS low.
00273Br 1  8D 02 48         STA     acia1_cm
00273Er 1  A9 7F            LDA     #$7F            ; Clear the top bit to indicate no flow control condition.
002740r 1  2D rr rr         AND     ls_mode
002743r 1  8D rr rr         STA     ls_mode
002746r 1                Flow_On_Done:
002746r 1  68               PLA
002747r 1  58               CLI
002748r 1  60               RTS
002749r 1               
002749r 1               ; =============================================================================
002749r 1               ; Flow control off.
002749r 1               ; This disables sending/receiving.
002749r 1               ; =============================================================================
002749r 1               
002749r 1                Flow_Off:
002749r 1  78               SEI
00274Ar 1  48               PHA
00274Br 1  A9 01            LDA     #%00000001      ; Clear bit 3 to set RTS high.
00274Dr 1  8D 02 48         STA     acia1_cm
002750r 1  A9 80            LDA     #$80            ; Set the top bit to indicate a flow control condition.
002752r 1  0D rr rr         ORA     ls_mode
002755r 1  8D rr rr         STA     ls_mode
002758r 1                Flow_Off_Done:
002758r 1  68               PLA
002759r 1  58               CLI
00275Ar 1  60               RTS
00275Br 1               
00275Br 1               ; =============================================================================
00275Br 1               ; ACIA write buffer.
00275Br 1               ; =============================================================================
00275Br 1               
00275Br 1               ACIA_Wr_Buffer:
00275Br 1  AE rr rr         LDX     acia1_wr_ptr         ; Get the current index.
00275Er 1  9D rr rr         STA     acia1_rx_buffer, X   ; Get the pointer value and store the data where it says
002761r 1  EE rr rr         INC     acia1_wr_ptr         ; then increment the pointer for the next write.
002764r 1  60               RTS
002765r 1               
002765r 1               ; =============================================================================
002765r 1               ; ACIA read buffer.
002765r 1               ; =============================================================================
002765r 1               
002765r 1               ACIA_Rd_Buffer:
002765r 1  8A               TXA                          ; Store X.
002766r 1  48               PHA
002767r 1  AE rr rr         LDX     acia1_rd_ptr         ; Ends with A containing the byte just read from buffer.
00276Ar 1  BD rr rr         LDA     acia1_rx_buffer, X   ; Get the pointer value and read the data it points to.
00276Dr 1  8D rr rr         STA     acia1_rx_byte        ; Store the data temporarily.
002770r 1  EE rr rr         INC     acia1_rd_ptr         ; Then increment the pointer for the next read.
002773r 1  68               PLA                          ; Restore X.
002774r 1  AA               TAX
002775r 1  AD rr rr         LDA     acia1_rx_byte
002778r 1  60               RTS
002779r 1               
002779r 1               ; =============================================================================
002779r 1               ; ACIA buffer difference.
002779r 1               ; =============================================================================
002779r 1               
002779r 1               ACIA_Buffer_Diff:
002779r 1  AD rr rr         LDA     acia1_wr_ptr        ; Find difference between number of bytes written
00277Cr 1  38               SEC                         ; and how many read.
00277Dr 1  ED rr rr         SBC     acia1_rd_ptr        ; Ends with A showing the number of bytes left to read.
002780r 1  60               RTS
002781r 1               
002781r 1               ; =============================================================================
002781r 1               ; ACIA buffer get character.
002781r 1               ; =============================================================================
002781r 1               
002781r 1               ACIA_Buffer_Get:
002781r 1  78               SEI
002782r 1  20 rr rr         JSR     ACIA_Buffer_Diff     ; See if there is any serial data.
002785r 1  F0 14            BEQ     ACIA_Buffer_Get_None ; No data so exit.
002787r 1  20 rr rr         JSR     ACIA_Rd_Buffer       ; There is data so get it.
00278Ar 1               
00278Ar 1  20 rr rr         JSR     ACIA_Buffer_Diff     ; How many bytes are left to read?
00278Dr 1  C9 B4            CMP     #$B4                 ; Is it at least 180?
00278Fr 1  B0 03            BCS     ACIA_Buffer_Got      ; If so, leave the sending end turned off.
002791r 1  20 rr rr         JSR     Flow_On              ; Else re-enable sending.
002794r 1               
002794r 1               ACIA_Buffer_Got:
002794r 1  AD rr rr         LDA     acia1_rx_byte        ; Retrieve the data into A.
002797r 1  38               SEC                          ; Carry set if character available.
002798r 1  4C rr rr         JMP     ACIA_Buffer_Get_Done
00279Br 1               
00279Br 1               ACIA_Buffer_Get_None:
00279Br 1  18               CLC                          ; Carry clear if no character available.
00279Cr 1               
00279Cr 1               ACIA_Buffer_Get_Done:
00279Cr 1  58               CLI
00279Dr 1  60               RTS
00279Er 1               
00279Er 1               ; =============================================================================
00279Er 1               ; ACIA Interrupt.
00279Er 1               ; =============================================================================
00279Er 1               
00279Er 1               ACIA_Interrupt:
00279Er 1               
00279Er 1  48               PHA                             ; Store A.
00279Fr 1  8A               TXA                             ; Store X.
0027A0r 1  48               PHA
0027A1r 1  98               TYA                             ; Store Y.
0027A2r 1  48               PHA
0027A3r 1               
0027A3r 1  AD 01 48         LDA     acia1_s                 ; Take a copy of the status register.
0027A6r 1  8D rr rr         STA     acia1_s_copy            ; Reading it changes it!
0027A9r 1               
0027A9r 1  29 08            AND     #%00001000              ; Check for the receive data buffer full.
0027ABr 1  F0 29            BEQ     ACIA_Interrupt_Done     ; If empty we are done.
0027ADr 1               
0027ADr 1  AD rr rr         LDA     acia1_s_copy
0027B0r 1  29 07            AND     #%00000111              ; Check for error conditions (lower 3 bits of status).
0027B2r 1  D0 13            BNE     ACIA_Interrupt_Error    ; If there was any error go report it.
0027B4r 1               
0027B4r 1  AD 00 48         LDA     acia1_d                 ; Get the data from the ACIA.
0027B7r 1  20 rr rr         JSR     ACIA_Wr_Buffer          ; Write it to the buffer.
0027BAr 1               
0027BAr 1  20 rr rr         JSR     ACIA_Buffer_Diff        ; Now see how full the buffer is.
0027BDr 1  C9 DC            CMP     #$DC                    ; If it has less than 220 bytes unread
0027BFr 1  90 15            BCC     ACIA_Interrupt_Done     ; just exit the ISR here. Else stop
0027C1r 1                                                   ; the sending end.
0027C1r 1  20 rr rr         JSR     Flow_Off
0027C4r 1  4C rr rr         JMP     ACIA_Interrupt_Done
0027C7r 1               
0027C7r 1               ACIA_Interrupt_Error:
0027C7r 1  AD rr rr         LDA     acia1_s_copy
0027CAr 1  8D 00 60         STA     IO
0027CDr 1  20 rr rr         JSR     Beep2
0027D0r 1  AD 00 48         LDA     acia1_d                 ; Read the data register to clear it out.
0027D3r 1  20 rr rr         JSR     NORMAL					; Try to go back to normal mode.
0027D6r 1               
0027D6r 1               ACIA_Interrupt_Done:
0027D6r 1  68               PLA                             ; Restore Y.
0027D7r 1  A8               TAY
0027D8r 1  68               PLA                             ; Restore X.
0027D9r 1  AA               TAX
0027DAr 1  68               PLA                             ; Restore A.
0027DBr 1               
0027DBr 1  40               RTI
0027DCr 1               
0027DCr 1               ; =============================================================================
0027DCr 1               ; VIA Interrupt.
0027DCr 1               ; =============================================================================
0027DCr 1               
0027DCr 1               VIA_Interrupt:
0027DCr 1               
0027DCr 1               
0027DCr 1  48               PHA                             ; Store A.
0027DDr 1               
0027DDr 1  AD 0D 50     	LDA		via1_ifr				; Check which interrupt fired.
0027E0r 1  0A           	ASL 	A
0027E1r 1  0A           	ASL 	A
0027E2r 1  0A           	ASL 	A
0027E3r 1  30 03        	BMI 	VIA_Interrupt_CB1
0027E5r 1  4C rr rr     	JMP		VIA_Interrupt_Done
0027E8r 1               
0027E8r 1               VIA_Interrupt_CB1:
0027E8r 1  AD 00 50     	LDA		via1_b					; Read the port to clear the interrupt.
0027EBr 1  EE rr rr         INC		char_sending			; Make the flag non zero.
0027EEr 1               
0027EEr 1               VIA_Interrupt_Done:
0027EEr 1  68               PLA                             ; Restore A.
0027EFr 1  40               RTI
0027F0r 1               
0027F0r 1               ; =============================================================================
0027F0r 1               ; ISR
0027F0r 1               ; =============================================================================
0027F0r 1               
0027F0r 1               ISR:
0027F0r 1  6C rr rr         jmp     (int_vector1)   ; Jump to the interrupt vector handler.
0027F3r 1               ISR_V1:
0027F3r 1  2C 0D 50         BIT     via1_ifr        ; Check 6522 VIA1's status register without loading.
0027F6r 1  30 E4            BMI     VIA_Interrupt   ; Result negative (bit 7 set) so service VIA.
0027F8r 1               
0027F8r 1  2C 01 48         BIT     acia1_s         ; Check the status register (loads bit 7 into N and bit 6 into V).
0027FBr 1  30 A1            BMI     ACIA_Interrupt  ; Result negative (bit 7 set) so service ACIA.
0027FDr 1  6C rr rr         jmp     (int_vector2)   ; Jump to the interrupt vector handler.
002800r 1               ISR_V2:
002800r 1  40               RTI
002801r 1               
002801r 1               ; =============================================================================
002801r 1               
002801r 1               StartupMessage:
002801r 1  0D 0A 0A 43      .byte    $0D,$0A, $0A, "Cold [C] or warm [W] start?", $00
002805r 1  6F 6C 64 20  
002809r 1  5B 43 5D 20  
002820r 1               
002820r 1               
002820r 1               .segment "VECTS"
000000r 1               ;.org $FFFA
000000r 1  rr rr            .word    Reset      ; NMI.
000002r 1  rr rr            .word    Reset      ; Reset.
000004r 1  rr rr            .word    ISR        ; Interrupt.
000004r 1               
